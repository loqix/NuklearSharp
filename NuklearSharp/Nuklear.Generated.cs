// Generated by Sichem at 2/3/2018 5:51:25 PM

using System;
using System.Runtime.InteropServices;

namespace NuklearSharp
{
	unsafe partial class Nuklear
	{
		[StructLayout(LayoutKind.Sequential)]
		public struct nk_color
		{
			public byte r;
			public byte g;
			public byte b;
			public byte a;
		}

		[StructLayout(LayoutKind.Sequential)]
		public struct nk_colorf
		{
			public float r;
			public float g;
			public float b;
			public float a;
		}

		[StructLayout(LayoutKind.Sequential)]
		public struct nk_vec2
		{
			public float x;
			public float y;
		}

		[StructLayout(LayoutKind.Sequential)]
		public struct nk_vec2i
		{
			public short x;
			public short y;
		}

		[StructLayout(LayoutKind.Sequential)]
		public struct nk_rect
		{
			public float x;
			public float y;
			public float w;
			public float h;
		}

		[StructLayout(LayoutKind.Sequential)]
		public struct nk_recti
		{
			public short x;
			public short y;
			public short w;
			public short h;
		}

		public class nk_image
		{
			public nk_handle handle = new nk_handle();
			public ushort w;
			public ushort h;
			public PinnedArray<ushort> region = new PinnedArray<ushort>(4);
		}

		public class nk_cursor
		{
			public nk_image img = new nk_image();
			public nk_vec2 size = new nk_vec2();
			public nk_vec2 offset = new nk_vec2();
		}

		public class nk_scroll
		{
			public uint x;
			public uint y;
		}

		[StructLayout(LayoutKind.Sequential)]
		public struct nk_draw_null_texture
		{
			public nk_handle texture;
			public nk_vec2 uv;
		}

		public class nk_list_view
		{
			public int begin;
			public int end;
			public int count;
			public int total_height;
			public nk_context ctx;
			public uint* scroll_pointer;
			public uint scroll_value;
		}

		public class nk_baked_font
		{
			public float height;
			public float ascent;
			public float descent;
			public uint glyph_offset;
			public uint glyph_count;
			public uint* ranges;
		}

		public class nk_font_config
		{
			public nk_font_config next;
			public void* ttf_blob;
			public ulong ttf_size;
			public byte ttf_data_owned_by_atlas;
			public byte merge_mode;
			public byte pixel_snap;
			public byte oversample_v;
			public byte oversample_h;
			public PinnedArray<byte> padding = new PinnedArray<byte>(3);
			public float size;
			public int coord_type;
			public nk_vec2 spacing = new nk_vec2();
			public uint* range;
			public nk_baked_font font;
			public char fallback_glyph;
			public nk_font_config n;
			public nk_font_config p;
		}

		[StructLayout(LayoutKind.Sequential)]
		public struct nk_font_glyph
		{
			public char codepoint;
			public float xadvance;
			public float x0;
			public float y0;
			public float x1;
			public float y1;
			public float w;
			public float h;
			public float u0;
			public float v0;
			public float u1;
			public float v1;
		}

		[StructLayout(LayoutKind.Sequential)]
		public struct nk_memory_status
		{
			public void* memory;
			public uint type;
			public ulong size;
			public ulong allocated;
			public ulong needed;
			public ulong calls;
		}

		[StructLayout(LayoutKind.Sequential)]
		public struct nk_buffer_marker
		{
			public int active;
			public ulong offset;
		}

		[StructLayout(LayoutKind.Sequential)]
		public struct nk_memory
		{
			public void* ptr;
			public ulong size;
		}

		public class nk_str
		{
			public nk_buffer buffer = new nk_buffer();
			public int len;
		}

		[StructLayout(LayoutKind.Sequential)]
		public struct nk_text_undo_record
		{
			public int where;
			public short insert_length;
			public short delete_length;
			public short char_storage;
		}

		public class nk_text_edit
		{
			public nk_clipboard clip = new nk_clipboard();
			public nk_str _string_ = new nk_str();
			public NkPluginFilter filter;
			public nk_vec2 scrollbar = new nk_vec2();
			public int cursor;
			public int select_start;
			public int select_end;
			public byte mode;
			public byte cursor_at_end_of_line;
			public byte initialized;
			public byte has_preferred_x;
			public byte single_line;
			public byte active;
			public byte padding1;
			public float preferred_x;
			public nk_text_undo_state undo = new nk_text_undo_state();
		}

		[StructLayout(LayoutKind.Sequential)]
		public struct nk_command
		{
			public int type;
			public ulong next;
			public nk_handle userdata;
		}

		[StructLayout(LayoutKind.Sequential)]
		public struct nk_mouse_button
		{
			public int down;
			public uint clicked;
			public nk_vec2 clicked_pos;
		}

		[StructLayout(LayoutKind.Sequential)]
		public struct nk_key
		{
			public int down;
			public uint clicked;
		}

		public class nk_input
		{
			public nk_keyboard keyboard = new nk_keyboard();
			public nk_mouse mouse = new nk_mouse();
		}

		[StructLayout(LayoutKind.Sequential)]
		public struct nk_draw_vertex_layout_element
		{
			public int attribute;
			public int format;
			public ulong offset;
		}

		[StructLayout(LayoutKind.Sequential)]
		public struct nk_draw_command
		{
			public uint elem_count;
			public nk_rect clip_rect;
			public nk_handle texture;
			public nk_handle userdata;
		}

		public class nk_style_text
		{
			public nk_color color = new nk_color();
			public nk_vec2 padding = new nk_vec2();
		}

		public class nk_style_button
		{
			public nk_style_item normal = new nk_style_item();
			public nk_style_item hover = new nk_style_item();
			public nk_style_item active = new nk_style_item();
			public nk_color border_color = new nk_color();
			public nk_color text_background = new nk_color();
			public nk_color text_normal = new nk_color();
			public nk_color text_hover = new nk_color();
			public nk_color text_active = new nk_color();
			public uint text_alignment;
			public float border;
			public float rounding;
			public nk_vec2 padding = new nk_vec2();
			public nk_vec2 image_padding = new nk_vec2();
			public nk_vec2 touch_padding = new nk_vec2();
			public nk_handle userdata = new nk_handle();
			public NkDrawNotify draw_begin;
			public NkDrawNotify draw_end;
		}

		public class nk_style_toggle
		{
			public nk_style_item normal = new nk_style_item();
			public nk_style_item hover = new nk_style_item();
			public nk_style_item active = new nk_style_item();
			public nk_color border_color = new nk_color();
			public nk_style_item cursor_normal = new nk_style_item();
			public nk_style_item cursor_hover = new nk_style_item();
			public nk_color text_normal = new nk_color();
			public nk_color text_hover = new nk_color();
			public nk_color text_active = new nk_color();
			public nk_color text_background = new nk_color();
			public uint text_alignment;
			public nk_vec2 padding = new nk_vec2();
			public nk_vec2 touch_padding = new nk_vec2();
			public float spacing;
			public float border;
			public nk_handle userdata = new nk_handle();
			public NkDrawNotify draw_begin;
			public NkDrawNotify draw_end;
		}

		public class nk_style_selectable
		{
			public nk_style_item normal = new nk_style_item();
			public nk_style_item hover = new nk_style_item();
			public nk_style_item pressed = new nk_style_item();
			public nk_style_item normal_active = new nk_style_item();
			public nk_style_item hover_active = new nk_style_item();
			public nk_style_item pressed_active = new nk_style_item();
			public nk_color text_normal = new nk_color();
			public nk_color text_hover = new nk_color();
			public nk_color text_pressed = new nk_color();
			public nk_color text_normal_active = new nk_color();
			public nk_color text_hover_active = new nk_color();
			public nk_color text_pressed_active = new nk_color();
			public nk_color text_background = new nk_color();
			public uint text_alignment;
			public float rounding;
			public nk_vec2 padding = new nk_vec2();
			public nk_vec2 touch_padding = new nk_vec2();
			public nk_vec2 image_padding = new nk_vec2();
			public nk_handle userdata = new nk_handle();
			public NkDrawNotify draw_begin;
			public NkDrawNotify draw_end;
		}

		public class nk_style_slider
		{
			public nk_style_item normal = new nk_style_item();
			public nk_style_item hover = new nk_style_item();
			public nk_style_item active = new nk_style_item();
			public nk_color border_color = new nk_color();
			public nk_color bar_normal = new nk_color();
			public nk_color bar_hover = new nk_color();
			public nk_color bar_active = new nk_color();
			public nk_color bar_filled = new nk_color();
			public nk_style_item cursor_normal = new nk_style_item();
			public nk_style_item cursor_hover = new nk_style_item();
			public nk_style_item cursor_active = new nk_style_item();
			public float border;
			public float rounding;
			public float bar_height;
			public nk_vec2 padding = new nk_vec2();
			public nk_vec2 spacing = new nk_vec2();
			public nk_vec2 cursor_size = new nk_vec2();
			public int show_buttons;
			public nk_style_button inc_button = new nk_style_button();
			public nk_style_button dec_button = new nk_style_button();
			public int inc_symbol;
			public int dec_symbol;
			public nk_handle userdata = new nk_handle();
			public NkDrawNotify draw_begin;
			public NkDrawNotify draw_end;
		}

		public class nk_style_progress
		{
			public nk_style_item normal = new nk_style_item();
			public nk_style_item hover = new nk_style_item();
			public nk_style_item active = new nk_style_item();
			public nk_color border_color = new nk_color();
			public nk_style_item cursor_normal = new nk_style_item();
			public nk_style_item cursor_hover = new nk_style_item();
			public nk_style_item cursor_active = new nk_style_item();
			public nk_color cursor_border_color = new nk_color();
			public float rounding;
			public float border;
			public float cursor_border;
			public float cursor_rounding;
			public nk_vec2 padding = new nk_vec2();
			public nk_handle userdata = new nk_handle();
			public NkDrawNotify draw_begin;
			public NkDrawNotify draw_end;
		}

		public class nk_style_scrollbar
		{
			public nk_style_item normal = new nk_style_item();
			public nk_style_item hover = new nk_style_item();
			public nk_style_item active = new nk_style_item();
			public nk_color border_color = new nk_color();
			public nk_style_item cursor_normal = new nk_style_item();
			public nk_style_item cursor_hover = new nk_style_item();
			public nk_style_item cursor_active = new nk_style_item();
			public nk_color cursor_border_color = new nk_color();
			public float border;
			public float rounding;
			public float border_cursor;
			public float rounding_cursor;
			public nk_vec2 padding = new nk_vec2();
			public int show_buttons;
			public nk_style_button inc_button = new nk_style_button();
			public nk_style_button dec_button = new nk_style_button();
			public int inc_symbol;
			public int dec_symbol;
			public nk_handle userdata = new nk_handle();
			public NkDrawNotify draw_begin;
			public NkDrawNotify draw_end;
		}

		public class nk_style_edit
		{
			public nk_style_item normal = new nk_style_item();
			public nk_style_item hover = new nk_style_item();
			public nk_style_item active = new nk_style_item();
			public nk_color border_color = new nk_color();
			public nk_style_scrollbar scrollbar = new nk_style_scrollbar();
			public nk_color cursor_normal = new nk_color();
			public nk_color cursor_hover = new nk_color();
			public nk_color cursor_text_normal = new nk_color();
			public nk_color cursor_text_hover = new nk_color();
			public nk_color text_normal = new nk_color();
			public nk_color text_hover = new nk_color();
			public nk_color text_active = new nk_color();
			public nk_color selected_normal = new nk_color();
			public nk_color selected_hover = new nk_color();
			public nk_color selected_text_normal = new nk_color();
			public nk_color selected_text_hover = new nk_color();
			public float border;
			public float rounding;
			public float cursor_size;
			public nk_vec2 scrollbar_size = new nk_vec2();
			public nk_vec2 padding = new nk_vec2();
			public float row_padding;
		}

		public class nk_style_property
		{
			public nk_style_item normal = new nk_style_item();
			public nk_style_item hover = new nk_style_item();
			public nk_style_item active = new nk_style_item();
			public nk_color border_color = new nk_color();
			public nk_color label_normal = new nk_color();
			public nk_color label_hover = new nk_color();
			public nk_color label_active = new nk_color();
			public int sym_left;
			public int sym_right;
			public float border;
			public float rounding;
			public nk_vec2 padding = new nk_vec2();
			public nk_style_edit edit = new nk_style_edit();
			public nk_style_button inc_button = new nk_style_button();
			public nk_style_button dec_button = new nk_style_button();
			public nk_handle userdata = new nk_handle();
			public NkDrawNotify draw_begin;
			public NkDrawNotify draw_end;
		}

		public class nk_style_chart
		{
			public nk_style_item background = new nk_style_item();
			public nk_color border_color = new nk_color();
			public nk_color selected_color = new nk_color();
			public nk_color color = new nk_color();
			public float border;
			public float rounding;
			public nk_vec2 padding = new nk_vec2();
		}

		public class nk_style_combo
		{
			public nk_style_item normal = new nk_style_item();
			public nk_style_item hover = new nk_style_item();
			public nk_style_item active = new nk_style_item();
			public nk_color border_color = new nk_color();
			public nk_color label_normal = new nk_color();
			public nk_color label_hover = new nk_color();
			public nk_color label_active = new nk_color();
			public nk_color symbol_normal = new nk_color();
			public nk_color symbol_hover = new nk_color();
			public nk_color symbol_active = new nk_color();
			public nk_style_button button = new nk_style_button();
			public int sym_normal;
			public int sym_hover;
			public int sym_active;
			public float border;
			public float rounding;
			public nk_vec2 content_padding = new nk_vec2();
			public nk_vec2 button_padding = new nk_vec2();
			public nk_vec2 spacing = new nk_vec2();
		}

		public class nk_style_tab
		{
			public nk_style_item background = new nk_style_item();
			public nk_color border_color = new nk_color();
			public nk_color text = new nk_color();
			public nk_style_button tab_maximize_button = new nk_style_button();
			public nk_style_button tab_minimize_button = new nk_style_button();
			public nk_style_button node_maximize_button = new nk_style_button();
			public nk_style_button node_minimize_button = new nk_style_button();
			public int sym_minimize;
			public int sym_maximize;
			public float border;
			public float rounding;
			public float indent;
			public nk_vec2 padding = new nk_vec2();
			public nk_vec2 spacing = new nk_vec2();
		}

		public class nk_style_window_header
		{
			public nk_style_item normal = new nk_style_item();
			public nk_style_item hover = new nk_style_item();
			public nk_style_item active = new nk_style_item();
			public nk_style_button close_button = new nk_style_button();
			public nk_style_button minimize_button = new nk_style_button();
			public int close_symbol;
			public int minimize_symbol;
			public int maximize_symbol;
			public nk_color label_normal = new nk_color();
			public nk_color label_hover = new nk_color();
			public nk_color label_active = new nk_color();
			public int align;
			public nk_vec2 padding = new nk_vec2();
			public nk_vec2 label_padding = new nk_vec2();
			public nk_vec2 spacing = new nk_vec2();
		}

		public class nk_style_window
		{
			public nk_style_window_header header = new nk_style_window_header();
			public nk_style_item fixed_background = new nk_style_item();
			public nk_color background = new nk_color();
			public nk_color border_color = new nk_color();
			public nk_color popup_border_color = new nk_color();
			public nk_color combo_border_color = new nk_color();
			public nk_color contextual_border_color = new nk_color();
			public nk_color menu_border_color = new nk_color();
			public nk_color group_border_color = new nk_color();
			public nk_color tooltip_border_color = new nk_color();
			public nk_style_item scaler = new nk_style_item();
			public float border;
			public float combo_border;
			public float contextual_border;
			public float menu_border;
			public float group_border;
			public float tooltip_border;
			public float popup_border;
			public float min_row_height_padding;
			public float rounding;
			public nk_vec2 spacing = new nk_vec2();
			public nk_vec2 scrollbar_size = new nk_vec2();
			public nk_vec2 min_size = new nk_vec2();
			public nk_vec2 padding = new nk_vec2();
			public nk_vec2 group_padding = new nk_vec2();
			public nk_vec2 popup_padding = new nk_vec2();
			public nk_vec2 combo_padding = new nk_vec2();
			public nk_vec2 contextual_padding = new nk_vec2();
			public nk_vec2 menu_padding = new nk_vec2();
			public nk_vec2 tooltip_padding = new nk_vec2();
		}

		public class nk_chart_slot
		{
			public int type;
			public nk_color color = new nk_color();
			public nk_color highlight = new nk_color();
			public float min;
			public float max;
			public float range;
			public int count;
			public nk_vec2 last = new nk_vec2();
			public int index;
		}

		public class nk_row_layout
		{
			public int type;
			public int index;
			public float height;
			public float min_height;
			public int columns;
			public float* ratio;
			public float item_width;
			public float item_height;
			public float item_offset;
			public float filled;
			public nk_rect item = new nk_rect();
			public int tree_depth;
			public PinnedArray<float> templates = new PinnedArray<float>(16);
		}

		public class nk_popup_buffer
		{
			public ulong begin;
			public ulong parent;
			public ulong last;
			public ulong end;
			public int active;
		}

		[StructLayout(LayoutKind.Sequential)]
		public struct nk_menu_state
		{
			public float x;
			public float y;
			public float w;
			public float h;
			public nk_scroll offset;
		}

		public class nk_popup_state
		{
			public nk_window win;
			public int type;
			public nk_popup_buffer buf = new nk_popup_buffer();
			public uint name;
			public int active;
			public uint combo_count;
			public uint con_count;
			public uint con_old;
			public uint active_con;
			public nk_rect header = new nk_rect();
		}

		public class nk_edit_state
		{
			public uint name;
			public uint seq;
			public uint old;
			public int active;
			public int prev;
			public int cursor;
			public int sel_start;
			public int sel_end;
			public nk_scroll scrollbar = new nk_scroll();
			public byte mode;
			public byte single_line;
		}

		public class nk_property_state
		{
			public int active;
			public int prev;
			public PinnedArray<sbyte> buffer = new PinnedArray<sbyte>(64);
			public int length;
			public int cursor;
			public int select_start;
			public int select_end;
			public uint name;
			public uint seq;
			public uint old;
			public int state;
		}

		public class nk_config_stack_style_item_element
		{
			public nk_style_item address;
			public nk_style_item old_value = new nk_style_item();
		}

		[StructLayout(LayoutKind.Sequential)]
		public struct nk_config_stack_float_element
		{
			public float* address;
			public float old_value;
		}

		[StructLayout(LayoutKind.Sequential)]
		public struct nk_config_stack_vec2_element
		{
			public nk_vec2* address;
			public nk_vec2 old_value;
		}

		[StructLayout(LayoutKind.Sequential)]
		public struct nk_config_stack_flags_element
		{
			public uint* address;
			public uint old_value;
		}

		[StructLayout(LayoutKind.Sequential)]
		public struct nk_config_stack_color_element
		{
			public nk_color* address;
			public nk_color old_value;
		}

		public class nk_config_stack_user_font_element
		{
			public nk_user_font address;
			public nk_user_font old_value;
		}

		public class nk_config_stack_style_item
		{
			public int head;
			public nk_config_stack_style_item_element[] elements = new nk_config_stack_style_item_element[16];
		}

		public class nk_config_stack_float
		{
			public int head;
			public PinnedArray<nk_config_stack_float_element> elements = new PinnedArray<nk_config_stack_float_element>(32);
		}

		public class nk_config_stack_vec2
		{
			public int head;
			public PinnedArray<nk_config_stack_vec2_element> elements = new PinnedArray<nk_config_stack_vec2_element>(16);
		}

		public class nk_config_stack_flags
		{
			public int head;
			public PinnedArray<nk_config_stack_flags_element> elements = new PinnedArray<nk_config_stack_flags_element>(32);
		}

		public class nk_config_stack_color
		{
			public int head;
			public PinnedArray<nk_config_stack_color_element> elements = new PinnedArray<nk_config_stack_color_element>(32);
		}

		public class nk_config_stack_user_font
		{
			public int head;
			public nk_config_stack_user_font_element[] elements = new nk_config_stack_user_font_element[8];
		}

		public class nk_config_stack_button_behavior
		{
			public int head;

			public PinnedArray<nk_config_stack_button_behavior_element> elements =
				new PinnedArray<nk_config_stack_button_behavior_element>(8);
		}

		public class nk_configuration_stacks
		{
			public nk_config_stack_style_item style_items = new nk_config_stack_style_item();
			public nk_config_stack_float floats = new nk_config_stack_float();
			public nk_config_stack_vec2 vectors = new nk_config_stack_vec2();
			public nk_config_stack_flags flags = new nk_config_stack_flags();
			public nk_config_stack_color colors = new nk_config_stack_color();
			public nk_config_stack_user_font fonts = new nk_config_stack_user_font();
			public nk_config_stack_button_behavior button_behaviors = new nk_config_stack_button_behavior();
		}

		public class nk_table
		{
			public uint seq;
			public uint size;
			public PinnedArray<uint> keys = new PinnedArray<uint>(51);
			public PinnedArray<uint> values = new PinnedArray<uint>(51);
			public nk_table next;
			public nk_table prev;
		}

		[StructLayout(LayoutKind.Sequential)]
		public struct conv
		{
			public uint i;
			public float f;
		}

		[StructLayout(LayoutKind.Sequential)]
		public struct nk_rp_rect
		{
			public int id;
			public ushort w;
			public ushort h;
			public ushort x;
			public ushort y;
			public int was_packed;
		}

		[StructLayout(LayoutKind.Sequential)]
		public struct nk_rp_node
		{
			public ushort x;
			public ushort y;
			public nk_rp_node* next;
		}

		[StructLayout(LayoutKind.Sequential)]
		public struct nk_rp__findresult
		{
			public int x;
			public int y;
			public nk_rp_node** prev_link;
		}

		[StructLayout(LayoutKind.Sequential)]
		public struct nk_tt_bakedchar
		{
			public ushort x0;
			public ushort y0;
			public ushort x1;
			public ushort y1;
			public float xoff;
			public float yoff;
			public float xadvance;
		}

		[StructLayout(LayoutKind.Sequential)]
		public struct nk_tt_aligned_quad
		{
			public float x0;
			public float y0;
			public float s0;
			public float t0;
			public float x1;
			public float y1;
			public float s1;
			public float t1;
		}

		[StructLayout(LayoutKind.Sequential)]
		public struct nk_tt_packedchar
		{
			public ushort x0;
			public ushort y0;
			public ushort x1;
			public ushort y1;
			public float xoff;
			public float yoff;
			public float xadvance;
			public float xoff2;
			public float yoff2;
		}

		[StructLayout(LayoutKind.Sequential)]
		public struct nk_tt_pack_range
		{
			public float font_size;
			public int first_unicode_codepoint_in_range;
			public int* array_of_unicode_codepoints;
			public int num_chars;
			public nk_tt_packedchar* chardata_for_range;
			public byte h_oversample;
			public byte v_oversample;
		}

		[StructLayout(LayoutKind.Sequential)]
		public struct nk_tt_pack_context
		{
			public void* pack_info;
			public int width;
			public int height;
			public int stride_in_bytes;
			public int padding;
			public uint h_oversample;
			public uint v_oversample;
			public byte* pixels;
			public void* nodes;
		}

		[StructLayout(LayoutKind.Sequential)]
		public struct nk_tt_fontinfo
		{
			public byte* data;
			public int fontstart;
			public int numGlyphs;
			public int loca;
			public int head;
			public int glyf;
			public int hhea;
			public int hmtx;
			public int kern;
			public int index_map;
			public int indexToLocFormat;
		}

		[StructLayout(LayoutKind.Sequential)]
		public struct nk_tt_vertex
		{
			public short x;
			public short y;
			public short cx;
			public short cy;
			public byte type;
			public byte padding;
		}

		[StructLayout(LayoutKind.Sequential)]
		public struct nk_tt__bitmap
		{
			public int w;
			public int h;
			public int stride;
			public byte* pixels;
		}

		[StructLayout(LayoutKind.Sequential)]
		public struct nk_tt__hheap_chunk
		{
			public nk_tt__hheap_chunk* next;
		}

		[StructLayout(LayoutKind.Sequential)]
		public struct nk_tt__hheap
		{

			public nk_tt__hheap_chunk* head;
			public void* first_free;
			public int num_remaining_in_head_chunk;
		}

		[StructLayout(LayoutKind.Sequential)]
		public struct nk_tt__edge
		{
			public float x0;
			public float y0;
			public float x1;
			public float y1;
			public int invert;
		}

		[StructLayout(LayoutKind.Sequential)]
		public struct nk_tt__active_edge
		{
			public nk_tt__active_edge* next;
			public float fx;
			public float fdx;
			public float fdy;
			public float direction;
			public float sy;
			public float ey;
		}

		[StructLayout(LayoutKind.Sequential)]
		public struct nk_tt__point
		{
			public float x;
			public float y;
		}

		[StructLayout(LayoutKind.Sequential)]
		public struct nk_font_bake_data
		{
			public nk_tt_fontinfo info;
			public nk_rp_rect* rects;
			public nk_tt_pack_range* ranges;
			public uint range_count;
		}

		[StructLayout(LayoutKind.Sequential)]
		public struct nk_font_baker
		{

			public nk_tt_pack_context spc;
			public nk_font_bake_data* build;
			public nk_tt_packedchar* packed_chars;
			public nk_rp_rect* rects;
			public nk_tt_pack_range* ranges;
		}

		[StructLayout(LayoutKind.Sequential)]
		public struct nk_text_find
		{
			public float x;
			public float y;
			public float height;
			public int first_char;
			public int length;
			public int prev_first;
		}

		[StructLayout(LayoutKind.Sequential)]
		public struct nk_text_edit_row
		{
			public float x0;
			public float x1;
			public float baseline_y_delta;
			public float ymin;
			public float ymax;
			public int num_chars;
		}

		[StructLayout(LayoutKind.Sequential)]
		public struct nk_text
		{
			public nk_vec2 padding;
			public nk_color background;
			public nk_color text;
		}

		public const int nk_false = 0;
		public const int nk_true = 1;
		public const int NK_UP = 0;
		public const int NK_RIGHT = 1;
		public const int NK_DOWN = 2;
		public const int NK_LEFT = 3;
		public const int NK_BUTTON_DEFAULT = 0;
		public const int NK_BUTTON_REPEATER = 1;
		public const int NK_FIXED = nk_false;
		public const int NK_MODIFIABLE = nk_true;
		public const int NK_VERTICAL = 0;
		public const int NK_HORIZONTAL = 1;
		public const int NK_MINIMIZED = nk_false;
		public const int NK_MAXIMIZED = nk_true;
		public const int NK_HIDDEN = nk_false;
		public const int NK_SHOWN = nk_true;
		public const int NK_CHART_LINES = 0;
		public const int NK_CHART_COLUMN = 1;
		public const int NK_CHART_MAX = 2;
		public const int NK_CHART_HOVERING = 0x01;
		public const int NK_CHART_CLICKED = 0x02;
		public const int NK_RGB = 0;
		public const int NK_RGBA = 1;
		public const int NK_POPUP_STATIC = 0;
		public const int NK_POPUP_DYNAMIC = 1;
		public const int NK_DYNAMIC = 0;
		public const int NK_STATIC = 1;
		public const int NK_TREE_NODE = 0;
		public const int NK_TREE_TAB = 1;
		public const int NK_SYMBOL_NONE = 0;
		public const int NK_SYMBOL_X = 1;
		public const int NK_SYMBOL_UNDERSCORE = 2;
		public const int NK_SYMBOL_CIRCLE_SOLID = 3;
		public const int NK_SYMBOL_CIRCLE_OUTLINE = 4;
		public const int NK_SYMBOL_RECT_SOLID = 5;
		public const int NK_SYMBOL_RECT_OUTLINE = 6;
		public const int NK_SYMBOL_TRIANGLE_UP = 7;
		public const int NK_SYMBOL_TRIANGLE_DOWN = 8;
		public const int NK_SYMBOL_TRIANGLE_LEFT = 9;
		public const int NK_SYMBOL_TRIANGLE_RIGHT = 10;
		public const int NK_SYMBOL_PLUS = 11;
		public const int NK_SYMBOL_MINUS = 12;
		public const int NK_SYMBOL_MAX = 13;
		public const int NK_KEY_NONE = 0;
		public const int NK_KEY_SHIFT = 1;
		public const int NK_KEY_CTRL = 2;
		public const int NK_KEY_DEL = 3;
		public const int NK_KEY_ENTER = 4;
		public const int NK_KEY_TAB = 5;
		public const int NK_KEY_BACKSPACE = 6;
		public const int NK_KEY_COPY = 7;
		public const int NK_KEY_CUT = 8;
		public const int NK_KEY_PASTE = 9;
		public const int NK_KEY_UP = 10;
		public const int NK_KEY_DOWN = 11;
		public const int NK_KEY_LEFT = 12;
		public const int NK_KEY_RIGHT = 13;
		public const int NK_KEY_TEXT_INSERT_MODE = 14;
		public const int NK_KEY_TEXT_REPLACE_MODE = 15;
		public const int NK_KEY_TEXT_RESET_MODE = 16;
		public const int NK_KEY_TEXT_LINE_START = 17;
		public const int NK_KEY_TEXT_LINE_END = 18;
		public const int NK_KEY_TEXT_START = 19;
		public const int NK_KEY_TEXT_END = 20;
		public const int NK_KEY_TEXT_UNDO = 21;
		public const int NK_KEY_TEXT_REDO = 22;
		public const int NK_KEY_TEXT_SELECT_ALL = 23;
		public const int NK_KEY_TEXT_WORD_LEFT = 24;
		public const int NK_KEY_TEXT_WORD_RIGHT = 25;
		public const int NK_KEY_SCROLL_START = 26;
		public const int NK_KEY_SCROLL_END = 27;
		public const int NK_KEY_SCROLL_DOWN = 28;
		public const int NK_KEY_SCROLL_UP = 29;
		public const int NK_KEY_MAX = 30;
		public const int NK_BUTTON_LEFT = 0;
		public const int NK_BUTTON_MIDDLE = 1;
		public const int NK_BUTTON_RIGHT = 2;
		public const int NK_BUTTON_DOUBLE = 3;
		public const int NK_BUTTON_MAX = 4;
		public const int NK_ANTI_ALIASING_OFF = 0;
		public const int NK_ANTI_ALIASING_ON = 1;
		public const int NK_CONVERT_SUCCESS = 0;
		public const int NK_CONVERT_INVALID_PARAM = 1;
		public const int NK_CONVERT_COMMAND_BUFFER_FULL = (1 << (1));
		public const int NK_CONVERT_VERTEX_BUFFER_FULL = (1 << (2));
		public const int NK_CONVERT_ELEMENT_BUFFER_FULL = (1 << (3));
		public const int NK_WINDOW_BORDER = (1 << (0));
		public const int NK_WINDOW_MOVABLE = (1 << (1));
		public const int NK_WINDOW_SCALABLE = (1 << (2));
		public const int NK_WINDOW_CLOSABLE = (1 << (3));
		public const int NK_WINDOW_MINIMIZABLE = (1 << (4));
		public const int NK_WINDOW_NO_SCROLLBAR = (1 << (5));
		public const int NK_WINDOW_TITLE = (1 << (6));
		public const int NK_WINDOW_SCROLL_AUTO_HIDE = (1 << (7));
		public const int NK_WINDOW_BACKGROUND = (1 << (8));
		public const int NK_WINDOW_SCALE_LEFT = (1 << (9));
		public const int NK_WINDOW_NO_INPUT = (1 << (10));
		public const int NK_WIDGET_INVALID = 0;
		public const int NK_WIDGET_VALID = 1;
		public const int NK_WIDGET_ROM = 2;
		public const int NK_WIDGET_STATE_MODIFIED = (1 << (1));
		public const int NK_WIDGET_STATE_INACTIVE = (1 << (2));
		public const int NK_WIDGET_STATE_ENTERED = (1 << (3));
		public const int NK_WIDGET_STATE_HOVER = (1 << (4));
		public const int NK_WIDGET_STATE_ACTIVED = (1 << (5));
		public const int NK_WIDGET_STATE_LEFT = (1 << (6));
		public const int NK_WIDGET_STATE_HOVERED = NK_WIDGET_STATE_HOVER | NK_WIDGET_STATE_MODIFIED;
		public const int NK_WIDGET_STATE_ACTIVE = NK_WIDGET_STATE_ACTIVED | NK_WIDGET_STATE_MODIFIED;
		public const int NK_TEXT_ALIGN_LEFT = 0x01;
		public const int NK_TEXT_ALIGN_CENTERED = 0x02;
		public const int NK_TEXT_ALIGN_RIGHT = 0x04;
		public const int NK_TEXT_ALIGN_TOP = 0x08;
		public const int NK_TEXT_ALIGN_MIDDLE = 0x10;
		public const int NK_TEXT_ALIGN_BOTTOM = 0x20;
		public const int NK_TEXT_LEFT = NK_TEXT_ALIGN_MIDDLE | NK_TEXT_ALIGN_LEFT;
		public const int NK_TEXT_CENTERED = NK_TEXT_ALIGN_MIDDLE | NK_TEXT_ALIGN_CENTERED;
		public const int NK_TEXT_RIGHT = NK_TEXT_ALIGN_MIDDLE | NK_TEXT_ALIGN_RIGHT;
		public const int NK_EDIT_DEFAULT = 0;
		public const int NK_EDIT_READ_ONLY = (1 << (0));
		public const int NK_EDIT_AUTO_SELECT = (1 << (1));
		public const int NK_EDIT_SIG_ENTER = (1 << (2));
		public const int NK_EDIT_ALLOW_TAB = (1 << (3));
		public const int NK_EDIT_NO_CURSOR = (1 << (4));
		public const int NK_EDIT_SELECTABLE = (1 << (5));
		public const int NK_EDIT_CLIPBOARD = (1 << (6));
		public const int NK_EDIT_CTRL_ENTER_NEWLINE = (1 << (7));
		public const int NK_EDIT_NO_HORIZONTAL_SCROLL = (1 << (8));
		public const int NK_EDIT_ALWAYS_INSERT_MODE = (1 << (9));
		public const int NK_EDIT_MULTILINE = (1 << (10));
		public const int NK_EDIT_GOTO_END_ON_ACTIVATE = (1 << (11));
		public const int NK_EDIT_SIMPLE = NK_EDIT_ALWAYS_INSERT_MODE;
		public const int NK_EDIT_FIELD = NK_EDIT_SIMPLE | NK_EDIT_SELECTABLE | NK_EDIT_CLIPBOARD;

		public const int NK_EDIT_BOX =
			NK_EDIT_ALWAYS_INSERT_MODE | NK_EDIT_SELECTABLE | NK_EDIT_MULTILINE | NK_EDIT_ALLOW_TAB | NK_EDIT_CLIPBOARD;

		public const int NK_EDIT_EDITOR = NK_EDIT_SELECTABLE | NK_EDIT_MULTILINE | NK_EDIT_ALLOW_TAB | NK_EDIT_CLIPBOARD;
		public const int NK_EDIT_ACTIVE = (1 << (0));
		public const int NK_EDIT_INACTIVE = (1 << (1));
		public const int NK_EDIT_ACTIVATED = (1 << (2));
		public const int NK_EDIT_DEACTIVATED = (1 << (3));
		public const int NK_EDIT_COMMITED = (1 << (4));
		public const int NK_COLOR_TEXT = 0;
		public const int NK_COLOR_WINDOW = 1;
		public const int NK_COLOR_HEADER = 2;
		public const int NK_COLOR_BORDER = 3;
		public const int NK_COLOR_BUTTON = 4;
		public const int NK_COLOR_BUTTON_HOVER = 5;
		public const int NK_COLOR_BUTTON_ACTIVE = 6;
		public const int NK_COLOR_TOGGLE = 7;
		public const int NK_COLOR_TOGGLE_HOVER = 8;
		public const int NK_COLOR_TOGGLE_CURSOR = 9;
		public const int NK_COLOR_SELECT = 10;
		public const int NK_COLOR_SELECT_ACTIVE = 11;
		public const int NK_COLOR_SLIDER = 12;
		public const int NK_COLOR_SLIDER_CURSOR = 13;
		public const int NK_COLOR_SLIDER_CURSOR_HOVER = 14;
		public const int NK_COLOR_SLIDER_CURSOR_ACTIVE = 15;
		public const int NK_COLOR_PROPERTY = 16;
		public const int NK_COLOR_EDIT = 17;
		public const int NK_COLOR_EDIT_CURSOR = 18;
		public const int NK_COLOR_COMBO = 19;
		public const int NK_COLOR_CHART = 20;
		public const int NK_COLOR_CHART_COLOR = 21;
		public const int NK_COLOR_CHART_COLOR_HIGHLIGHT = 22;
		public const int NK_COLOR_SCROLLBAR = 23;
		public const int NK_COLOR_SCROLLBAR_CURSOR = 24;
		public const int NK_COLOR_SCROLLBAR_CURSOR_HOVER = 25;
		public const int NK_COLOR_SCROLLBAR_CURSOR_ACTIVE = 26;
		public const int NK_COLOR_TAB_HEADER = 27;
		public const int NK_COLOR_COUNT = 28;
		public const int NK_CURSOR_ARROW = 0;
		public const int NK_CURSOR_TEXT = 1;
		public const int NK_CURSOR_MOVE = 2;
		public const int NK_CURSOR_RESIZE_VERTICAL = 3;
		public const int NK_CURSOR_RESIZE_HORIZONTAL = 4;
		public const int NK_CURSOR_RESIZE_TOP_LEFT_DOWN_RIGHT = 5;
		public const int NK_CURSOR_RESIZE_TOP_RIGHT_DOWN_LEFT = 6;
		public const int NK_CURSOR_COUNT = 7;
		public const int NK_COORD_UV = 0;
		public const int NK_COORD_PIXEL = 1;
		public const int NK_FONT_ATLAS_ALPHA8 = 0;
		public const int NK_FONT_ATLAS_RGBA32 = 1;
		public const int NK_BUFFER_FIXED = 0;
		public const int NK_BUFFER_DYNAMIC = 1;
		public const int NK_BUFFER_FRONT = 0;
		public const int NK_BUFFER_BACK = 1;
		public const int NK_BUFFER_MAX = 2;
		public const int NK_TEXT_EDIT_SINGLE_LINE = 0;
		public const int NK_TEXT_EDIT_MULTI_LINE = 1;
		public const int NK_TEXT_EDIT_MODE_VIEW = 0;
		public const int NK_TEXT_EDIT_MODE_INSERT = 1;
		public const int NK_TEXT_EDIT_MODE_REPLACE = 2;
		public const int NK_COMMAND_NOP = 0;
		public const int NK_COMMAND_SCISSOR = 1;
		public const int NK_COMMAND_LINE = 2;
		public const int NK_COMMAND_CURVE = 3;
		public const int NK_COMMAND_RECT = 4;
		public const int NK_COMMAND_RECT_FILLED = 5;
		public const int NK_COMMAND_RECT_MULTI_COLOR = 6;
		public const int NK_COMMAND_CIRCLE = 7;
		public const int NK_COMMAND_CIRCLE_FILLED = 8;
		public const int NK_COMMAND_ARC = 9;
		public const int NK_COMMAND_ARC_FILLED = 10;
		public const int NK_COMMAND_TRIANGLE = 11;
		public const int NK_COMMAND_TRIANGLE_FILLED = 12;
		public const int NK_COMMAND_POLYGON = 13;
		public const int NK_COMMAND_POLYGON_FILLED = 14;
		public const int NK_COMMAND_POLYLINE = 15;
		public const int NK_COMMAND_TEXT = 16;
		public const int NK_COMMAND_IMAGE = 17;
		public const int NK_COMMAND_CUSTOM = 18;
		public const int NK_CLIPPING_OFF = nk_false;
		public const int NK_CLIPPING_ON = nk_true;
		public const int NK_STROKE_OPEN = nk_false;
		public const int NK_STROKE_CLOSED = nk_true;
		public const int NK_VERTEX_POSITION = 0;
		public const int NK_VERTEX_COLOR = 1;
		public const int NK_VERTEX_TEXCOORD = 2;
		public const int NK_VERTEX_ATTRIBUTE_COUNT = 3;
		public const int NK_FORMAT_SCHAR = 0;
		public const int NK_FORMAT_SSHORT = 1;
		public const int NK_FORMAT_SINT = 2;
		public const int NK_FORMAT_UCHAR = 3;
		public const int NK_FORMAT_USHORT = 4;
		public const int NK_FORMAT_UINT = 5;
		public const int NK_FORMAT_FLOAT = 6;
		public const int NK_FORMAT_DOUBLE = 7;
		public const int NK_FORMAT_COLOR_BEGIN = 8;
		public const int NK_FORMAT_R8G8B8 = NK_FORMAT_COLOR_BEGIN;
		public const int NK_FORMAT_R16G15B16 = 10;
		public const int NK_FORMAT_R32G32B32 = 11;
		public const int NK_FORMAT_R8G8B8A8 = 12;
		public const int NK_FORMAT_B8G8R8A8 = 13;
		public const int NK_FORMAT_R16G15B16A16 = 14;
		public const int NK_FORMAT_R32G32B32A32 = 15;
		public const int NK_FORMAT_R32G32B32A32_FLOAT = 16;
		public const int NK_FORMAT_R32G32B32A32_DOUBLE = 17;
		public const int NK_FORMAT_RGB32 = 18;
		public const int NK_FORMAT_RGBA32 = 19;
		public const int NK_FORMAT_COLOR_END = NK_FORMAT_RGBA32;
		public const int NK_FORMAT_COUNT = 21;
		public const int NK_STYLE_ITEM_COLOR = 0;
		public const int NK_STYLE_ITEM_IMAGE = 1;
		public const int NK_HEADER_LEFT = 0;
		public const int NK_HEADER_RIGHT = 1;
		public const int NK_PANEL_WINDOW = (1 << (0));
		public const int NK_PANEL_GROUP = (1 << (1));
		public const int NK_PANEL_POPUP = (1 << (2));
		public const int NK_PANEL_CONTEXTUAL = (1 << (4));
		public const int NK_PANEL_COMBO = (1 << (5));
		public const int NK_PANEL_MENU = (1 << (6));
		public const int NK_PANEL_TOOLTIP = (1 << (7));
		public const int NK_PANEL_SET_NONBLOCK = NK_PANEL_CONTEXTUAL | NK_PANEL_COMBO | NK_PANEL_MENU | NK_PANEL_TOOLTIP;
		public const int NK_PANEL_SET_POPUP = NK_PANEL_SET_NONBLOCK | NK_PANEL_POPUP;
		public const int NK_PANEL_SET_SUB = NK_PANEL_SET_POPUP | NK_PANEL_GROUP;
		public const int NK_LAYOUT_DYNAMIC_FIXED = 0;
		public const int NK_LAYOUT_DYNAMIC_ROW = 1;
		public const int NK_LAYOUT_DYNAMIC_FREE = 2;
		public const int NK_LAYOUT_DYNAMIC = 3;
		public const int NK_LAYOUT_STATIC_FIXED = 4;
		public const int NK_LAYOUT_STATIC_ROW = 5;
		public const int NK_LAYOUT_STATIC_FREE = 6;
		public const int NK_LAYOUT_STATIC = 7;
		public const int NK_LAYOUT_TEMPLATE = 8;
		public const int NK_LAYOUT_COUNT = 9;
		public const int NK_WINDOW_PRIVATE = (1 << (11));
		public const int NK_WINDOW_DYNAMIC = NK_WINDOW_PRIVATE;
		public const int NK_WINDOW_ROM = (1 << (12));
		public const int NK_WINDOW_NOT_INTERACTIVE = NK_WINDOW_ROM | NK_WINDOW_NO_INPUT;
		public const int NK_WINDOW_HIDDEN = (1 << (13));
		public const int NK_WINDOW_CLOSED = (1 << (14));
		public const int NK_WINDOW_MINIMIZED = (1 << (15));
		public const int NK_WINDOW_REMOVE_ROM = (1 << (16));
		public const int NK_DO_NOT_STOP_ON_NEW_LINE = 0;
		public const int NK_STOP_ON_NEW_LINE = 1;
		public const int NK_RP_HEURISTIC_Skyline_default = 0;
		public const int NK_RP_HEURISTIC_Skyline_BL_sortHeight = NK_RP_HEURISTIC_Skyline_default;
		public const int NK_RP_HEURISTIC_Skyline_BF_sortHeight = 2;
		public const int NK_RP__INIT_skyline = 1;
		public const int NK_TT_vmove = 1;
		public const int NK_TT_vline = 2;
		public const int NK_TT_vcurve = 3;
		public const int NK_TT_PLATFORM_ID_UNICODE = 0;
		public const int NK_TT_PLATFORM_ID_MAC = 1;
		public const int NK_TT_PLATFORM_ID_ISO = 2;
		public const int NK_TT_PLATFORM_ID_MICROSOFT = 3;
		public const int NK_TT_UNICODE_EID_UNICODE_1_0 = 0;
		public const int NK_TT_UNICODE_EID_UNICODE_1_1 = 1;
		public const int NK_TT_UNICODE_EID_ISO_10646 = 2;
		public const int NK_TT_UNICODE_EID_UNICODE_2_0_BMP = 3;
		public const int NK_TT_UNICODE_EID_UNICODE_2_0_FULL = 4;
		public const int NK_TT_MS_EID_SYMBOL = 0;
		public const int NK_TT_MS_EID_UNICODE_BMP = 1;
		public const int NK_TT_MS_EID_SHIFTJIS = 2;
		public const int NK_TT_MS_EID_UNICODE_FULL = 10;
		public const int NK_TT_MAC_EID_ROMAN = 0;
		public const int NK_TT_MAC_EID_ARABIC = 4;
		public const int NK_TT_MAC_EID_JAPANESE = 1;
		public const int NK_TT_MAC_EID_HEBREW = 5;
		public const int NK_TT_MAC_EID_CHINESE_TRAD = 2;
		public const int NK_TT_MAC_EID_GREEK = 6;
		public const int NK_TT_MAC_EID_KOREAN = 3;
		public const int NK_TT_MAC_EID_RUSSIAN = 7;
		public const int NK_TT_MS_LANG_ENGLISH = 0x0409;
		public const int NK_TT_MS_LANG_ITALIAN = 0x0410;
		public const int NK_TT_MS_LANG_CHINESE = 0x0804;
		public const int NK_TT_MS_LANG_JAPANESE = 0x0411;
		public const int NK_TT_MS_LANG_DUTCH = 0x0413;
		public const int NK_TT_MS_LANG_KOREAN = 0x0412;
		public const int NK_TT_MS_LANG_FRENCH = 0x040c;
		public const int NK_TT_MS_LANG_RUSSIAN = 0x0419;
		public const int NK_TT_MS_LANG_GERMAN = 0x0407;
		public const int NK_TT_MS_LANG_SPANISH = 0x0409;
		public const int NK_TT_MS_LANG_HEBREW = 0x040d;
		public const int NK_TT_MS_LANG_SWEDISH = 0x041D;
		public const int NK_TT_MAC_LANG_ENGLISH = 0;
		public const int NK_TT_MAC_LANG_JAPANESE = 11;
		public const int NK_TT_MAC_LANG_ARABIC = 12;
		public const int NK_TT_MAC_LANG_KOREAN = 23;
		public const int NK_TT_MAC_LANG_DUTCH = 4;
		public const int NK_TT_MAC_LANG_RUSSIAN = 32;
		public const int NK_TT_MAC_LANG_FRENCH = 1;
		public const int NK_TT_MAC_LANG_SPANISH = 6;
		public const int NK_TT_MAC_LANG_GERMAN = 2;
		public const int NK_TT_MAC_LANG_SWEDISH = 5;
		public const int NK_TT_MAC_LANG_HEBREW = 10;
		public const int NK_TT_MAC_LANG_CHINESE_SIMPLIFIED = 33;
		public const int NK_TT_MAC_LANG_ITALIAN = 3;
		public const int NK_TT_MAC_LANG_CHINESE_TRAD = 19;
		public const int NK_TOGGLE_CHECK = 0;
		public const int NK_TOGGLE_OPTION = 1;
		public const int NK_PROPERTY_DEFAULT = 0;
		public const int NK_PROPERTY_EDIT = 1;
		public const int NK_PROPERTY_DRAG = 2;
		public const int NK_FILTER_INT = 0;
		public const int NK_FILTER_FLOAT = 1;
		public const int NK_PROPERTY_INT = 0;
		public const int NK_PROPERTY_FLOAT = 1;
		public const int NK_PROPERTY_DOUBLE = 2;
		public const int NK_INSERT_BACK = 0;
		public const int NK_INSERT_FRONT = 1;
		public static byte[] nk_utfbyte = {0x80, 0, 0xC0, 0xE0, 0xF0};
		public static byte[] nk_utfmask = {0xC0, 0x80, 0xE0, 0xF0, 0xF8};
		public static uint[] nk_utfmin = {0, 0, 0x80, 0x800, 0x10000};
		public static uint[] nk_utfmax = {0x10FFFF, 0x7F, 0x7FF, 0xFFFF, 0x10FFFF};
		public static ulong nk_rect_align = (ulong) (4);
		public static ulong nk_range_align = (ulong) (8);
		public static ulong nk_char_align = (ulong) (4);
		public static ulong nk_build_align = (ulong) (8);
		public static ulong nk_baker_align = (ulong) (8);
		public static byte* nk__barrier;
		public static byte* nk__barrier2;
		public static byte* nk__barrier3;
		public static byte* nk__barrier4;
		public static byte* nk__dout;

		public static float nk_sqrt(float x)
		{
			return (float) (x*nk_inv_sqrt((float) (x)));
		}

		public static float nk_sin(float x)
		{
			float a0 = (float) (+1.91059300966915117e-31f);
			float a1 = (float) (+1.00086760103908896f);
			float a2 = (float) (-1.21276126894734565e-2f);
			float a3 = (float) (-1.38078780785773762e-1f);
			float a4 = (float) (-2.67353392911981221e-2f);
			float a5 = (float) (+2.08026600266304389e-2f);
			float a6 = (float) (-3.03996055049204407e-3f);
			float a7 = (float) (+1.38235642404333740e-4f);
			return (float) (a0 + x*(a1 + x*(a2 + x*(a3 + x*(a4 + x*(a5 + x*(a6 + x*a7)))))));
		}

		public static float nk_cos(float x)
		{
			float a0 = (float) (+1.00238601909309722f);
			float a1 = (float) (-3.81919947353040024e-2f);
			float a2 = (float) (-3.94382342128062756e-1f);
			float a3 = (float) (-1.18134036025221444e-1f);
			float a4 = (float) (+1.07123798512170878e-1f);
			float a5 = (float) (-1.86637164165180873e-2f);
			float a6 = (float) (+9.90140908664079833e-4f);
			float a7 = (float) (-5.23022132118824778e-14f);
			return (float) (a0 + x*(a1 + x*(a2 + x*(a3 + x*(a4 + x*(a5 + x*(a6 + x*a7)))))));
		}

		public static uint nk_round_up_pow2(uint v)
		{
			v--;
			v |= (uint) (v >> 1);
			v |= (uint) (v >> 2);
			v |= (uint) (v >> 4);
			v |= (uint) (v >> 8);
			v |= (uint) (v >> 16);
			v++;
			return (uint) (v);
		}

		public static nk_rect nk_get_null_rect()
		{
			return (nk_rect) (nk_null_rect);
		}

		public static nk_rect nk_rect_(float x, float y, float w, float h)
		{
			nk_rect r = new nk_rect();
			r.x = (float) (x);
			r.y = (float) (y);
			r.w = (float) (w);
			r.h = (float) (h);
			return (nk_rect) (r);
		}

		public static nk_rect nk_recti_(int x, int y, int w, int h)
		{
			nk_rect r = new nk_rect();
			r.x = ((float) (x));
			r.y = ((float) (y));
			r.w = ((float) (w));
			r.h = ((float) (h));
			return (nk_rect) (r);
		}

		public static nk_rect nk_recta(nk_vec2 pos, nk_vec2 size)
		{
			return (nk_rect) (nk_rect_((float) (pos.x), (float) (pos.y), (float) (size.x), (float) (size.y)));
		}

		public static nk_rect nk_rectv(float* r)
		{
			return (nk_rect) (nk_rect_((float) (r[0]), (float) (r[1]), (float) (r[2]), (float) (r[3])));
		}

		public static nk_rect nk_rectiv(int* r)
		{
			return (nk_rect) (nk_recti_((int) (r[0]), (int) (r[1]), (int) (r[2]), (int) (r[3])));
		}

		public static nk_vec2 nk_rect_pos(nk_rect r)
		{
			nk_vec2 ret = new nk_vec2();
			ret.x = (float) (r.x);
			ret.y = (float) (r.y);
			return (nk_vec2) (ret);
		}

		public static nk_vec2 nk_rect_size(nk_rect r)
		{
			nk_vec2 ret = new nk_vec2();
			ret.x = (float) (r.w);
			ret.y = (float) (r.h);
			return (nk_vec2) (ret);
		}

		public static nk_rect nk_shrink_rect_(nk_rect r, float amount)
		{
			nk_rect res = new nk_rect();
			r.w = (float) ((r.w) < (2*amount) ? (2*amount) : (r.w));
			r.h = (float) ((r.h) < (2*amount) ? (2*amount) : (r.h));
			res.x = (float) (r.x + amount);
			res.y = (float) (r.y + amount);
			res.w = (float) (r.w - 2*amount);
			res.h = (float) (r.h - 2*amount);
			return (nk_rect) (res);
		}

		public static nk_rect nk_pad_rect(nk_rect r, nk_vec2 pad)
		{
			r.w = (float) ((r.w) < (2*pad.x) ? (2*pad.x) : (r.w));
			r.h = (float) ((r.h) < (2*pad.y) ? (2*pad.y) : (r.h));
			r.x += (float) (pad.x);
			r.y += (float) (pad.y);
			r.w -= (float) (2*pad.x);
			r.h -= (float) (2*pad.y);
			return (nk_rect) (r);
		}

		public static nk_vec2 nk_vec2_(float x, float y)
		{
			nk_vec2 ret = new nk_vec2();
			ret.x = (float) (x);
			ret.y = (float) (y);
			return (nk_vec2) (ret);
		}

		public static nk_vec2 nk_vec2i_(int x, int y)
		{
			nk_vec2 ret = new nk_vec2();
			ret.x = ((float) (x));
			ret.y = ((float) (y));
			return (nk_vec2) (ret);
		}

		public static nk_vec2 nk_vec2v(float* v)
		{
			return (nk_vec2) (nk_vec2_((float) (v[0]), (float) (v[1])));
		}

		public static nk_vec2 nk_vec2iv(int* v)
		{
			return (nk_vec2) (nk_vec2i_((int) (v[0]), (int) (v[1])));
		}

		public static int nk_is_lower(int c)
		{
			return (int) ((((c) >= ('a')) && (c <= 'z')) || (((c) >= (0xE0)) && (c <= 0xFF)) ? 1 : 0);
		}

		public static int nk_is_upper(int c)
		{
			return (int) ((((c) >= ('A')) && (c <= 'Z')) || (((c) >= (0xC0)) && (c <= 0xDF)) ? 1 : 0);
		}

		public static int nk_to_upper(int c)
		{
			return (int) ((((c) >= ('a')) && (c <= 'z')) ? (c - ('a' - 'A')) : c);
		}

		public static int nk_to_lower(int c)
		{
			return (int) ((((c) >= ('A')) && (c <= 'Z')) ? (c - ('a' + 'A')) : c);
		}

		public static void* nk_memcopy(void* dst0, void* src0, ulong length)
		{
			ulong t;
			sbyte* dst = (sbyte*) (dst0);
			sbyte* src = (sbyte*) (src0);
			if (((length) == (0)) || ((dst) == (src))) goto done;
			if ((dst) < (src))
			{
				t = ((ulong) (src));
				if (((t | (ulong) (dst)) & (sizeof (int) - 1)) != 0)
				{
					if ((((t ^ (ulong) (dst)) & (sizeof (int) - 1)) != 0) || ((length) < (sizeof (int)))) t = (ulong) (length);
					else t = (ulong) (sizeof (int) - (t & (sizeof (int) - 1)));
					length -= (ulong) (t);
					do
					{
						*dst++ = (sbyte) (*src++);
					} while ((--t) != 0);
				}
				t = (ulong) (length/sizeof (int));
				if ((t) != 0)
					do
					{
						*(int*) ((void*) (dst)) = (int) (*(int*) ((void*) (src)));
						src += sizeof (int);
						dst += sizeof (int);
					} while ((--t) != 0);
				t = (ulong) (length & (sizeof (int) - 1));
				if ((t) != 0)
					do
					{
						*dst++ = (sbyte) (*src++);
					} while ((--t) != 0);
			}
			else
			{
				src += length;
				dst += length;
				t = ((ulong) (src));
				if (((t | (ulong) (dst)) & (sizeof (int) - 1)) != 0)
				{
					if ((((t ^ (ulong) (dst)) & (sizeof (int) - 1)) != 0) || (length <= sizeof (int))) t = (ulong) (length);
					else t &= (ulong) (sizeof (int) - 1);
					length -= (ulong) (t);
					do
					{
						*--dst = (sbyte) (*--src);
					} while ((--t) != 0);
				}
				t = (ulong) (length/sizeof (int));
				if ((t) != 0)
					do
					{
						src -= sizeof (int);
						dst -= sizeof (int);
						*(int*) ((void*) (dst)) = (int) (*(int*) ((void*) (src)));
					} while ((--t) != 0);
				t = (ulong) (length & (sizeof (int) - 1));
				if ((t) != 0)
					do
					{
						*--dst = (sbyte) (*--src);
					} while ((--t) != 0);
			}

			done:
			;
			return (dst0);
		}

		public static void nk_memset(void* ptr, int c0, ulong size)
		{
			byte* dst = (byte*) (ptr);
			uint c = (uint) (0);
			ulong t = (ulong) (0);
			if ((c = (uint) ((byte) (c0))) != 0)
			{
				c = (uint) ((c << 8) | c);
				if (sizeof (uint) > 2) c = (uint) ((c << 16) | c);
			}

			dst = (byte*) (ptr);
			if ((size) < (3*sizeof (uint)))
			{
				while ((size--) != 0)
				{
					*dst++ = ((byte) (c0));
				}
				return;
			}

			if ((t = (ulong) (((ulong) ((long) (dst))) & (sizeof (uint) - 1))) != 0)
			{
				t = (ulong) (sizeof (uint) - t);
				size -= (ulong) (t);
				do
				{
					*dst++ = ((byte) (c0));
				} while (--t != 0);
			}

			t = (ulong) (size/sizeof (uint));
			do
			{
				*(uint*) ((void*) (dst)) = (uint) (c);
				dst += sizeof (uint);
			} while (--t != 0);
			t = (ulong) (size & (sizeof (uint) - 1));
			if (t != 0)
			{
				do
				{
					*dst++ = ((byte) (c0));
				} while (--t != 0);
			}

		}

		public static void nk_zero(void* ptr, ulong size)
		{
			nk_memset(ptr, (int) (0), (ulong) (size));
		}

		public static int nk_strlen(char* str)
		{
			int siz = (int) (0);
			while (((str) != null) && (*str++ != '\0'))
			{
				siz++;
			}
			return (int) (siz);
		}

		public static int nk_strtoi(char* str, char** endptr)
		{
			int neg = (int) (1);
			char* p = str;
			int value = (int) (0);
			if (str == null) return (int) (0);
			while ((*p) == (' '))
			{
				p++;
			}
			if ((*p) == ('-'))
			{
				neg = (int) (-1);
				p++;
			}

			while ((((*p) != 0) && ((*p) >= ('0'))) && (*p <= '9'))
			{
				value = (int) (value*10 + (*p - '0'));
				p++;
			}
			if ((endptr) != null) *endptr = p;
			return (int) (neg*value);
		}

		public static double nk_strtod(char* str, char** endptr)
		{
			double m;
			double neg = (double) (1.0);
			char* p = str;
			double value = (double) (0);
			double number = (double) (0);
			if (str == null) return (double) (0);
			while ((*p) == (' '))
			{
				p++;
			}
			if ((*p) == ('-'))
			{
				neg = (double) (-1.0);
				p++;
			}

			while ((((*p) != 0) && (*p != '.')) && (*p != 'e'))
			{
				value = (double) (value*10.0 + (double) (*p - '0'));
				p++;
			}
			if ((*p) == ('.'))
			{
				p++;
				for (m = (double) (0.1); ((*p) != 0) && (*p != 'e'); p++)
				{
					value = (double) (value + (double) (*p - '0')*m);
					m *= (double) (0.1);
				}
			}

			if ((*p) == ('e'))
			{
				int i;
				int pow;
				int div;
				p++;
				if ((*p) == ('-'))
				{
					div = (int) (nk_true);
					p++;
				}
				else if ((*p) == ('+'))
				{
					div = (int) (nk_false);
					p++;
				}
				else div = (int) (nk_false);
				for (pow = (int) (0); *p != 0; p++)
				{
					pow = (int) (pow*10 + (*p - '0'));
				}
				for (m = (double) (1.0) , i = (int) (0); (i) < (pow); i++)
				{
					m *= (double) (10.0);
				}
				if ((div) != 0) value /= (double) (m);
				else value *= (double) (m);
			}

			number = (double) (value*neg);
			if ((endptr) != null) *endptr = p;
			return (double) (number);
		}

		public static float nk_strtof(char* str, char** endptr)
		{
			float float_value;
			double double_value;
			double_value = (double) (nk_strtod(str, endptr));
			float_value = ((float) (double_value));
			return (float) (float_value);
		}

		public static int nk_stricmpn(char* s1, char* s2, int n)
		{
			int c1;
			int c2;
			int d;
			do
			{
				c1 = (int) (*s1++);
				c2 = (int) (*s2++);
				if (n-- == 0) return (int) (0);
				d = (int) (c1 - c2);
				while ((d) != 0)
				{
					if ((c1 <= 'Z') && ((c1) >= ('A')))
					{
						d += (int) ('a' - 'A');
						if (d == 0) break;
					}
					if ((c2 <= 'Z') && ((c2) >= ('A')))
					{
						d -= (int) ('a' - 'A');
						if (d == 0) break;
					}
					return (int) ((((d) >= (0) ? 1 : 0) << 1) - 1);
				}
			} while ((c1) != 0);
			return (int) (0);
		}

		public static int nk_str_match_here(sbyte* regexp, char* text)
		{
			if ((regexp[0]) == ('\0')) return (int) (1);
			if ((regexp[1]) == ('*')) return (int) (nk_str_match_star((int) (regexp[0]), regexp + 2, text));
			if (((regexp[0]) == ('$')) && ((regexp[1]) == ('\0'))) return (int) ((*text) == ('\0') ? 1 : 0);
			if ((*text != '\0') && (((regexp[0]) == ('.')) || ((regexp[0]) == (*text))))
				return (int) (nk_str_match_here(regexp + 1, text + 1));
			return (int) (0);
		}

		public static int nk_str_match_star(int c, sbyte* regexp, char* text)
		{
			do
			{
				if ((nk_str_match_here(regexp, text)) != 0) return (int) (1);
			} while ((*text != '\0') && (((*text++) == (c)) || ((c) == ('.'))));
			return (int) (0);
		}

		public static int nk_string_float_limit(char* _string_, int prec)
		{
			int dot = (int) (0);
			char* c = _string_;
			while ((*c) != 0)
			{
				if ((*c) == ('.'))
				{
					dot = (int) (1);
					c++;
					continue;
				}
				if ((dot) == (prec + 1))
				{
					*c = (char) 0;
					break;
				}
				if ((dot) > (0)) dot++;
				c++;
			}
			return (int) (c - _string_);
		}

		public static double nk_pow(double x, int n)
		{
			double r = (double) (1);
			int plus = (int) ((n) >= (0) ? 1 : 0);
			n = (int) ((plus) != 0 ? n : -n);
			while ((n) > (0))
			{
				if ((n & 1) == (1)) r *= (double) (x);
				n /= (int) (2);
				x *= (double) (x);
			}
			return (double) ((plus) != 0 ? r : 1.0/r);
		}

		public static int nk_ifloord(double x)
		{
			x = ((double) ((int) (x) - (((x) < (0.0)) ? 1 : 0)));
			return (int) (x);
		}

		public static int nk_ifloorf(float x)
		{
			x = ((float) ((int) (x) - (((x) < (0.0f)) ? 1 : 0)));
			return (int) (x);
		}

		public static int nk_iceilf(float x)
		{
			if ((x) >= (0))
			{
				int i = (int) (x);
				return (int) (((x) > (i)) ? i + 1 : i);
			}
			else
			{
				int t = (int) (x);
				float r = (float) (x - (float) (t));
				return (int) (((r) > (0.0f)) ? t + 1 : t);
			}

		}

		public static int nk_log10(double n)
		{
			int neg;
			int ret;
			int exp = (int) (0);
			neg = (int) (((n) < (0)) ? 1 : 0);
			ret = (int) ((neg) != 0 ? (int) (-n) : (int) (n));
			while ((ret/10) > (0))
			{
				ret /= (int) (10);
				exp++;
			}
			if ((neg) != 0) exp = (int) (-exp);
			return (int) (exp);
		}

		public static void nk_strrev_ascii(char* s)
		{
			int len = (int) (nk_strlen(s));
			int end = (int) (len/2);
			int i = (int) (0);
			char t;
			for (; (i) < (end); ++i)
			{
				t = (s[i]);
				s[i] = (s[len - 1 - i]);
				s[len - 1 - i] = t;
			}
		}

		public static char* nk_itoa(char* s, int n)
		{
			int i = (int) (0);
			if ((n) == (0))
			{
				s[i++] = ('0');
				s[i] = (char) (0);
				return s;
			}

			if ((n) < (0))
			{
				s[i++] = ('-');
				n = (int) (-n);
			}

			while ((n) > (0))
			{
				s[i++] = (char) (('0' + (char) (n%10)));
				n /= (int) (10);
			}
			s[i] = (char) (0);
			if ((s[0]) == ('-')) ++s;
			nk_strrev_ascii(s);
			return s;
		}

		public static char* nk_dtoa(char* s, double n)
		{
			int useExp = (int) (0);
			int digit = (int) (0);
			int m = (int) (0);
			int m1 = (int) (0);
			char* c = s;
			int neg = (int) (0);
			if (s == null) return null;
			if ((n) == (0.0))
			{
				s[0] = ('0');
				s[1] = ('\0');
				return s;
			}

			neg = (int) ((n) < (0) ? 1 : 0);
			if ((neg) != 0) n = (double) (-n);
			m = (int) (nk_log10((double) (n)));
			useExp = (int) ((((m) >= (14)) || (((neg) != 0) && ((m) >= (9)))) || (m <= -9) ? 1 : 0);
			if ((neg) != 0) *(c++) = ('-');
			if ((useExp) != 0)
			{
				if ((m) < (0)) m -= (int) (1);
				n = (double) (n/nk_pow((double) (10.0), (int) (m)));
				m1 = (int) (m);
				m = (int) (0);
			}

			if ((m) < (1.0))
			{
				m = (int) (0);
			}

			while (((n) > (0.00000000000001)) || ((m) >= (0)))
			{
				double weight = (double) (nk_pow((double) (10.0), (int) (m)));
				if ((weight) > (0))
				{
					double t = (double) (n/weight);
					digit = (int) (nk_ifloord((double) (t)));
					n -= (double) ((double) (digit)*weight);
					*(c++) = (char) (('0' + (char) (digit)));
				}
				if (((m) == (0)) && ((n) > (0))) *(c++) = ('.');
				m--;
			}
			if ((useExp) != 0)
			{
				int i;
				int j;
				*(c++) = ('e');
				if ((m1) > (0))
				{
					*(c++) = ('+');
				}
				else
				{
					*(c++) = ('-');
					m1 = (int) (-m1);
				}
				m = (int) (0);
				while ((m1) > (0))
				{
					*(c++) = (char) (('0' + (char) (m1%10)));
					m1 /= (int) (10);
					m++;
				}
				c -= m;
				for (i = (int) (0) , j = (int) (m - 1); (i) < (j); i++ , j--)
				{
					c[i] ^= (c[j]);
					c[j] ^= (c[i]);
					c[i] ^= (c[j]);
				}
				c += m;
			}

			*(c) = ('\0');
			return s;
		}

		public static uint nk_murmur_hash(void* key, int len, uint seed)
		{
			nk_murmur_hash_union conv = new nk_murmur_hash_union(null);
			byte* data = (byte*) (key);
			int nblocks = (int) (len/4);
			uint h1 = (uint) (seed);
			uint c1 = (uint) (0xcc9e2d51);
			uint c2 = (uint) (0x1b873593);
			byte* tail;
			uint* blocks;
			uint k1;
			int i;
			if (key == null) return (uint) (0);
			conv.b = (data + nblocks*4);
			blocks = conv.i;
			for (i = (int) (-nblocks); i != 0; ++i)
			{
				k1 = (uint) (blocks[i]);
				k1 *= (uint) (c1);
				k1 = (uint) ((k1) << (15) | ((k1) >> (32 - 15)));
				k1 *= (uint) (c2);
				h1 ^= (uint) (k1);
				h1 = (uint) ((h1) << (13) | ((h1) >> (32 - 13)));
				h1 = (uint) (h1*5 + 0xe6546b64);
			}
			tail = (data + nblocks*4);
			k1 = (uint) (0);
			int l = (int) (len & 3);
			switch (l)
			{
				case 1:
				case 2:
				case 3:
					if ((l) == (2))
					{
						k1 ^= ((uint) (tail[1] << 8));
					}
					else if ((l) == (3))
					{
						k1 ^= ((uint) (tail[2] << 16));
					}
					k1 ^= (uint) (tail[0]);
					k1 *= (uint) (c1);
					k1 = (uint) ((k1) << (15) | ((k1) >> (32 - 15)));
					k1 *= (uint) (c2);
					h1 ^= (uint) (k1);
					break;
				default:
					break;
			}

			h1 ^= ((uint) (len));
			h1 ^= (uint) (h1 >> 16);
			h1 *= (uint) (0x85ebca6b);
			h1 ^= (uint) (h1 >> 13);
			h1 *= (uint) (0xc2b2ae35);
			h1 ^= (uint) (h1 >> 16);
			return (uint) (h1);
		}

		public static int nk_parse_hex(sbyte* p, int length)
		{
			int i = (int) (0);
			int len = (int) (0);
			while ((len) < (length))
			{
				i <<= 4;
				if (((p[len]) >= ('a')) && (p[len] <= 'f')) i += (int) ((p[len] - 'a') + 10);
				else if (((p[len]) >= ('A')) && (p[len] <= 'F')) i += (int) ((p[len] - 'A') + 10);
				else i += (int) (p[len] - '0');
				len++;
			}
			return (int) (i);
		}

		public static nk_color nk_rgba(int r, int g, int b, int a)
		{
			nk_color ret = new nk_color();
			ret.r = ((byte) (((r) < (255) ? (r) : (255)) < (0) ? (0) : ((r) < (255) ? (r) : (255))));
			ret.g = ((byte) (((g) < (255) ? (g) : (255)) < (0) ? (0) : ((g) < (255) ? (g) : (255))));
			ret.b = ((byte) (((b) < (255) ? (b) : (255)) < (0) ? (0) : ((b) < (255) ? (b) : (255))));
			ret.a = ((byte) (((a) < (255) ? (a) : (255)) < (0) ? (0) : ((a) < (255) ? (a) : (255))));
			return (nk_color) (ret);
		}

		public static nk_color nk_rgb_hex(sbyte* rgb)
		{
			nk_color col = new nk_color();
			sbyte* c = rgb;
			if ((*c) == ('#')) c++;
			col.r = ((byte) (nk_parse_hex(c, (int) (2))));
			col.g = ((byte) (nk_parse_hex(c + 2, (int) (2))));
			col.b = ((byte) (nk_parse_hex(c + 4, (int) (2))));
			col.a = (byte) (255);
			return (nk_color) (col);
		}

		public static nk_color nk_rgba_hex(sbyte* rgb)
		{
			nk_color col = new nk_color();
			sbyte* c = rgb;
			if ((*c) == ('#')) c++;
			col.r = ((byte) (nk_parse_hex(c, (int) (2))));
			col.g = ((byte) (nk_parse_hex(c + 2, (int) (2))));
			col.b = ((byte) (nk_parse_hex(c + 4, (int) (2))));
			col.a = ((byte) (nk_parse_hex(c + 6, (int) (2))));
			return (nk_color) (col);
		}

		public static void nk_color_hex_rgba(char* output, nk_color col)
		{
			output[0] = ((char) (((col.r & 0xF0) >> 4) <= 9 ? '0' + ((col.r & 0xF0) >> 4) : 'A' - 10 + ((col.r & 0xF0) >> 4)));
			output[1] = ((char) ((col.r & 0x0F) <= 9 ? '0' + (col.r & 0x0F) : 'A' - 10 + (col.r & 0x0F)));
			output[2] = ((char) (((col.g & 0xF0) >> 4) <= 9 ? '0' + ((col.g & 0xF0) >> 4) : 'A' - 10 + ((col.g & 0xF0) >> 4)));
			output[3] = ((char) ((col.g & 0x0F) <= 9 ? '0' + (col.g & 0x0F) : 'A' - 10 + (col.g & 0x0F)));
			output[4] = ((char) (((col.b & 0xF0) >> 4) <= 9 ? '0' + ((col.b & 0xF0) >> 4) : 'A' - 10 + ((col.b & 0xF0) >> 4)));
			output[5] = ((char) ((col.b & 0x0F) <= 9 ? '0' + (col.b & 0x0F) : 'A' - 10 + (col.b & 0x0F)));
			output[6] = ((char) (((col.a & 0xF0) >> 4) <= 9 ? '0' + ((col.a & 0xF0) >> 4) : 'A' - 10 + ((col.a & 0xF0) >> 4)));
			output[7] = ((char) ((col.a & 0x0F) <= 9 ? '0' + (col.a & 0x0F) : 'A' - 10 + (col.a & 0x0F)));
			output[8] = ('\0');
		}

		public static void nk_color_hex_rgb(char* output, nk_color col)
		{
			output[0] = ((char) (((col.r & 0xF0) >> 4) <= 9 ? '0' + ((col.r & 0xF0) >> 4) : 'A' - 10 + ((col.r & 0xF0) >> 4)));
			output[1] = ((char) ((col.r & 0x0F) <= 9 ? '0' + (col.r & 0x0F) : 'A' - 10 + (col.r & 0x0F)));
			output[2] = ((char) (((col.g & 0xF0) >> 4) <= 9 ? '0' + ((col.g & 0xF0) >> 4) : 'A' - 10 + ((col.g & 0xF0) >> 4)));
			output[3] = ((char) ((col.g & 0x0F) <= 9 ? '0' + (col.g & 0x0F) : 'A' - 10 + (col.g & 0x0F)));
			output[4] = ((char) (((col.b & 0xF0) >> 4) <= 9 ? '0' + ((col.b & 0xF0) >> 4) : 'A' - 10 + ((col.b & 0xF0) >> 4)));
			output[5] = ((char) ((col.b & 0x0F) <= 9 ? '0' + (col.b & 0x0F) : 'A' - 10 + (col.b & 0x0F)));
			output[6] = ('\0');
		}

		public static nk_color nk_rgba_iv(int* c)
		{
			return (nk_color) (nk_rgba((int) (c[0]), (int) (c[1]), (int) (c[2]), (int) (c[3])));
		}

		public static nk_color nk_rgba_bv(byte* c)
		{
			return (nk_color) (nk_rgba((int) (c[0]), (int) (c[1]), (int) (c[2]), (int) (c[3])));
		}

		public static nk_color nk_rgb(int r, int g, int b)
		{
			nk_color ret = new nk_color();
			ret.r = ((byte) (((r) < (255) ? (r) : (255)) < (0) ? (0) : ((r) < (255) ? (r) : (255))));
			ret.g = ((byte) (((g) < (255) ? (g) : (255)) < (0) ? (0) : ((g) < (255) ? (g) : (255))));
			ret.b = ((byte) (((b) < (255) ? (b) : (255)) < (0) ? (0) : ((b) < (255) ? (b) : (255))));
			ret.a = ((byte) (255));
			return (nk_color) (ret);
		}

		public static nk_color nk_rgb_iv(int* c)
		{
			return (nk_color) (nk_rgb((int) (c[0]), (int) (c[1]), (int) (c[2])));
		}

		public static nk_color nk_rgb_bv(byte* c)
		{
			return (nk_color) (nk_rgb((int) (c[0]), (int) (c[1]), (int) (c[2])));
		}

		public static nk_color nk_rgba_u32(uint _in_)
		{
			nk_color ret = new nk_color();
			ret.r = (byte) (_in_ & 0xFF);
			ret.g = (byte) ((_in_ >> 8) & 0xFF);
			ret.b = (byte) ((_in_ >> 16) & 0xFF);
			ret.a = ((byte) ((_in_ >> 24) & 0xFF));
			return (nk_color) (ret);
		}

		public static nk_color nk_rgba_f(float r, float g, float b, float a)
		{
			nk_color ret = new nk_color();
			ret.r = ((byte) (((0) < ((1.0f) < (r) ? (1.0f) : (r)) ? ((1.0f) < (r) ? (1.0f) : (r)) : (0))*255.0f));
			ret.g = ((byte) (((0) < ((1.0f) < (g) ? (1.0f) : (g)) ? ((1.0f) < (g) ? (1.0f) : (g)) : (0))*255.0f));
			ret.b = ((byte) (((0) < ((1.0f) < (b) ? (1.0f) : (b)) ? ((1.0f) < (b) ? (1.0f) : (b)) : (0))*255.0f));
			ret.a = ((byte) (((0) < ((1.0f) < (a) ? (1.0f) : (a)) ? ((1.0f) < (a) ? (1.0f) : (a)) : (0))*255.0f));
			return (nk_color) (ret);
		}

		public static nk_color nk_rgba_fv(float* c)
		{
			return (nk_color) (nk_rgba_f((float) (c[0]), (float) (c[1]), (float) (c[2]), (float) (c[3])));
		}

		public static nk_color nk_rgba_cf(nk_colorf c)
		{
			return (nk_color) (nk_rgba_f((float) (c.r), (float) (c.g), (float) (c.b), (float) (c.a)));
		}

		public static nk_color nk_rgb_f(float r, float g, float b)
		{
			nk_color ret = new nk_color();
			ret.r = ((byte) (((0) < ((1.0f) < (r) ? (1.0f) : (r)) ? ((1.0f) < (r) ? (1.0f) : (r)) : (0))*255.0f));
			ret.g = ((byte) (((0) < ((1.0f) < (g) ? (1.0f) : (g)) ? ((1.0f) < (g) ? (1.0f) : (g)) : (0))*255.0f));
			ret.b = ((byte) (((0) < ((1.0f) < (b) ? (1.0f) : (b)) ? ((1.0f) < (b) ? (1.0f) : (b)) : (0))*255.0f));
			ret.a = (byte) (255);
			return (nk_color) (ret);
		}

		public static nk_color nk_rgb_fv(float* c)
		{
			return (nk_color) (nk_rgb_f((float) (c[0]), (float) (c[1]), (float) (c[2])));
		}

		public static nk_color nk_rgb_cf(nk_colorf c)
		{
			return (nk_color) (nk_rgb_f((float) (c.r), (float) (c.g), (float) (c.b)));
		}

		public static nk_color nk_hsv(int h, int s, int v)
		{
			return (nk_color) (nk_hsva((int) (h), (int) (s), (int) (v), (int) (255)));
		}

		public static nk_color nk_hsv_iv(int* c)
		{
			return (nk_color) (nk_hsv((int) (c[0]), (int) (c[1]), (int) (c[2])));
		}

		public static nk_color nk_hsv_bv(byte* c)
		{
			return (nk_color) (nk_hsv((int) (c[0]), (int) (c[1]), (int) (c[2])));
		}

		public static nk_color nk_hsv_f(float h, float s, float v)
		{
			return (nk_color) (nk_hsva_f((float) (h), (float) (s), (float) (v), (float) (1.0f)));
		}

		public static nk_color nk_hsv_fv(float* c)
		{
			return (nk_color) (nk_hsv_f((float) (c[0]), (float) (c[1]), (float) (c[2])));
		}

		public static nk_color nk_hsva(int h, int s, int v, int a)
		{
			float hf = (float) (((float) (((h) < (255) ? (h) : (255)) < (0) ? (0) : ((h) < (255) ? (h) : (255))))/255.0f);
			float sf = (float) (((float) (((s) < (255) ? (s) : (255)) < (0) ? (0) : ((s) < (255) ? (s) : (255))))/255.0f);
			float vf = (float) (((float) (((v) < (255) ? (v) : (255)) < (0) ? (0) : ((v) < (255) ? (v) : (255))))/255.0f);
			float af = (float) (((float) (((a) < (255) ? (a) : (255)) < (0) ? (0) : ((a) < (255) ? (a) : (255))))/255.0f);
			return (nk_color) (nk_hsva_f((float) (hf), (float) (sf), (float) (vf), (float) (af)));
		}

		public static nk_color nk_hsva_iv(int* c)
		{
			return (nk_color) (nk_hsva((int) (c[0]), (int) (c[1]), (int) (c[2]), (int) (c[3])));
		}

		public static nk_color nk_hsva_bv(byte* c)
		{
			return (nk_color) (nk_hsva((int) (c[0]), (int) (c[1]), (int) (c[2]), (int) (c[3])));
		}

		public static nk_colorf nk_hsva_colorf(float h, float s, float v, float a)
		{
			int i;
			float p;
			float q;
			float t;
			float f;
			nk_colorf _out_ = new nk_colorf();
			if (s <= 0.0f)
			{
				_out_.r = (float) (v);
				_out_.g = (float) (v);
				_out_.b = (float) (v);
				_out_.a = (float) (a);
				return (nk_colorf) (_out_);
			}

			h = (float) (h/(60.0f/360.0f));
			i = ((int) (h));
			f = (float) (h - (float) (i));
			p = (float) (v*(1.0f - s));
			q = (float) (v*(1.0f - (s*f)));
			t = (float) (v*(1.0f - s*(1.0f - f)));
			switch (i)
			{
				case 0:
				default:
					_out_.r = (float) (v);
					_out_.g = (float) (t);
					_out_.b = (float) (p);
					break;
				case 1:
					_out_.r = (float) (q);
					_out_.g = (float) (v);
					_out_.b = (float) (p);
					break;
				case 2:
					_out_.r = (float) (p);
					_out_.g = (float) (v);
					_out_.b = (float) (t);
					break;
				case 3:
					_out_.r = (float) (p);
					_out_.g = (float) (q);
					_out_.b = (float) (v);
					break;
				case 4:
					_out_.r = (float) (t);
					_out_.g = (float) (p);
					_out_.b = (float) (v);
					break;
				case 5:
					_out_.r = (float) (v);
					_out_.g = (float) (p);
					_out_.b = (float) (q);
					break;
			}

			_out_.a = (float) (a);
			return (nk_colorf) (_out_);
		}

		public static nk_colorf nk_hsva_colorfv(float* c)
		{
			return (nk_colorf) (nk_hsva_colorf((float) (c[0]), (float) (c[1]), (float) (c[2]), (float) (c[3])));
		}

		public static nk_color nk_hsva_f(float h, float s, float v, float a)
		{
			nk_colorf c = (nk_colorf) (nk_hsva_colorf((float) (h), (float) (s), (float) (v), (float) (a)));
			return (nk_color) (nk_rgba_f((float) (c.r), (float) (c.g), (float) (c.b), (float) (c.a)));
		}

		public static nk_color nk_hsva_fv(float* c)
		{
			return (nk_color) (nk_hsva_f((float) (c[0]), (float) (c[1]), (float) (c[2]), (float) (c[3])));
		}

		public static uint nk_color_u32(nk_color _in_)
		{
			uint _out_ = (uint) (_in_.r);
			_out_ |= (uint) ((uint) (_in_.g) << 8);
			_out_ |= (uint) ((uint) (_in_.b) << 16);
			_out_ |= (uint) ((uint) (_in_.a) << 24);
			return (uint) (_out_);
		}

		public static void nk_color_f(float* r, float* g, float* b, float* a, nk_color _in_)
		{
			float s = (float) (1.0f/255.0f);
			*r = (float) ((float) (_in_.r)*s);
			*g = (float) ((float) (_in_.g)*s);
			*b = (float) ((float) (_in_.b)*s);
			*a = (float) ((float) (_in_.a)*s);
		}

		public static void nk_color_fv(float* c, nk_color _in_)
		{
			nk_color_f(&c[0], &c[1], &c[2], &c[3], (nk_color) (_in_));
		}

		public static nk_colorf nk_color_cf(nk_color _in_)
		{
			nk_colorf o = new nk_colorf();
			nk_color_f(&o.r, &o.g, &o.b, &o.a, (nk_color) (_in_));
			return (nk_colorf) (o);
		}

		public static void nk_color_d(double* r, double* g, double* b, double* a, nk_color _in_)
		{
			double s = (double) (1.0/255.0);
			*r = (double) ((double) (_in_.r)*s);
			*g = (double) ((double) (_in_.g)*s);
			*b = (double) ((double) (_in_.b)*s);
			*a = (double) ((double) (_in_.a)*s);
		}

		public static void nk_color_dv(double* c, nk_color _in_)
		{
			nk_color_d(&c[0], &c[1], &c[2], &c[3], (nk_color) (_in_));
		}

		public static void nk_color_hsv_f(float* out_h, float* out_s, float* out_v, nk_color _in_)
		{
			float a;
			nk_color_hsva_f(out_h, out_s, out_v, &a, (nk_color) (_in_));
		}

		public static void nk_color_hsv_fv(float* _out_, nk_color _in_)
		{
			float a;
			nk_color_hsva_f(&_out_[0], &_out_[1], &_out_[2], &a, (nk_color) (_in_));
		}

		public static void nk_colorf_hsva_f(float* out_h, float* out_s, float* out_v, float* out_a, nk_colorf _in_)
		{
			float chroma;
			float K = (float) (0.0f);
			if ((_in_.g) < (_in_.b))
			{
				float t = (float) (_in_.g);
				_in_.g = (float) (_in_.b);
				_in_.b = (float) (t);
				K = (float) (-1.0f);
			}

			if ((_in_.r) < (_in_.g))
			{
				float t = (float) (_in_.r);
				_in_.r = (float) (_in_.g);
				_in_.g = (float) (t);
				K = (float) (-2.0f/6.0f - K);
			}

			chroma = (float) (_in_.r - (((_in_.g) < (_in_.b)) ? _in_.g : _in_.b));
			*out_h =
				(float)
					(((K + (_in_.g - _in_.b)/(6.0f*chroma + 1e-20f)) < (0))
						? -(K + (_in_.g - _in_.b)/(6.0f*chroma + 1e-20f))
						: (K + (_in_.g - _in_.b)/(6.0f*chroma + 1e-20f)));
			*out_s = (float) (chroma/(_in_.r + 1e-20f));
			*out_v = (float) (_in_.r);
			*out_a = (float) (_in_.a);
		}

		public static void nk_colorf_hsva_fv(float* hsva, nk_colorf _in_)
		{
			nk_colorf_hsva_f(&hsva[0], &hsva[1], &hsva[2], &hsva[3], (nk_colorf) (_in_));
		}

		public static void nk_color_hsva_f(float* out_h, float* out_s, float* out_v, float* out_a, nk_color _in_)
		{
			nk_colorf col = new nk_colorf();
			nk_color_f(&col.r, &col.g, &col.b, &col.a, (nk_color) (_in_));
			nk_colorf_hsva_f(out_h, out_s, out_v, out_a, (nk_colorf) (col));
		}

		public static void nk_color_hsva_fv(float* _out_, nk_color _in_)
		{
			nk_color_hsva_f(&_out_[0], &_out_[1], &_out_[2], &_out_[3], (nk_color) (_in_));
		}

		public static void nk_color_hsva_i(int* out_h, int* out_s, int* out_v, int* out_a, nk_color _in_)
		{
			float h;
			float s;
			float v;
			float a;
			nk_color_hsva_f(&h, &s, &v, &a, (nk_color) (_in_));
			*out_h = (int) ((byte) (h*255.0f));
			*out_s = (int) ((byte) (s*255.0f));
			*out_v = (int) ((byte) (v*255.0f));
			*out_a = (int) ((byte) (a*255.0f));
		}

		public static void nk_color_hsva_iv(int* _out_, nk_color _in_)
		{
			nk_color_hsva_i(&_out_[0], &_out_[1], &_out_[2], &_out_[3], (nk_color) (_in_));
		}

		public static void nk_color_hsva_bv(byte* _out_, nk_color _in_)
		{
			int* tmp = stackalloc int[4];
			nk_color_hsva_i(&tmp[0], &tmp[1], &tmp[2], &tmp[3], (nk_color) (_in_));
			_out_[0] = ((byte) (tmp[0]));
			_out_[1] = ((byte) (tmp[1]));
			_out_[2] = ((byte) (tmp[2]));
			_out_[3] = ((byte) (tmp[3]));
		}

		public static void nk_color_hsva_b(byte* h, byte* s, byte* v, byte* a, nk_color _in_)
		{
			int* tmp = stackalloc int[4];
			nk_color_hsva_i(&tmp[0], &tmp[1], &tmp[2], &tmp[3], (nk_color) (_in_));
			*h = ((byte) (tmp[0]));
			*s = ((byte) (tmp[1]));
			*v = ((byte) (tmp[2]));
			*a = ((byte) (tmp[3]));
		}

		public static void nk_color_hsv_i(int* out_h, int* out_s, int* out_v, nk_color _in_)
		{
			int a;
			nk_color_hsva_i(out_h, out_s, out_v, &a, (nk_color) (_in_));
		}

		public static void nk_color_hsv_b(byte* out_h, byte* out_s, byte* out_v, nk_color _in_)
		{
			int* tmp = stackalloc int[4];
			nk_color_hsva_i(&tmp[0], &tmp[1], &tmp[2], &tmp[3], (nk_color) (_in_));
			*out_h = ((byte) (tmp[0]));
			*out_s = ((byte) (tmp[1]));
			*out_v = ((byte) (tmp[2]));
		}

		public static void nk_color_hsv_iv(int* _out_, nk_color _in_)
		{
			nk_color_hsv_i(&_out_[0], &_out_[1], &_out_[2], (nk_color) (_in_));
		}

		public static void nk_color_hsv_bv(byte* _out_, nk_color _in_)
		{
			int* tmp = stackalloc int[4];
			nk_color_hsv_i(&tmp[0], &tmp[1], &tmp[2], (nk_color) (_in_));
			_out_[0] = ((byte) (tmp[0]));
			_out_[1] = ((byte) (tmp[1]));
			_out_[2] = ((byte) (tmp[2]));
		}

		public static nk_handle nk_handle_ptr(void* ptr)
		{
			nk_handle handle = new nk_handle();
			handle.ptr = ptr;
			return (nk_handle) (handle);
		}

		public static nk_handle nk_handle_id(int id)
		{
			nk_handle handle = new nk_handle();
			nk_zero(&handle, (ulong) (sizeof (nk_handle)));
			handle.id = (int) (id);
			return (nk_handle) (handle);
		}

		public static nk_image nk_subimage_ptr(void* ptr, ushort w, ushort h, nk_rect r)
		{
			nk_image s = new nk_image();

			s.handle.ptr = ptr;
			s.w = (ushort) (w);
			s.h = (ushort) (h);
			s.region[0] = ((ushort) (r.x));
			s.region[1] = ((ushort) (r.y));
			s.region[2] = ((ushort) (r.w));
			s.region[3] = ((ushort) (r.h));
			return (nk_image) (s);
		}

		public static nk_image nk_subimage_id(int id, ushort w, ushort h, nk_rect r)
		{
			nk_image s = new nk_image();

			s.handle.id = (int) (id);
			s.w = (ushort) (w);
			s.h = (ushort) (h);
			s.region[0] = ((ushort) (r.x));
			s.region[1] = ((ushort) (r.y));
			s.region[2] = ((ushort) (r.w));
			s.region[3] = ((ushort) (r.h));
			return (nk_image) (s);
		}

		public static nk_image nk_subimage_handle(nk_handle handle, ushort w, ushort h, nk_rect r)
		{
			nk_image s = new nk_image();

			s.handle = (nk_handle) (handle);
			s.w = (ushort) (w);
			s.h = (ushort) (h);
			s.region[0] = ((ushort) (r.x));
			s.region[1] = ((ushort) (r.y));
			s.region[2] = ((ushort) (r.w));
			s.region[3] = ((ushort) (r.h));
			return (nk_image) (s);
		}

		public static nk_image nk_image_handle(nk_handle handle)
		{
			nk_image s = new nk_image();

			s.handle = (nk_handle) (handle);
			s.w = (ushort) (0);
			s.h = (ushort) (0);
			s.region[0] = (ushort) (0);
			s.region[1] = (ushort) (0);
			s.region[2] = (ushort) (0);
			s.region[3] = (ushort) (0);
			return (nk_image) (s);
		}

		public static nk_image nk_image_ptr(void* ptr)
		{
			nk_image s = new nk_image();

			s.handle.ptr = ptr;
			s.w = (ushort) (0);
			s.h = (ushort) (0);
			s.region[0] = (ushort) (0);
			s.region[1] = (ushort) (0);
			s.region[2] = (ushort) (0);
			s.region[3] = (ushort) (0);
			return (nk_image) (s);
		}

		public static nk_image nk_image_id(int id)
		{
			nk_image s = new nk_image();

			s.handle.id = (int) (id);
			s.w = (ushort) (0);
			s.h = (ushort) (0);
			s.region[0] = (ushort) (0);
			s.region[1] = (ushort) (0);
			s.region[2] = (ushort) (0);
			s.region[3] = (ushort) (0);
			return (nk_image) (s);
		}

		public static int nk_image_is_subimage(nk_image img)
		{
			return (int) ((((img.w) == (0)) && ((img.h) == (0))) ? 1 : 0);
		}

		public static void nk_unify(ref nk_rect clip, ref nk_rect a, float x0, float y0, float x1, float y1)
		{
			clip.x = (float) ((a.x) < (x0) ? (x0) : (a.x));
			clip.y = (float) ((a.y) < (y0) ? (y0) : (a.y));
			clip.w = (float) (((a.x + a.w) < (x1) ? (a.x + a.w) : (x1)) - clip.x);
			clip.h = (float) (((a.y + a.h) < (y1) ? (a.y + a.h) : (y1)) - clip.y);
			clip.w = (float) ((0) < (clip.w) ? (clip.w) : (0));
			clip.h = (float) ((0) < (clip.h) ? (clip.h) : (0));
		}

		public static void nk_triangle_from_direction(nk_vec2* result, nk_rect r, float pad_x, float pad_y, int direction)
		{
			float w_half;
			float h_half;
			r.w = (float) ((2*pad_x) < (r.w) ? (r.w) : (2*pad_x));
			r.h = (float) ((2*pad_y) < (r.h) ? (r.h) : (2*pad_y));
			r.w = (float) (r.w - 2*pad_x);
			r.h = (float) (r.h - 2*pad_y);
			r.x = (float) (r.x + pad_x);
			r.y = (float) (r.y + pad_y);
			w_half = (float) (r.w/2.0f);
			h_half = (float) (r.h/2.0f);
			if ((direction) == (NK_UP))
			{
				result[0] = (nk_vec2) (nk_vec2_((float) (r.x + w_half), (float) (r.y)));
				result[1] = (nk_vec2) (nk_vec2_((float) (r.x + r.w), (float) (r.y + r.h)));
				result[2] = (nk_vec2) (nk_vec2_((float) (r.x), (float) (r.y + r.h)));
			}
			else if ((direction) == (NK_RIGHT))
			{
				result[0] = (nk_vec2) (nk_vec2_((float) (r.x), (float) (r.y)));
				result[1] = (nk_vec2) (nk_vec2_((float) (r.x + r.w), (float) (r.y + h_half)));
				result[2] = (nk_vec2) (nk_vec2_((float) (r.x), (float) (r.y + r.h)));
			}
			else if ((direction) == (NK_DOWN))
			{
				result[0] = (nk_vec2) (nk_vec2_((float) (r.x), (float) (r.y)));
				result[1] = (nk_vec2) (nk_vec2_((float) (r.x + r.w), (float) (r.y)));
				result[2] = (nk_vec2) (nk_vec2_((float) (r.x + w_half), (float) (r.y + r.h)));
			}
			else
			{
				result[0] = (nk_vec2) (nk_vec2_((float) (r.x), (float) (r.y + h_half)));
				result[1] = (nk_vec2) (nk_vec2_((float) (r.x + r.w), (float) (r.y)));
				result[2] = (nk_vec2) (nk_vec2_((float) (r.x + r.w), (float) (r.y + r.h)));
			}

		}

		public static int nk_text_clamp(nk_user_font font, char* text, int text_len, float space, int* glyphs,
			float* text_width, uint* sep_list, int sep_count)
		{
			int i = (int) (0);
			int glyph_len = (int) (0);
			float last_width = (float) (0);
			char unicode = (char) 0;
			float width = (float) (0);
			int len = (int) (0);
			int g = (int) (0);
			float s;
			int sep_len = (int) (0);
			int sep_g = (int) (0);
			float sep_width = (float) (0);
			sep_count = (int) ((sep_count) < (0) ? (0) : (sep_count));
			glyph_len = (int) (nk_utf_decode(text, &unicode, (int) (text_len)));
			while ((((glyph_len) != 0) && ((width) < (space))) && ((len) < (text_len)))
			{
				len += (int) (glyph_len);
				s = (float) (font.width((nk_handle) (font.userdata), (float) (font.height), text, (int) (len)));
				for (i = (int) (0); (i) < (sep_count); ++i)
				{
					if (unicode != sep_list[i]) continue;
					sep_width = (float) (last_width = (float) (width));
					sep_g = (int) (g + 1);
					sep_len = (int) (len);
					break;
				}
				if ((i) == (sep_count))
				{
					last_width = (float) (sep_width = (float) (width));
					sep_g = (int) (g + 1);
				}
				width = (float) (s);
				glyph_len = (int) (nk_utf_decode(text + len, &unicode, (int) (text_len - len)));
				g++;
			}
			if ((len) >= (text_len))
			{
				*glyphs = (int) (g);
				*text_width = (float) (last_width);
				return (int) (len);
			}
			else
			{
				*glyphs = (int) (sep_g);
				*text_width = (float) (sep_width);
				return (int) ((sep_len == 0) ? len : sep_len);
			}

		}

		public static nk_vec2 nk_text_calculate_text_bounds(nk_user_font font, char* begin, int byte_len, float row_height,
			char** remaining, nk_vec2* out_offset, int* glyphs, int op)
		{
			float line_height = (float) (row_height);
			nk_vec2 text_size = (nk_vec2) (nk_vec2_((float) (0), (float) (0)));
			float line_width = (float) (0.0f);
			float glyph_width;
			int glyph_len = (int) (0);
			char unicode = (char) 0;
			int text_len = (int) (0);
			if (((begin == null) || (byte_len <= 0)) || (font == null))
				return (nk_vec2) (nk_vec2_((float) (0), (float) (row_height)));
			glyph_len = (int) (nk_utf_decode(begin, &unicode, (int) (byte_len)));
			if (glyph_len == 0) return (nk_vec2) (text_size);
			glyph_width = (float) (font.width((nk_handle) (font.userdata), (float) (font.height), begin, (int) (glyph_len)));
			*glyphs = (int) (0);
			while (((text_len) < (byte_len)) && ((glyph_len) != 0))
			{
				if ((unicode) == ('\n'))
				{
					text_size.x = (float) ((text_size.x) < (line_width) ? (line_width) : (text_size.x));
					text_size.y += (float) (line_height);
					line_width = (float) (0);
					*glyphs += (int) (1);
					if ((op) == (NK_STOP_ON_NEW_LINE)) break;
					text_len++;
					glyph_len = (int) (nk_utf_decode(begin + text_len, &unicode, (int) (byte_len - text_len)));
					continue;
				}
				if ((unicode) == ('\r'))
				{
					text_len++;
					*glyphs += (int) (1);
					glyph_len = (int) (nk_utf_decode(begin + text_len, &unicode, (int) (byte_len - text_len)));
					continue;
				}
				*glyphs = (int) (*glyphs + 1);
				text_len += (int) (glyph_len);
				line_width += (float) (glyph_width);
				glyph_len = (int) (nk_utf_decode(begin + text_len, &unicode, (int) (byte_len - text_len)));
				glyph_width =
					(float) (font.width((nk_handle) (font.userdata), (float) (font.height), begin + text_len, (int) (glyph_len)));
				continue;
			}
			if ((text_size.x) < (line_width)) text_size.x = (float) (line_width);
			if ((out_offset) != null)
				*out_offset = (nk_vec2) (nk_vec2_((float) (line_width), (float) (text_size.y + line_height)));
			if (((line_width) > (0)) || ((text_size.y) == (0.0f))) text_size.y += (float) (line_height);
			if ((remaining) != null) *remaining = begin + text_len;
			return (nk_vec2) (text_size);
		}

		public static void* nk_malloc(nk_handle unused, void* old, ulong size)
		{
			return CRuntime.malloc((ulong) (size));
		}

		public static void nk_mfree(nk_handle unused, void* ptr)
		{
			CRuntime.free(ptr);
		}

		public static void nk_buffer_init(nk_buffer b, ulong initial_size)
		{
			if (((b == null)) || (initial_size == 0)) return;

			b.type = (int) (NK_BUFFER_DYNAMIC);
			b.memory.ptr = CRuntime.malloc((ulong) (initial_size));
			b.memory.size = (ulong) (initial_size);
			b.size = (ulong) (initial_size);
			b.grow_factor = (float) (2.0f);

		}

		public static void nk_buffer_init_fixed(nk_buffer b, void* m, ulong size)
		{
			if (((b == null) || (m == null)) || (size == 0)) return;

			b.type = (int) (NK_BUFFER_FIXED);
			b.memory.ptr = m;
			b.memory.size = (ulong) (size);
			b.size = (ulong) (size);
		}

		public static void* nk_buffer_align(void* unaligned, ulong align, ulong* alignment, int type)
		{
			void* memory = null;
			switch (type)
			{
				default:
				case NK_BUFFER_MAX:
				case NK_BUFFER_FRONT:
					if ((align) != 0)
					{
						memory = ((void*) ((long) (((ulong) ((long) ((byte*) (unaligned) + (align - 1)))) & ~(align - 1))));
						*alignment = ((ulong) ((byte*) (memory) - (byte*) (unaligned)));
					}
					else
					{
						memory = unaligned;
						*alignment = (ulong) (0);
					}
					break;
				case NK_BUFFER_BACK:
					if ((align) != 0)
					{
						memory = ((void*) ((long) (((ulong) ((long) ((byte*) (unaligned)))) & ~(align - 1))));
						*alignment = ((ulong) ((byte*) (unaligned) - (byte*) (memory)));
					}
					else
					{
						memory = unaligned;
						*alignment = (ulong) (0);
					}
					break;
			}

			return memory;
		}

		public static void* nk_buffer_realloc(nk_buffer b, ulong capacity, ref ulong size)
		{
			void* temp;
			ulong buffer_size;
			if ((((b == null) || (size == null)))) return null;
			buffer_size = (ulong) (b.memory.size);
			temp = CRuntime.malloc((ulong) (capacity));
			if (temp == null) return null;
			size = (ulong) (capacity);
			if (temp != b.memory.ptr)
			{
				nk_memcopy(temp, b.memory.ptr, (ulong) (buffer_size));
				CRuntime.free(b.memory.ptr);
			}

			if ((b.size) == (buffer_size))
			{
				b.size = (ulong) (capacity);
				return temp;
			}
			else
			{
				void* dst;
				void* src;
				ulong back_size;
				back_size = (ulong) (buffer_size - b.size);
				dst = ((void*) ((byte*) (temp) + (capacity - back_size)));
				src = ((void*) ((byte*) (temp) + (b.size)));
				nk_memcopy(dst, src, (ulong) (back_size));
				b.size = (ulong) (capacity - back_size);
			}

			return temp;
		}

		public static void* nk_buffer_alloc(nk_buffer b, int type, ulong size, ulong align)
		{
			int full;
			ulong alignment;
			void* unaligned;
			void* memory;
			if ((b == null) || (size == 0)) return null;
			b.needed += (ulong) (size);
			if ((type) == (NK_BUFFER_FRONT)) unaligned = ((void*) ((byte*) (b.memory.ptr) + (b.allocated)));
			else unaligned = ((void*) ((byte*) (b.memory.ptr) + (b.size - size)));
			memory = nk_buffer_align(unaligned, (ulong) (align), &alignment, (int) (type));
			if ((type) == (NK_BUFFER_FRONT)) full = (int) ((b.allocated + size + alignment) > (b.size) ? 1 : 0);
			else
				full = (int) ((b.size - ((b.size) < (size + alignment) ? (b.size) : (size + alignment))) <= b.allocated ? 1 : 0);
			if ((full) != 0)
			{
				ulong capacity;
				if (b.type != NK_BUFFER_DYNAMIC) return null;
				if (((b.type != NK_BUFFER_DYNAMIC))) return null;
				capacity = ((ulong) ((float) (b.memory.size)*b.grow_factor));
				capacity =
					(ulong)
						((capacity) < (nk_round_up_pow2((uint) (b.allocated + size)))
							? (nk_round_up_pow2((uint) (b.allocated + size)))
							: (capacity));
				b.memory.ptr = nk_buffer_realloc(b, (ulong) (capacity), ref b.memory.size);
				if (b.memory.ptr == null) return null;
				if ((type) == (NK_BUFFER_FRONT)) unaligned = ((void*) ((byte*) (b.memory.ptr) + (b.allocated)));
				else unaligned = ((void*) ((byte*) (b.memory.ptr) + (b.size - size)));
				memory = nk_buffer_align(unaligned, (ulong) (align), &alignment, (int) (type));
			}

			if ((type) == (NK_BUFFER_FRONT)) b.allocated += (ulong) (size + alignment);
			else b.size -= (ulong) (size + alignment);
			b.needed += (ulong) (alignment);
			b.calls++;
			return memory;
		}

		public static void nk_buffer_push(nk_buffer b, int type, void* memory, ulong size, ulong align)
		{
			void* mem = nk_buffer_alloc(b, (int) (type), (ulong) (size), (ulong) (align));
			if (mem == null) return;
			nk_memcopy(mem, memory, (ulong) (size));
		}

		public static void nk_buffer_mark(nk_buffer buffer, int type)
		{
			if (buffer == null) return;
			buffer.marker[type].active = (int) (nk_true);
			if ((type) == (NK_BUFFER_BACK)) buffer.marker[type].offset = (ulong) (buffer.size);
			else buffer.marker[type].offset = (ulong) (buffer.allocated);
		}

		public static void nk_buffer_reset(nk_buffer buffer, int type)
		{
			if (buffer == null) return;
			if ((type) == (NK_BUFFER_BACK))
			{
				buffer.needed -= (ulong) (buffer.memory.size - buffer.marker[type].offset);
				if ((buffer.marker[type].active) != 0) buffer.size = (ulong) (buffer.marker[type].offset);
				else buffer.size = (ulong) (buffer.memory.size);
				buffer.marker[type].active = (int) (nk_false);
			}
			else
			{
				buffer.needed -= (ulong) (buffer.allocated - buffer.marker[type].offset);
				if ((buffer.marker[type].active) != 0) buffer.allocated = (ulong) (buffer.marker[type].offset);
				else buffer.allocated = (ulong) (0);
				buffer.marker[type].active = (int) (nk_false);
			}

		}

		public static void nk_buffer_clear(nk_buffer b)
		{
			if (b == null) return;
			b.allocated = (ulong) (0);
			b.size = (ulong) (b.memory.size);
			b.calls = (ulong) (0);
			b.needed = (ulong) (0);
		}

		public static void nk_buffer_free(nk_buffer b)
		{
			if ((b == null) || (b.memory.ptr == null)) return;
			if ((b.type) == (NK_BUFFER_FIXED)) return;

			CRuntime.free(b.memory.ptr);
		}

		public static void nk_buffer_info(nk_memory_status* s, nk_buffer b)
		{
			if ((s == null) || (b == null)) return;
			s->allocated = (ulong) (b.allocated);
			s->size = (ulong) (b.memory.size);
			s->needed = (ulong) (b.needed);
			s->memory = b.memory.ptr;
			s->calls = (ulong) (b.calls);
		}

		public static void* nk_buffer_memory(nk_buffer buffer)
		{
			if (buffer == null) return null;
			return buffer.memory.ptr;
		}

		public static void* nk_buffer_memory_const(nk_buffer buffer)
		{
			if (buffer == null) return null;
			return buffer.memory.ptr;
		}

		public static ulong nk_buffer_total(nk_buffer buffer)
		{
			if (buffer == null) return (ulong) (0);
			return (ulong) (buffer.memory.size);
		}

		public static void nk_str_init_fixed(nk_str str, void* memory, ulong size)
		{
			nk_buffer_init_fixed(str.buffer, memory, (ulong) (size));
			str.len = (int) (0);
		}

		public static int nk_str_append_text_char(nk_str s, char* str, int len)
		{
			sbyte* mem;
			if (((s == null) || (str == null)) || (len == 0)) return (int) (0);
			mem =
				(sbyte*) (nk_buffer_alloc(s.buffer, (int) (NK_BUFFER_FRONT), (ulong) ((ulong) (len)*sizeof (char)), (ulong) (0)));
			if (mem == null) return (int) (0);
			nk_memcopy(mem, str, (ulong) ((ulong) (len)*sizeof (char)));
			s.len += (int) (nk_utf_len(str, (int) (len)));
			return (int) (len);
		}

		public static int nk_str_append_str_char(nk_str s, char* str)
		{
			return (int) (nk_str_append_text_char(s, str, (int) (nk_strlen(str))));
		}

		public static int nk_str_append_text_utf8(nk_str str, char* text, int len)
		{
			int i = (int) (0);
			int byte_len = (int) (0);
			char unicode;
			if (((str == null) || (text == null)) || (len == 0)) return (int) (0);
			for (i = (int) (0); (i) < (len); ++i)
			{
				byte_len += (int) (nk_utf_decode(text + byte_len, &unicode, (int) (4)));
			}
			nk_str_append_text_char(str, text, (int) (byte_len));
			return (int) (len);
		}

		public static int nk_str_append_str_utf8(nk_str str, char* text)
		{
			int runes = (int) (0);
			int byte_len = (int) (0);
			int num_runes = (int) (0);
			int glyph_len = (int) (0);
			char unicode;
			if ((str == null) || (text == null)) return (int) (0);
			glyph_len = (int) (byte_len = (int) (nk_utf_decode(text + byte_len, &unicode, (int) (4))));
			while ((unicode != '\0') && ((glyph_len) != 0))
			{
				glyph_len = (int) (nk_utf_decode(text + byte_len, &unicode, (int) (4)));
				byte_len += (int) (glyph_len);
				num_runes++;
			}
			nk_str_append_text_char(str, text, (int) (byte_len));
			return (int) (runes);
		}

		public static int nk_str_insert_at_char(nk_str s, int pos, char* str, int len)
		{
			int i;
			void* mem;
			sbyte* src;
			sbyte* dst;
			int copylen;
			if ((((s == null) || (str == null)) || (len == 0)) || (((ulong) (pos)) > (s.buffer.allocated))) return (int) (0);
			if (((s.buffer.allocated + (ulong) (len)) >= (s.buffer.memory.size)) && ((s.buffer.type) == (NK_BUFFER_FIXED)))
				return (int) (0);
			copylen = (int) ((int) (s.buffer.allocated) - pos);
			if (copylen == 0)
			{
				nk_str_append_text_char(s, str, (int) (len));
				return (int) (1);
			}

			mem = nk_buffer_alloc(s.buffer, (int) (NK_BUFFER_FRONT), (ulong) ((ulong) (len)*sizeof (char)), (ulong) (0));
			if (mem == null) return (int) (0);
			dst = ((sbyte*) ((void*) ((byte*) (s.buffer.memory.ptr) + (pos + len + (copylen - 1)))));
			src = ((sbyte*) ((void*) ((byte*) (s.buffer.memory.ptr) + (pos + (copylen - 1)))));
			for (i = (int) (0); (i) < (copylen); ++i)
			{
				*dst-- = (sbyte) (*src--);
			}
			mem = ((void*) ((byte*) (s.buffer.memory.ptr) + (pos)));
			nk_memcopy(mem, str, (ulong) ((ulong) (len)*sizeof (char)));
			s.len = (int) (nk_utf_len((char*) (s.buffer.memory.ptr), (int) (s.buffer.allocated)));
			return (int) (1);
		}

		public static int nk_str_insert_at_rune(nk_str str, int pos, char* cstr, int len)
		{
			int glyph_len;
			char unicode;
			char* begin;
			char* buffer;
			if (((str == null) || (cstr == null)) || (len == 0)) return (int) (0);
			begin = nk_str_at_rune(str, (int) (pos), &unicode, &glyph_len);
			if (str.len == 0) return (int) (nk_str_append_text_char(str, cstr, (int) (len)));
			buffer = nk_str_get_const(str);
			if (begin == null) return (int) (0);
			return (int) (nk_str_insert_at_char(str, (int) (begin - buffer), cstr, (int) (len)));
		}

		public static int nk_str_insert_text_char(nk_str str, int pos, char* text, int len)
		{
			return (int) (nk_str_insert_text_utf8(str, (int) (pos), text, (int) (len)));
		}

		public static int nk_str_insert_str_char(nk_str str, int pos, char* text)
		{
			return (int) (nk_str_insert_text_utf8(str, (int) (pos), text, (int) (nk_strlen(text))));
		}

		public static int nk_str_insert_text_utf8(nk_str str, int pos, char* text, int len)
		{
			int i = (int) (0);
			int byte_len = (int) (0);
			char unicode;
			if (((str == null) || (text == null)) || (len == 0)) return (int) (0);
			for (i = (int) (0); (i) < (len); ++i)
			{
				byte_len += (int) (nk_utf_decode(text + byte_len, &unicode, (int) (4)));
			}
			nk_str_insert_at_rune(str, (int) (pos), text, (int) (byte_len));
			return (int) (len);
		}

		public static int nk_str_insert_str_utf8(nk_str str, int pos, char* text)
		{
			int runes = (int) (0);
			int byte_len = (int) (0);
			int num_runes = (int) (0);
			int glyph_len = (int) (0);
			char unicode;
			if ((str == null) || (text == null)) return (int) (0);
			glyph_len = (int) (byte_len = (int) (nk_utf_decode(text + byte_len, &unicode, (int) (4))));
			while ((unicode != '\0') && ((glyph_len) != 0))
			{
				glyph_len = (int) (nk_utf_decode(text + byte_len, &unicode, (int) (4)));
				byte_len += (int) (glyph_len);
				num_runes++;
			}
			nk_str_insert_at_rune(str, (int) (pos), text, (int) (byte_len));
			return (int) (runes);
		}

		public static int nk_str_insert_text_runes(nk_str str, int pos, char* runes, int len)
		{
			int i = (int) (0);
			int byte_len = (int) (0);
			char* glyph = stackalloc char[4];
			if (((str == null) || (runes == null)) || (len == 0)) return (int) (0);
			for (i = (int) (0); (i) < (len); ++i)
			{
				byte_len = (int) (nk_utf_encode(runes[i], glyph, (int) (4)));
				if (byte_len == 0) break;
				nk_str_insert_at_rune(str, (int) (pos + i), glyph, (int) (byte_len));
			}
			return (int) (len);
		}

		public static int nk_str_insert_str_runes(nk_str str, int pos, char* runes)
		{
			int i = (int) (0);
			char* glyph = stackalloc char[4];
			int byte_len;
			if ((str == null) || (runes == null)) return (int) (0);
			while (runes[i] != '\0')
			{
				byte_len = (int) (nk_utf_encode(runes[i], glyph, (int) (4)));
				nk_str_insert_at_rune(str, (int) (pos + i), glyph, (int) (byte_len));
				i++;
			}
			return (int) (i);
		}

		public static void nk_str_remove_chars(nk_str s, int len)
		{
			if (((s == null) || ((len) < (0))) || (((ulong) (len)) > (s.buffer.allocated))) return;
			s.buffer.allocated -= ((ulong) (len));
			s.len = (int) (nk_utf_len((char*) (s.buffer.memory.ptr), (int) (s.buffer.allocated)));
		}

		public static void nk_str_remove_runes(nk_str str, int len)
		{
			int index;
			char* begin;
			char* end;
			char unicode;
			if ((str == null) || ((len) < (0))) return;
			if ((len) >= (str.len))
			{
				str.len = (int) (0);
				return;
			}

			index = (int) (str.len - len);
			begin = nk_str_at_rune(str, (int) (index), &unicode, &len);
			end = (char*) (str.buffer.memory.ptr) + str.buffer.allocated;
			nk_str_remove_chars(str, (int) ((int) (end - begin) + 1));
		}

		public static void nk_str_delete_chars(nk_str s, int pos, int len)
		{
			if ((((s == null) || (len == 0)) || (((ulong) (pos)) > (s.buffer.allocated))) ||
			    (((ulong) (pos + len)) > (s.buffer.allocated))) return;
			if (((ulong) (pos + len)) < (s.buffer.allocated))
			{
				sbyte* dst = ((sbyte*) ((void*) ((byte*) (s.buffer.memory.ptr) + (pos))));
				sbyte* src = ((sbyte*) ((void*) ((byte*) (s.buffer.memory.ptr) + (pos + len))));
				nk_memcopy(dst, src, (ulong) (s.buffer.allocated - (ulong) (pos + len)));
				s.buffer.allocated -= ((ulong) (len));
			}
			else nk_str_remove_chars(s, (int) (len));
			s.len = (int) (nk_utf_len((char*) (s.buffer.memory.ptr), (int) (s.buffer.allocated)));
		}

		public static void nk_str_delete_runes(nk_str s, int pos, int len)
		{
			char* temp;
			char unicode;
			char* begin;
			char* end;
			int unused;
			if ((s.len) < (pos + len))
				len =
					(int)
						(((s.len - pos) < (s.len) ? (s.len - pos) : (s.len)) < (0)
							? (0)
							: ((s.len - pos) < (s.len) ? (s.len - pos) : (s.len)));
			if (len == 0) return;
			temp = (char*) (s.buffer.memory.ptr);
			begin = nk_str_at_rune(s, (int) (pos), &unicode, &unused);
			if (begin == null) return;
			s.buffer.memory.ptr = begin;
			end = nk_str_at_rune(s, (int) (len), &unicode, &unused);
			s.buffer.memory.ptr = temp;
			if (end == null) return;
			nk_str_delete_chars(s, (int) (begin - temp), (int) (end - begin));
		}

		public static char* nk_str_at_char(nk_str s, int pos)
		{
			if ((s == null) || ((pos) > ((int) (s.buffer.allocated)))) return null;
			return ((char*) ((void*) ((byte*) (s.buffer.memory.ptr) + (pos))));
		}

		public static char* nk_str_at_rune(nk_str str, int pos, char* unicode, int* len)
		{
			int i = (int) (0);
			int src_len = (int) (0);
			int glyph_len = (int) (0);
			char* text;
			int text_len;
			if (((str == null) || (unicode == null)) || (len == null)) return null;
			if ((pos) < (0))
			{
				*unicode = (char) (0);
				*len = (int) (0);
				return null;
			}

			text = (char*) (str.buffer.memory.ptr);
			text_len = ((int) (str.buffer.allocated));
			glyph_len = (int) (nk_utf_decode(text, unicode, (int) (text_len)));
			while ((glyph_len) != 0)
			{
				if ((i) == (pos))
				{
					*len = (int) (glyph_len);
					break;
				}
				i++;
				src_len = (int) (src_len + glyph_len);
				glyph_len = (int) (nk_utf_decode(text + src_len, unicode, (int) (text_len - src_len)));
			}
			if (i != pos) return null;
			return text + src_len;
		}

		public static char* nk_str_at_char_const(nk_str s, int pos)
		{
			if ((s == null) || ((pos) > ((int) (s.buffer.allocated)))) return null;
			return ((char*) ((void*) ((byte*) (s.buffer.memory.ptr) + (pos))));
		}

		public static char* nk_str_at_const(nk_str str, int pos, char* unicode, int* len)
		{
			int i = (int) (0);
			int src_len = (int) (0);
			int glyph_len = (int) (0);
			char* text;
			int text_len;
			if (((str == null) || (unicode == null)) || (len == null)) return null;
			if ((pos) < (0))
			{
				*unicode = (char) (0);
				*len = (int) (0);
				return null;
			}

			text = (char*) (str.buffer.memory.ptr);
			text_len = ((int) (str.buffer.allocated));
			glyph_len = (int) (nk_utf_decode(text, unicode, (int) (text_len)));
			while ((glyph_len) != 0)
			{
				if ((i) == (pos))
				{
					*len = (int) (glyph_len);
					break;
				}
				i++;
				src_len = (int) (src_len + glyph_len);
				glyph_len = (int) (nk_utf_decode(text + src_len, unicode, (int) (text_len - src_len)));
			}
			if (i != pos) return null;
			return text + src_len;
		}

		public static char nk_str_rune_at(nk_str str, int pos)
		{
			int len;
			char unicode = (char) 0;
			nk_str_at_const(str, (int) (pos), &unicode, &len);
			return unicode;
		}

		public static char* nk_str_get(nk_str s)
		{
			if (((s == null) || (s.len == 0)) || (s.buffer.allocated == 0)) return null;
			return (char*) (s.buffer.memory.ptr);
		}

		public static char* nk_str_get_const(nk_str s)
		{
			if (((s == null) || (s.len == 0)) || (s.buffer.allocated == 0)) return null;
			return (char*) (s.buffer.memory.ptr);
		}

		public static int nk_str_len(nk_str s)
		{
			if (((s == null) || (s.len == 0)) || (s.buffer.allocated == 0)) return (int) (0);
			return (int) (s.len);
		}

		public static int nk_str_len_char(nk_str s)
		{
			if (((s == null) || (s.len == 0)) || (s.buffer.allocated == 0)) return (int) (0);
			return (int) (s.buffer.allocated);
		}

		public static void nk_str_clear(nk_str str)
		{
			nk_buffer_clear(str.buffer);
			str.len = (int) (0);
		}

		public static void nk_str_free(nk_str str)
		{
			nk_buffer_free(str.buffer);
			str.len = (int) (0);
		}

		public static void nk_push_scissor(nk_command_buffer b, nk_rect r)
		{
			nk_command_scissor cmd;
			if (b == null) return;
			b.clip.x = (float) (r.x);
			b.clip.y = (float) (r.y);
			b.clip.w = (float) (r.w);
			b.clip.h = (float) (r.h);
			cmd = (nk_command_scissor) (nk_command_buffer_push(b, (int) (NK_COMMAND_SCISSOR)));
			if (cmd == null) return;
			cmd.x = ((short) (r.x));
			cmd.y = ((short) (r.y));
			cmd.w = ((ushort) ((0) < (r.w) ? (r.w) : (0)));
			cmd.h = ((ushort) ((0) < (r.h) ? (r.h) : (0)));
		}

		public static void nk_stroke_line(nk_command_buffer b, float x0, float y0, float x1, float y1, float line_thickness,
			nk_color c)
		{
			nk_command_line cmd;
			if ((b == null) || (line_thickness <= 0)) return;
			cmd = (nk_command_line) (nk_command_buffer_push(b, (int) (NK_COMMAND_LINE)));
			if (cmd == null) return;
			cmd.line_thickness = ((ushort) (line_thickness));
			cmd.begin.x = ((short) (x0));
			cmd.begin.y = ((short) (y0));
			cmd.end.x = ((short) (x1));
			cmd.end.y = ((short) (y1));
			cmd.color = (nk_color) (c);
		}

		public static void nk_stroke_curve(nk_command_buffer b, float ax, float ay, float ctrl0x, float ctrl0y, float ctrl1x,
			float ctrl1y, float bx, float by, float line_thickness, nk_color col)
		{
			nk_command_curve cmd;
			if (((b == null) || ((col.a) == (0))) || (line_thickness <= 0)) return;
			cmd = (nk_command_curve) (nk_command_buffer_push(b, (int) (NK_COMMAND_CURVE)));
			if (cmd == null) return;
			cmd.line_thickness = ((ushort) (line_thickness));
			cmd.begin.x = ((short) (ax));
			cmd.begin.y = ((short) (ay));
			cmd.ctrl_0.x = ((short) (ctrl0x));
			cmd.ctrl_0.y = ((short) (ctrl0y));
			cmd.ctrl_1.x = ((short) (ctrl1x));
			cmd.ctrl_1.y = ((short) (ctrl1y));
			cmd.end.x = ((short) (bx));
			cmd.end.y = ((short) (by));
			cmd.color = (nk_color) (col);
		}

		public static void nk_stroke_rect(nk_command_buffer b, nk_rect rect, float rounding, float line_thickness, nk_color c)
		{
			nk_command_rect cmd;
			if (((((b == null) || ((c.a) == (0))) || ((rect.w) == (0))) || ((rect.h) == (0))) || (line_thickness <= 0)) return;
			if ((b.use_clipping) != 0)
			{
				if (
					!(!(((((b.clip.x) > (rect.x + rect.w)) || ((b.clip.x + b.clip.w) < (rect.x))) || ((b.clip.y) > (rect.y + rect.h))) ||
					    ((b.clip.y + b.clip.h) < (rect.y))))) return;
			}

			cmd = (nk_command_rect) (nk_command_buffer_push(b, (int) (NK_COMMAND_RECT)));
			if (cmd == null) return;
			cmd.rounding = ((ushort) (rounding));
			cmd.line_thickness = ((ushort) (line_thickness));
			cmd.x = ((short) (rect.x));
			cmd.y = ((short) (rect.y));
			cmd.w = ((ushort) ((0) < (rect.w) ? (rect.w) : (0)));
			cmd.h = ((ushort) ((0) < (rect.h) ? (rect.h) : (0)));
			cmd.color = (nk_color) (c);
		}

		public static void nk_fill_rect(nk_command_buffer b, nk_rect rect, float rounding, nk_color c)
		{
			nk_command_rect_filled cmd;
			if ((((b == null) || ((c.a) == (0))) || ((rect.w) == (0))) || ((rect.h) == (0))) return;
			if ((b.use_clipping) != 0)
			{
				if (
					!(!(((((b.clip.x) > (rect.x + rect.w)) || ((b.clip.x + b.clip.w) < (rect.x))) || ((b.clip.y) > (rect.y + rect.h))) ||
					    ((b.clip.y + b.clip.h) < (rect.y))))) return;
			}

			cmd = (nk_command_rect_filled) (nk_command_buffer_push(b, (int) (NK_COMMAND_RECT_FILLED)));
			if (cmd == null) return;
			cmd.rounding = ((ushort) (rounding));
			cmd.x = ((short) (rect.x));
			cmd.y = ((short) (rect.y));
			cmd.w = ((ushort) ((0) < (rect.w) ? (rect.w) : (0)));
			cmd.h = ((ushort) ((0) < (rect.h) ? (rect.h) : (0)));
			cmd.color = (nk_color) (c);
		}

		public static void nk_fill_rect_multi_color(nk_command_buffer b, nk_rect rect, nk_color left, nk_color top,
			nk_color right, nk_color bottom)
		{
			nk_command_rect_multi_color cmd;
			if (((b == null) || ((rect.w) == (0))) || ((rect.h) == (0))) return;
			if ((b.use_clipping) != 0)
			{
				if (
					!(!(((((b.clip.x) > (rect.x + rect.w)) || ((b.clip.x + b.clip.w) < (rect.x))) || ((b.clip.y) > (rect.y + rect.h))) ||
					    ((b.clip.y + b.clip.h) < (rect.y))))) return;
			}

			cmd = (nk_command_rect_multi_color) (nk_command_buffer_push(b, (int) (NK_COMMAND_RECT_MULTI_COLOR)));
			if (cmd == null) return;
			cmd.x = ((short) (rect.x));
			cmd.y = ((short) (rect.y));
			cmd.w = ((ushort) ((0) < (rect.w) ? (rect.w) : (0)));
			cmd.h = ((ushort) ((0) < (rect.h) ? (rect.h) : (0)));
			cmd.left = (nk_color) (left);
			cmd.top = (nk_color) (top);
			cmd.right = (nk_color) (right);
			cmd.bottom = (nk_color) (bottom);
		}

		public static void nk_stroke_circle(nk_command_buffer b, nk_rect r, float line_thickness, nk_color c)
		{
			nk_command_circle cmd;
			if ((((b == null) || ((r.w) == (0))) || ((r.h) == (0))) || (line_thickness <= 0)) return;
			if ((b.use_clipping) != 0)
			{
				if (
					!(!(((((b.clip.x) > (r.x + r.w)) || ((b.clip.x + b.clip.w) < (r.x))) || ((b.clip.y) > (r.y + r.h))) ||
					    ((b.clip.y + b.clip.h) < (r.y))))) return;
			}

			cmd = (nk_command_circle) (nk_command_buffer_push(b, (int) (NK_COMMAND_CIRCLE)));
			if (cmd == null) return;
			cmd.line_thickness = ((ushort) (line_thickness));
			cmd.x = ((short) (r.x));
			cmd.y = ((short) (r.y));
			cmd.w = ((ushort) ((r.w) < (0) ? (0) : (r.w)));
			cmd.h = ((ushort) ((r.h) < (0) ? (0) : (r.h)));
			cmd.color = (nk_color) (c);
		}

		public static void nk_fill_circle(nk_command_buffer b, nk_rect r, nk_color c)
		{
			nk_command_circle_filled cmd;
			if ((((b == null) || ((c.a) == (0))) || ((r.w) == (0))) || ((r.h) == (0))) return;
			if ((b.use_clipping) != 0)
			{
				if (
					!(!(((((b.clip.x) > (r.x + r.w)) || ((b.clip.x + b.clip.w) < (r.x))) || ((b.clip.y) > (r.y + r.h))) ||
					    ((b.clip.y + b.clip.h) < (r.y))))) return;
			}

			cmd = (nk_command_circle_filled) (nk_command_buffer_push(b, (int) (NK_COMMAND_CIRCLE_FILLED)));
			if (cmd == null) return;
			cmd.x = ((short) (r.x));
			cmd.y = ((short) (r.y));
			cmd.w = ((ushort) ((r.w) < (0) ? (0) : (r.w)));
			cmd.h = ((ushort) ((r.h) < (0) ? (0) : (r.h)));
			cmd.color = (nk_color) (c);
		}

		public static void nk_stroke_arc(nk_command_buffer b, float cx, float cy, float radius, float a_min, float a_max,
			float line_thickness, nk_color c)
		{
			nk_command_arc cmd;
			if (((b == null) || ((c.a) == (0))) || (line_thickness <= 0)) return;
			cmd = (nk_command_arc) (nk_command_buffer_push(b, (int) (NK_COMMAND_ARC)));
			if (cmd == null) return;
			cmd.line_thickness = ((ushort) (line_thickness));
			cmd.cx = ((short) (cx));
			cmd.cy = ((short) (cy));
			cmd.r = ((ushort) (radius));
			cmd.a[0] = (float) (a_min);
			cmd.a[1] = (float) (a_max);
			cmd.color = (nk_color) (c);
		}

		public static void nk_fill_arc(nk_command_buffer b, float cx, float cy, float radius, float a_min, float a_max,
			nk_color c)
		{
			nk_command_arc_filled cmd;
			if ((b == null) || ((c.a) == (0))) return;
			cmd = (nk_command_arc_filled) (nk_command_buffer_push(b, (int) (NK_COMMAND_ARC_FILLED)));
			if (cmd == null) return;
			cmd.cx = ((short) (cx));
			cmd.cy = ((short) (cy));
			cmd.r = ((ushort) (radius));
			cmd.a[0] = (float) (a_min);
			cmd.a[1] = (float) (a_max);
			cmd.color = (nk_color) (c);
		}

		public static void nk_stroke_triangle(nk_command_buffer b, float x0, float y0, float x1, float y1, float x2, float y2,
			float line_thickness, nk_color c)
		{
			nk_command_triangle cmd;
			if (((b == null) || ((c.a) == (0))) || (line_thickness <= 0)) return;
			if ((b.use_clipping) != 0)
			{
				if (
					((!((((b.clip.x) <= (x0)) && ((x0) < (b.clip.x + b.clip.w))) &&
					    (((b.clip.y) <= (y0)) && ((y0) < (b.clip.y + b.clip.h))))) &&
					 (!((((b.clip.x) <= (x1)) && ((x1) < (b.clip.x + b.clip.w))) &&
					    (((b.clip.y) <= (y1)) && ((y1) < (b.clip.y + b.clip.h)))))) &&
					(!((((b.clip.x) <= (x2)) && ((x2) < (b.clip.x + b.clip.w))) &&
					   (((b.clip.y) <= (y2)) && ((y2) < (b.clip.y + b.clip.h)))))) return;
			}

			cmd = (nk_command_triangle) (nk_command_buffer_push(b, (int) (NK_COMMAND_TRIANGLE)));
			if (cmd == null) return;
			cmd.line_thickness = ((ushort) (line_thickness));
			cmd.a.x = ((short) (x0));
			cmd.a.y = ((short) (y0));
			cmd.b.x = ((short) (x1));
			cmd.b.y = ((short) (y1));
			cmd.c.x = ((short) (x2));
			cmd.c.y = ((short) (y2));
			cmd.color = (nk_color) (c);
		}

		public static void nk_fill_triangle(nk_command_buffer b, float x0, float y0, float x1, float y1, float x2, float y2,
			nk_color c)
		{
			nk_command_triangle_filled cmd;
			if ((b == null) || ((c.a) == (0))) return;
			if (b == null) return;
			if ((b.use_clipping) != 0)
			{
				if (
					((!((((b.clip.x) <= (x0)) && ((x0) < (b.clip.x + b.clip.w))) &&
					    (((b.clip.y) <= (y0)) && ((y0) < (b.clip.y + b.clip.h))))) &&
					 (!((((b.clip.x) <= (x1)) && ((x1) < (b.clip.x + b.clip.w))) &&
					    (((b.clip.y) <= (y1)) && ((y1) < (b.clip.y + b.clip.h)))))) &&
					(!((((b.clip.x) <= (x2)) && ((x2) < (b.clip.x + b.clip.w))) &&
					   (((b.clip.y) <= (y2)) && ((y2) < (b.clip.y + b.clip.h)))))) return;
			}

			cmd = (nk_command_triangle_filled) (nk_command_buffer_push(b, (int) (NK_COMMAND_TRIANGLE_FILLED)));
			if (cmd == null) return;
			cmd.a.x = ((short) (x0));
			cmd.a.y = ((short) (y0));
			cmd.b.x = ((short) (x1));
			cmd.b.y = ((short) (y1));
			cmd.c.x = ((short) (x2));
			cmd.c.y = ((short) (y2));
			cmd.color = (nk_color) (c);
		}

		public static void nk_draw_image(nk_command_buffer b, nk_rect r, nk_image img, nk_color col)
		{
			nk_command_image cmd;
			if (b == null) return;
			if ((b.use_clipping) != 0)
			{
				if ((((b.clip.w) == (0)) || ((b.clip.h) == (0))) ||
				    (!(!(((((b.clip.x) > (r.x + r.w)) || ((b.clip.x + b.clip.w) < (r.x))) || ((b.clip.y) > (r.y + r.h))) ||
				         ((b.clip.y + b.clip.h) < (r.y)))))) return;
			}

			cmd = (nk_command_image) (nk_command_buffer_push(b, (int) (NK_COMMAND_IMAGE)));
			if (cmd == null) return;
			cmd.x = ((short) (r.x));
			cmd.y = ((short) (r.y));
			cmd.w = ((ushort) ((0) < (r.w) ? (r.w) : (0)));
			cmd.h = ((ushort) ((0) < (r.h) ? (r.h) : (0)));
			cmd.img = (nk_image) (img);
			cmd.col = (nk_color) (col);
		}

		public static void nk_push_custom(nk_command_buffer b, nk_rect r, NkCommandCustomCallback cb, nk_handle usr)
		{
			nk_command_custom cmd;
			if (b == null) return;
			if ((b.use_clipping) != 0)
			{
				if ((((b.clip.w) == (0)) || ((b.clip.h) == (0))) ||
				    (!(!(((((b.clip.x) > (r.x + r.w)) || ((b.clip.x + b.clip.w) < (r.x))) || ((b.clip.y) > (r.y + r.h))) ||
				         ((b.clip.y + b.clip.h) < (r.y)))))) return;
			}

			cmd = (nk_command_custom) (nk_command_buffer_push(b, (int) (NK_COMMAND_CUSTOM)));
			if (cmd == null) return;
			cmd.x = ((short) (r.x));
			cmd.y = ((short) (r.y));
			cmd.w = ((ushort) ((0) < (r.w) ? (r.w) : (0)));
			cmd.h = ((ushort) ((0) < (r.h) ? (r.h) : (0)));
			cmd.callback_data = (nk_handle) (usr);
			cmd.callback = cb;
		}

		public static void nk_draw_text(nk_command_buffer b, nk_rect r, char* _string_, int length, nk_user_font font,
			nk_color bg, nk_color fg)
		{
			float text_width = (float) (0);
			nk_command_text cmd;
			if ((((b == null) || (_string_ == null)) || (length == 0)) || (((bg.a) == (0)) && ((fg.a) == (0)))) return;
			if ((b.use_clipping) != 0)
			{
				if ((((b.clip.w) == (0)) || ((b.clip.h) == (0))) ||
				    (!(!(((((b.clip.x) > (r.x + r.w)) || ((b.clip.x + b.clip.w) < (r.x))) || ((b.clip.y) > (r.y + r.h))) ||
				         ((b.clip.y + b.clip.h) < (r.y)))))) return;
			}

			text_width = (float) (font.width((nk_handle) (font.userdata), (float) (font.height), _string_, (int) (length)));
			if ((text_width) > (r.w))
			{
				int glyphs = (int) (0);
				float txt_width = (float) (text_width);
				length = (int) (nk_text_clamp(font, _string_, (int) (length), (float) (r.w), &glyphs, &txt_width, null, (int) (0)));
			}

			if (length == 0) return;
			cmd = (nk_command_text) (nk_command_buffer_push(b, (int) (NK_COMMAND_TEXT)));
			if (cmd == null) return;
			cmd.x = ((short) (r.x));
			cmd.y = ((short) (r.y));
			cmd.w = ((ushort) (r.w));
			cmd.h = ((ushort) (r.h));
			cmd.background = (nk_color) (bg);
			cmd.foreground = (nk_color) (fg);
			cmd.font = font;
			cmd.length = (int) (length);
			cmd.height = (float) (font.height);
			cmd._string_ = new PinnedArray<char>(length);
			CRuntime.memcpy((void*) cmd._string_, _string_, length*sizeof (char));
			cmd._string_[length] = ('\0');
		}

		public static void nk_draw_list_init(nk_draw_list list)
		{
			ulong i = (ulong) (0);
			if (list == null) return;

			for (i = (ulong) (0); (i) < (ulong) list.circle_vtx.Length; ++i)
			{
				float a = (float) (((float) (i)/(float) (ulong) list.circle_vtx.Length)*2*3.141592654f);
				list.circle_vtx[i].x = (float) (nk_cos((float) (a)));
				list.circle_vtx[i].y = (float) (nk_sin((float) (a)));
			}
		}

		public static void nk_draw_list_setup(nk_draw_list canvas, nk_convert_config config, nk_buffer cmds,
			nk_buffer vertices, nk_buffer elements, int line_aa, int shape_aa)
		{
			if (((((canvas == null) || (config == null)) || (cmds == null)) || (vertices == null)) || (elements == null)) return;
			canvas.buffer = cmds;
			canvas.config = (nk_convert_config) (config);
			canvas.elements = elements;
			canvas.vertices = vertices;
			canvas.line_AA = (int) (line_aa);
			canvas.shape_AA = (int) (shape_aa);
			canvas.clip_rect = (nk_rect) (nk_null_rect);
		}

		public static nk_draw_command* nk__draw_list_begin(nk_draw_list canvas, nk_buffer buffer)
		{
			byte* memory;
			ulong offset;
			nk_draw_command* cmd;
			if (((buffer == null) || (buffer.size == 0)) || (canvas.cmd_count == 0)) return null;
			memory = (byte*) (buffer.memory.ptr);
			offset = (ulong) (buffer.memory.size - canvas.cmd_offset);
			cmd = ((nk_draw_command*) ((void*) ((memory) + (offset))));
			return cmd;
		}

		public static nk_draw_command* nk__draw_list_end(nk_draw_list canvas, nk_buffer buffer)
		{
			ulong size;
			ulong offset;
			byte* memory;
			nk_draw_command* end;
			if ((buffer == null) || (canvas == null)) return null;
			memory = (byte*) (buffer.memory.ptr);
			size = (ulong) (buffer.memory.size);
			offset = (ulong) (size - canvas.cmd_offset);
			end = ((nk_draw_command*) ((void*) ((memory) + (offset))));
			end -= (canvas.cmd_count - 1);
			return end;
		}

		public static nk_draw_command* nk__draw_list_next(nk_draw_command* cmd, nk_buffer buffer, nk_draw_list canvas)
		{
			nk_draw_command* end;
			if (((cmd == null) || (buffer == null)) || (canvas == null)) return null;
			end = nk__draw_list_end(canvas, buffer);
			if (cmd <= end) return null;
			return (cmd - 1);
		}

		public static void nk_draw_list_clear(nk_draw_list list)
		{
			if (list == null) return;
			if ((list.buffer) != null) nk_buffer_clear(list.buffer);
			if ((list.vertices) != null) nk_buffer_clear(list.vertices);
			if ((list.elements) != null) nk_buffer_clear(list.elements);
			list.element_count = (uint) (0);
			list.vertex_count = (uint) (0);
			list.cmd_offset = (ulong) (0);
			list.cmd_count = (uint) (0);
			list.path_count = (uint) (0);
			list.vertices = null;
			list.elements = null;
			list.clip_rect = (nk_rect) (nk_null_rect);
		}

		public static nk_vec2* nk_draw_list_alloc_path(nk_draw_list list, int count)
		{
			nk_vec2* points;
			ulong point_align = (ulong) (4);
			ulong point_size = (ulong) (sizeof (nk_vec2));
			points =
				(nk_vec2*)
					(nk_buffer_alloc(list.buffer, (int) (NK_BUFFER_FRONT), (ulong) (point_size*(ulong) (count)), (ulong) (point_align)));
			if (points == null) return null;
			if (list.path_offset == 0)
			{
				void* memory = nk_buffer_memory(list.buffer);
				list.path_offset = ((uint) ((byte*) (points) - (byte*) (memory)));
			}

			list.path_count += ((uint) (count));
			return points;
		}

		public static nk_vec2 nk_draw_list_path_last(nk_draw_list list)
		{
			void* memory;
			nk_vec2* point;
			memory = nk_buffer_memory(list.buffer);
			point = ((nk_vec2*) ((void*) ((byte*) (memory) + (list.path_offset))));
			point += (list.path_count - 1);
			return (nk_vec2) (*point);
		}

		public static nk_draw_command* nk_draw_list_push_command(nk_draw_list list, nk_rect clip, nk_handle texture)
		{
			ulong cmd_align = (ulong) (4);
			ulong cmd_size = (ulong) (sizeof (nk_draw_command));
			nk_draw_command* cmd;
			cmd =
				(nk_draw_command*) (nk_buffer_alloc(list.buffer, (int) (NK_BUFFER_BACK), (ulong) (cmd_size), (ulong) (cmd_align)));
			if (cmd == null) return null;
			if (list.cmd_count == 0)
			{
				byte* memory = (byte*) (nk_buffer_memory(list.buffer));
				ulong total = (ulong) (nk_buffer_total(list.buffer));
				memory = ((byte*) ((void*) ((memory) + (total))));
				list.cmd_offset = ((ulong) (memory - (byte*) (cmd)));
			}

			cmd->elem_count = (uint) (0);
			cmd->clip_rect = (nk_rect) (clip);
			cmd->texture = (nk_handle) (texture);
			cmd->userdata = (nk_handle) (list.userdata);
			list.cmd_count++;
			list.clip_rect = (nk_rect) (clip);
			return cmd;
		}

		public static nk_draw_command* nk_draw_list_command_last(nk_draw_list list)
		{
			void* memory;
			ulong size;
			nk_draw_command* cmd;
			memory = nk_buffer_memory(list.buffer);
			size = (ulong) (nk_buffer_total(list.buffer));
			cmd = ((nk_draw_command*) ((void*) ((byte*) (memory) + (size - list.cmd_offset))));
			return (cmd - (list.cmd_count - 1));
		}

		public static void nk_draw_list_add_clip(nk_draw_list list, nk_rect rect)
		{
			if (list == null) return;
			if (list.cmd_count == 0)
			{
				nk_draw_list_push_command(list, (nk_rect) (rect), (nk_handle) (list.config._null_.texture));
			}
			else
			{
				nk_draw_command* prev = nk_draw_list_command_last(list);
				if ((prev->elem_count) == (0)) prev->clip_rect = (nk_rect) (rect);
				nk_draw_list_push_command(list, (nk_rect) (rect), (nk_handle) (prev->texture));
			}

		}

		public static void nk_draw_list_push_image(nk_draw_list list, nk_handle texture)
		{
			if (list == null) return;
			if (list.cmd_count == 0)
			{
				nk_draw_list_push_command(list, (nk_rect) (nk_null_rect), (nk_handle) (texture));
			}
			else
			{
				nk_draw_command* prev = nk_draw_list_command_last(list);
				if ((prev->elem_count) == (0))
				{
					prev->texture = (nk_handle) (texture);
					prev->userdata = (nk_handle) (list.userdata);
				}
				else if ((prev->texture.id != texture.id) || (prev->userdata.id != list.userdata.id))
					nk_draw_list_push_command(list, (nk_rect) (prev->clip_rect), (nk_handle) (texture));
			}

		}

		public static void nk_draw_list_push_userdata(nk_draw_list list, nk_handle userdata)
		{
			list.userdata = (nk_handle) (userdata);
		}

		public static void* nk_draw_list_alloc_vertices(nk_draw_list list, ulong count)
		{
			void* vtx;
			if (list == null) return null;
			vtx = nk_buffer_alloc(list.vertices, (int) (NK_BUFFER_FRONT), (ulong) (list.config.vertex_size*count),
				(ulong) (list.config.vertex_alignment));
			if (vtx == null) return null;
			list.vertex_count += ((uint) (count));
			return vtx;
		}

		public static ushort* nk_draw_list_alloc_elements(nk_draw_list list, ulong count)
		{
			ushort* ids;
			nk_draw_command* cmd;
			ulong elem_align = (ulong) (2);
			ulong elem_size = (ulong) (sizeof (ushort));
			if (list == null) return null;
			ids =
				(ushort*) (nk_buffer_alloc(list.elements, (int) (NK_BUFFER_FRONT), (ulong) (elem_size*count), (ulong) (elem_align)));
			if (ids == null) return null;
			cmd = nk_draw_list_command_last(list);
			list.element_count += ((uint) (count));
			cmd->elem_count += ((uint) (count));
			return ids;
		}

		public static int nk_draw_vertex_layout_element_is_end_of_layout(nk_draw_vertex_layout_element* element)
		{
			return
				(int) (((element->attribute) == (NK_VERTEX_ATTRIBUTE_COUNT)) || ((element->format) == (NK_FORMAT_COUNT)) ? 1 : 0);
		}

		public static void nk_draw_vertex_color(void* attr, float* vals, int format)
		{
			float* val = stackalloc float[4];
			if (((format) < (NK_FORMAT_COLOR_BEGIN)) || ((format) > (NK_FORMAT_COLOR_END))) return;
			val[0] = (float) ((0) < ((1.0f) < (vals[0]) ? (1.0f) : (vals[0])) ? ((1.0f) < (vals[0]) ? (1.0f) : (vals[0])) : (0));
			val[1] = (float) ((0) < ((1.0f) < (vals[1]) ? (1.0f) : (vals[1])) ? ((1.0f) < (vals[1]) ? (1.0f) : (vals[1])) : (0));
			val[2] = (float) ((0) < ((1.0f) < (vals[2]) ? (1.0f) : (vals[2])) ? ((1.0f) < (vals[2]) ? (1.0f) : (vals[2])) : (0));
			val[3] = (float) ((0) < ((1.0f) < (vals[3]) ? (1.0f) : (vals[3])) ? ((1.0f) < (vals[3]) ? (1.0f) : (vals[3])) : (0));
			switch (format)
			{
				default:
					;
					break;
				case NK_FORMAT_R8G8B8A8:
				case NK_FORMAT_R8G8B8:
				{
					nk_color col = (nk_color) (nk_rgba_fv(val));
					nk_memcopy(attr, &col.r, (ulong) (sizeof (nk_color)));
				}
					break;
				case NK_FORMAT_B8G8R8A8:
				{
					nk_color col = (nk_color) (nk_rgba_fv(val));
					nk_color bgra = (nk_color) (nk_rgba((int) (col.b), (int) (col.g), (int) (col.r), (int) (col.a)));
					nk_memcopy(attr, &bgra, (ulong) (sizeof (nk_color)));
				}
					break;
				case NK_FORMAT_R16G15B16:
				{
					ushort* col = stackalloc ushort[3];
					col[0] = ((ushort) (val[0]*(float) (65535)));
					col[1] = ((ushort) (val[1]*(float) (65535)));
					col[2] = ((ushort) (val[2]*(float) (65535)));
					nk_memcopy(attr, col, (ulong) (sizeof (nk_color)));
				}
					break;
				case NK_FORMAT_R16G15B16A16:
				{
					ushort* col = stackalloc ushort[4];
					col[0] = ((ushort) (val[0]*(float) (65535)));
					col[1] = ((ushort) (val[1]*(float) (65535)));
					col[2] = ((ushort) (val[2]*(float) (65535)));
					col[3] = ((ushort) (val[3]*(float) (65535)));
					nk_memcopy(attr, col, (ulong) (sizeof (nk_color)));
				}
					break;
				case NK_FORMAT_R32G32B32:
				{
					uint* col = stackalloc uint[3];
					col[0] = ((uint) (val[0]*(float) (4294967295u)));
					col[1] = ((uint) (val[1]*(float) (4294967295u)));
					col[2] = ((uint) (val[2]*(float) (4294967295u)));
					nk_memcopy(attr, col, (ulong) (sizeof (nk_color)));
				}
					break;
				case NK_FORMAT_R32G32B32A32:
				{
					uint* col = stackalloc uint[4];
					col[0] = ((uint) (val[0]*(float) (4294967295u)));
					col[1] = ((uint) (val[1]*(float) (4294967295u)));
					col[2] = ((uint) (val[2]*(float) (4294967295u)));
					col[3] = ((uint) (val[3]*(float) (4294967295u)));
					nk_memcopy(attr, col, (ulong) (sizeof (nk_color)));
				}
					break;
				case NK_FORMAT_R32G32B32A32_FLOAT:
					nk_memcopy(attr, val, (ulong) (sizeof (float)*4));
					break;
				case NK_FORMAT_R32G32B32A32_DOUBLE:
				{
					double* col = stackalloc double[4];
					col[0] = ((double) (val[0]));
					col[1] = ((double) (val[1]));
					col[2] = ((double) (val[2]));
					col[3] = ((double) (val[3]));
					nk_memcopy(attr, col, (ulong) (sizeof (nk_color)));
				}
					break;
				case NK_FORMAT_RGB32:
				case NK_FORMAT_RGBA32:
				{
					nk_color col = (nk_color) (nk_rgba_fv(val));
					uint color = (uint) (nk_color_u32((nk_color) (col)));
					nk_memcopy(attr, &color, (ulong) (sizeof (uint)));
				}
					break;
			}

		}

		public static void nk_draw_vertex_element(void* dst, float* values, int value_count, int format)
		{
			int value_index;
			void* attribute = dst;
			if (((format) >= (NK_FORMAT_COLOR_BEGIN)) && (format <= NK_FORMAT_COLOR_END)) return;
			for (value_index = (int) (0); (value_index) < (value_count); ++value_index)
			{
				switch (format)
				{
					default:
						;
						break;
					case NK_FORMAT_SCHAR:
					{
						sbyte value =
							(sbyte)
								(((values[value_index]) < ((float) (127)) ? (values[value_index]) : ((float) (127))) < ((float) (-127))
									? ((float) (-127))
									: ((values[value_index]) < ((float) (127)) ? (values[value_index]) : ((float) (127))));
						nk_memcopy(attribute, &value, (ulong) (sizeof (double)));
						attribute = (void*) (((sbyte*) (attribute) + sizeof (char)));
					}
						break;
					case NK_FORMAT_SSHORT:
					{
						short value =
							(short)
								(((values[value_index]) < ((float) (32767)) ? (values[value_index]) : ((float) (32767))) < ((float) (-32767))
									? ((float) (-32767))
									: ((values[value_index]) < ((float) (32767)) ? (values[value_index]) : ((float) (32767))));
						nk_memcopy(attribute, &value, (ulong) (sizeof (double)));
						attribute = (void*) ((sbyte*) (attribute) + sizeof (short));
					}
						break;
					case NK_FORMAT_SINT:
					{
						int value =
							(int)
								(((values[value_index]) < ((float) (2147483647)) ? (values[value_index]) : ((float) (2147483647))) <
								 ((float) (-2147483647))
									? ((float) (-2147483647))
									: ((values[value_index]) < ((float) (2147483647)) ? (values[value_index]) : ((float) (2147483647))));
						nk_memcopy(attribute, &value, (ulong) (sizeof (double)));
						attribute = (void*) ((sbyte*) (attribute) + sizeof (int));
					}
						break;
					case NK_FORMAT_UCHAR:
					{
						byte value =
							(byte)
								(((values[value_index]) < ((float) (256)) ? (values[value_index]) : ((float) (256))) < ((float) (0))
									? ((float) (0))
									: ((values[value_index]) < ((float) (256)) ? (values[value_index]) : ((float) (256))));
						nk_memcopy(attribute, &value, (ulong) (sizeof (double)));
						attribute = (void*) (((sbyte*) (attribute) + sizeof (byte)));
					}
						break;
					case NK_FORMAT_USHORT:
					{
						ushort value =
							(ushort)
								(((values[value_index]) < ((float) (65535)) ? (values[value_index]) : ((float) (65535))) < ((float) (0))
									? ((float) (0))
									: ((values[value_index]) < ((float) (65535)) ? (values[value_index]) : ((float) (65535))));
						nk_memcopy(attribute, &value, (ulong) (sizeof (double)));
						attribute = (void*) ((sbyte*) (attribute) + sizeof (short));
					}
						break;
					case NK_FORMAT_UINT:
					{
						uint value =
							(uint)
								(((values[value_index]) < ((float) (4294967295u)) ? (values[value_index]) : ((float) (4294967295u))) <
								 ((float) (0))
									? ((float) (0))
									: ((values[value_index]) < ((float) (4294967295u)) ? (values[value_index]) : ((float) (4294967295u))));
						nk_memcopy(attribute, &value, (ulong) (sizeof (double)));
						attribute = (void*) ((sbyte*) (attribute) + sizeof (uint));
					}
						break;
					case NK_FORMAT_FLOAT:
						nk_memcopy(attribute, &values[value_index], (ulong) (sizeof (float)));
						attribute = (void*) (((sbyte*) (attribute) + sizeof (float)));
						break;
					case NK_FORMAT_DOUBLE:
					{
						double value = (double) (values[value_index]);
						nk_memcopy(attribute, &value, (ulong) (sizeof (double)));
						attribute = (void*) (((sbyte*) (attribute) + sizeof (double)));
					}
						break;
				}
			}
		}

		public static void* nk_draw_vertex(void* dst, nk_convert_config config, nk_vec2 pos, nk_vec2 uv, nk_colorf color)
		{
			void* result = (void*) ((sbyte*) (dst) + config.vertex_size);
			fixed (nk_draw_vertex_layout_element* elem_iter2 = config.vertex_layout)
			{
				nk_draw_vertex_layout_element* elem_iter = elem_iter2;
				while (nk_draw_vertex_layout_element_is_end_of_layout(elem_iter) == 0)
				{
					void* address = (void*) ((sbyte*) (dst) + elem_iter->offset);
					switch (elem_iter->attribute)
					{
						case NK_VERTEX_ATTRIBUTE_COUNT:
						default:
							;
							break;
						case NK_VERTEX_POSITION:
							nk_draw_vertex_element(address, &pos.x, (int) (2), (int) (elem_iter->format));
							break;
						case NK_VERTEX_TEXCOORD:
							nk_draw_vertex_element(address, &uv.x, (int) (2), (int) (elem_iter->format));
							break;
						case NK_VERTEX_COLOR:
							nk_draw_vertex_color(address, &color.r, (int) (elem_iter->format));
							break;
					}
					elem_iter++;
				}
			}
			return result;
		}

		public static void nk_draw_list_stroke_poly_line(nk_draw_list list, nk_vec2* points, uint points_count, nk_color color,
			int closed, float thickness, int aliasing)
		{
			ulong count;
			int thick_line;
			nk_colorf col = new nk_colorf();
			nk_colorf col_trans = new nk_colorf();
			if ((list == null) || ((points_count) < (2))) return;
			color.a = ((byte) ((float) (color.a)*list.config.global_alpha));
			count = (ulong) (points_count);
			if (closed == 0) count = (ulong) (points_count - 1);
			thick_line = (int) ((thickness) > (1.0f) ? 1 : 0);
			nk_draw_list_push_userdata(list, (nk_handle) (list.userdata));
			color.a = ((byte) ((float) (color.a)*list.config.global_alpha));
			nk_color_fv(&col.r, (nk_color) (color));
			col_trans = (nk_colorf) (col);
			col_trans.a = (float) (0);
			if ((aliasing) == (NK_ANTI_ALIASING_ON))
			{
				float AA_SIZE = (float) (1.0f);
				ulong pnt_align = (ulong) (4);
				ulong pnt_size = (ulong) (sizeof (nk_vec2));
				ulong i1 = (ulong) (0);
				ulong vertex_offset;
				ulong index = (ulong) (list.vertex_count);
				ulong idx_count = (ulong) ((thick_line) != 0 ? (count*18) : (count*12));
				ulong vtx_count = (ulong) ((thick_line) != 0 ? (points_count*4) : (points_count*3));
				void* vtx = nk_draw_list_alloc_vertices(list, (ulong) (vtx_count));
				ushort* ids = nk_draw_list_alloc_elements(list, (ulong) (idx_count));
				ulong size;
				nk_vec2* normals;
				nk_vec2* temp;
				if ((vtx == null) || (ids == null)) return;
				vertex_offset = ((ulong) ((byte*) (vtx) - (byte*) (list.vertices.memory.ptr)));
				nk_buffer_mark(list.vertices, (int) (NK_BUFFER_FRONT));
				size = (ulong) (pnt_size*(ulong) ((thick_line) != 0 ? 5 : 3)*points_count);
				normals = (nk_vec2*) (nk_buffer_alloc(list.vertices, (int) (NK_BUFFER_FRONT), (ulong) (size), (ulong) (pnt_align)));
				if (normals == null) return;
				temp = normals + points_count;
				vtx = (void*) ((byte*) (list.vertices.memory.ptr) + vertex_offset);
				for (i1 = (ulong) (0); (i1) < (count); ++i1)
				{
					ulong i2 = (ulong) (((i1 + 1) == (points_count)) ? 0 : (i1 + 1));
					nk_vec2 diff =
						(nk_vec2) (nk_vec2_((float) ((points[i2]).x - (points[i1]).x), (float) ((points[i2]).y - (points[i1]).y)));
					float len;
					len = (float) ((diff).x*(diff).x + (diff).y*(diff).y);
					if (len != 0.0f) len = (float) (nk_inv_sqrt((float) (len)));
					else len = (float) (1.0f);
					diff = (nk_vec2) (nk_vec2_((float) ((diff).x*(len)), (float) ((diff).y*(len))));
					normals[i1].x = (float) (diff.y);
					normals[i1].y = (float) (-diff.x);
				}
				if (closed == 0) normals[points_count - 1] = (nk_vec2) (normals[points_count - 2]);
				if (thick_line == 0)
				{
					ulong idx1;
					ulong i;
					if (closed == 0)
					{
						nk_vec2 d = new nk_vec2();
						temp[0] =
							(nk_vec2)
								(nk_vec2_(
									(float) ((points[0]).x + (nk_vec2_((float) ((normals[0]).x*(AA_SIZE)), (float) ((normals[0]).y*(AA_SIZE)))).x),
									(float) ((points[0]).y + (nk_vec2_((float) ((normals[0]).x*(AA_SIZE)), (float) ((normals[0]).y*(AA_SIZE)))).y)));
						temp[1] =
							(nk_vec2)
								(nk_vec2_(
									(float) ((points[0]).x - (nk_vec2_((float) ((normals[0]).x*(AA_SIZE)), (float) ((normals[0]).y*(AA_SIZE)))).x),
									(float) ((points[0]).y - (nk_vec2_((float) ((normals[0]).x*(AA_SIZE)), (float) ((normals[0]).y*(AA_SIZE)))).y)));
						d =
							(nk_vec2)
								(nk_vec2_((float) ((normals[points_count - 1]).x*(AA_SIZE)), (float) ((normals[points_count - 1]).y*(AA_SIZE))));
						temp[(points_count - 1)*2 + 0] =
							(nk_vec2)
								(nk_vec2_((float) ((points[points_count - 1]).x + (d).x), (float) ((points[points_count - 1]).y + (d).y)));
						temp[(points_count - 1)*2 + 1] =
							(nk_vec2)
								(nk_vec2_((float) ((points[points_count - 1]).x - (d).x), (float) ((points[points_count - 1]).y - (d).y)));
					}
					idx1 = (ulong) (index);
					for (i1 = (ulong) (0); (i1) < (count); i1++)
					{
						nk_vec2 dm = new nk_vec2();
						float dmr2;
						ulong i2 = (ulong) (((i1 + 1) == (points_count)) ? 0 : (i1 + 1));
						ulong idx2 = (ulong) (((i1 + 1) == (points_count)) ? index : (idx1 + 3));
						dm =
							(nk_vec2)
								(nk_vec2_(
									(float)
										((nk_vec2_((float) ((normals[i1]).x + (normals[i2]).x), (float) ((normals[i1]).y + (normals[i2]).y))).x*(0.5f)),
									(float)
										((nk_vec2_((float) ((normals[i1]).x + (normals[i2]).x), (float) ((normals[i1]).y + (normals[i2]).y))).y*(0.5f))));
						dmr2 = (float) (dm.x*dm.x + dm.y*dm.y);
						if ((dmr2) > (0.000001f))
						{
							float scale = (float) (1.0f/dmr2);
							scale = (float) ((100.0f) < (scale) ? (100.0f) : (scale));
							dm = (nk_vec2) (nk_vec2_((float) ((dm).x*(scale)), (float) ((dm).y*(scale))));
						}
						dm = (nk_vec2) (nk_vec2_((float) ((dm).x*(AA_SIZE)), (float) ((dm).y*(AA_SIZE))));
						temp[i2*2 + 0] = (nk_vec2) (nk_vec2_((float) ((points[i2]).x + (dm).x), (float) ((points[i2]).y + (dm).y)));
						temp[i2*2 + 1] = (nk_vec2) (nk_vec2_((float) ((points[i2]).x - (dm).x), (float) ((points[i2]).y - (dm).y)));
						ids[0] = ((ushort) (idx2 + 0));
						ids[1] = ((ushort) (idx1 + 0));
						ids[2] = ((ushort) (idx1 + 2));
						ids[3] = ((ushort) (idx1 + 2));
						ids[4] = ((ushort) (idx2 + 2));
						ids[5] = ((ushort) (idx2 + 0));
						ids[6] = ((ushort) (idx2 + 1));
						ids[7] = ((ushort) (idx1 + 1));
						ids[8] = ((ushort) (idx1 + 0));
						ids[9] = ((ushort) (idx1 + 0));
						ids[10] = ((ushort) (idx2 + 0));
						ids[11] = ((ushort) (idx2 + 1));
						ids += 12;
						idx1 = (ulong) (idx2);
					}
					for (i = (ulong) (0); (i) < (points_count); ++i)
					{
						nk_vec2 uv = (nk_vec2) (list.config._null_.uv);
						vtx = nk_draw_vertex(vtx, list.config, (nk_vec2) (points[i]), (nk_vec2) (uv), (nk_colorf) (col));
						vtx = nk_draw_vertex(vtx, list.config, (nk_vec2) (temp[i*2 + 0]), (nk_vec2) (uv), (nk_colorf) (col_trans));
						vtx = nk_draw_vertex(vtx, list.config, (nk_vec2) (temp[i*2 + 1]), (nk_vec2) (uv), (nk_colorf) (col_trans));
					}
				}
				else
				{
					ulong idx1;
					ulong i;
					float half_inner_thickness = (float) ((thickness - AA_SIZE)*0.5f);
					if (closed == 0)
					{
						nk_vec2 d1 =
							(nk_vec2)
								(nk_vec2_((float) ((normals[0]).x*(half_inner_thickness + AA_SIZE)),
									(float) ((normals[0]).y*(half_inner_thickness + AA_SIZE))));
						nk_vec2 d2 =
							(nk_vec2)
								(nk_vec2_((float) ((normals[0]).x*(half_inner_thickness)), (float) ((normals[0]).y*(half_inner_thickness))));
						temp[0] = (nk_vec2) (nk_vec2_((float) ((points[0]).x + (d1).x), (float) ((points[0]).y + (d1).y)));
						temp[1] = (nk_vec2) (nk_vec2_((float) ((points[0]).x + (d2).x), (float) ((points[0]).y + (d2).y)));
						temp[2] = (nk_vec2) (nk_vec2_((float) ((points[0]).x - (d2).x), (float) ((points[0]).y - (d2).y)));
						temp[3] = (nk_vec2) (nk_vec2_((float) ((points[0]).x - (d1).x), (float) ((points[0]).y - (d1).y)));
						d1 =
							(nk_vec2)
								(nk_vec2_((float) ((normals[points_count - 1]).x*(half_inner_thickness + AA_SIZE)),
									(float) ((normals[points_count - 1]).y*(half_inner_thickness + AA_SIZE))));
						d2 =
							(nk_vec2)
								(nk_vec2_((float) ((normals[points_count - 1]).x*(half_inner_thickness)),
									(float) ((normals[points_count - 1]).y*(half_inner_thickness))));
						temp[(points_count - 1)*4 + 0] =
							(nk_vec2)
								(nk_vec2_((float) ((points[points_count - 1]).x + (d1).x), (float) ((points[points_count - 1]).y + (d1).y)));
						temp[(points_count - 1)*4 + 1] =
							(nk_vec2)
								(nk_vec2_((float) ((points[points_count - 1]).x + (d2).x), (float) ((points[points_count - 1]).y + (d2).y)));
						temp[(points_count - 1)*4 + 2] =
							(nk_vec2)
								(nk_vec2_((float) ((points[points_count - 1]).x - (d2).x), (float) ((points[points_count - 1]).y - (d2).y)));
						temp[(points_count - 1)*4 + 3] =
							(nk_vec2)
								(nk_vec2_((float) ((points[points_count - 1]).x - (d1).x), (float) ((points[points_count - 1]).y - (d1).y)));
					}
					idx1 = (ulong) (index);
					for (i1 = (ulong) (0); (i1) < (count); ++i1)
					{
						nk_vec2 dm_out = new nk_vec2();
						nk_vec2 dm_in = new nk_vec2();
						ulong i2 = (ulong) (((i1 + 1) == (points_count)) ? 0 : (i1 + 1));
						ulong idx2 = (ulong) (((i1 + 1) == (points_count)) ? index : (idx1 + 4));
						nk_vec2 dm =
							(nk_vec2)
								(nk_vec2_(
									(float)
										((nk_vec2_((float) ((normals[i1]).x + (normals[i2]).x), (float) ((normals[i1]).y + (normals[i2]).y))).x*(0.5f)),
									(float)
										((nk_vec2_((float) ((normals[i1]).x + (normals[i2]).x), (float) ((normals[i1]).y + (normals[i2]).y))).y*(0.5f))));
						float dmr2 = (float) (dm.x*dm.x + dm.y*dm.y);
						if ((dmr2) > (0.000001f))
						{
							float scale = (float) (1.0f/dmr2);
							scale = (float) ((100.0f) < (scale) ? (100.0f) : (scale));
							dm = (nk_vec2) (nk_vec2_((float) ((dm).x*(scale)), (float) ((dm).y*(scale))));
						}
						dm_out =
							(nk_vec2)
								(nk_vec2_((float) ((dm).x*((half_inner_thickness) + AA_SIZE)),
									(float) ((dm).y*((half_inner_thickness) + AA_SIZE))));
						dm_in = (nk_vec2) (nk_vec2_((float) ((dm).x*(half_inner_thickness)), (float) ((dm).y*(half_inner_thickness))));
						temp[i2*4 + 0] =
							(nk_vec2) (nk_vec2_((float) ((points[i2]).x + (dm_out).x), (float) ((points[i2]).y + (dm_out).y)));
						temp[i2*4 + 1] = (nk_vec2) (nk_vec2_((float) ((points[i2]).x + (dm_in).x), (float) ((points[i2]).y + (dm_in).y)));
						temp[i2*4 + 2] = (nk_vec2) (nk_vec2_((float) ((points[i2]).x - (dm_in).x), (float) ((points[i2]).y - (dm_in).y)));
						temp[i2*4 + 3] =
							(nk_vec2) (nk_vec2_((float) ((points[i2]).x - (dm_out).x), (float) ((points[i2]).y - (dm_out).y)));
						ids[0] = ((ushort) (idx2 + 1));
						ids[1] = ((ushort) (idx1 + 1));
						ids[2] = ((ushort) (idx1 + 2));
						ids[3] = ((ushort) (idx1 + 2));
						ids[4] = ((ushort) (idx2 + 2));
						ids[5] = ((ushort) (idx2 + 1));
						ids[6] = ((ushort) (idx2 + 1));
						ids[7] = ((ushort) (idx1 + 1));
						ids[8] = ((ushort) (idx1 + 0));
						ids[9] = ((ushort) (idx1 + 0));
						ids[10] = ((ushort) (idx2 + 0));
						ids[11] = ((ushort) (idx2 + 1));
						ids[12] = ((ushort) (idx2 + 2));
						ids[13] = ((ushort) (idx1 + 2));
						ids[14] = ((ushort) (idx1 + 3));
						ids[15] = ((ushort) (idx1 + 3));
						ids[16] = ((ushort) (idx2 + 3));
						ids[17] = ((ushort) (idx2 + 2));
						ids += 18;
						idx1 = (ulong) (idx2);
					}
					for (i = (ulong) (0); (i) < (points_count); ++i)
					{
						nk_vec2 uv = (nk_vec2) (list.config._null_.uv);
						vtx = nk_draw_vertex(vtx, list.config, (nk_vec2) (temp[i*4 + 0]), (nk_vec2) (uv), (nk_colorf) (col_trans));
						vtx = nk_draw_vertex(vtx, list.config, (nk_vec2) (temp[i*4 + 1]), (nk_vec2) (uv), (nk_colorf) (col));
						vtx = nk_draw_vertex(vtx, list.config, (nk_vec2) (temp[i*4 + 2]), (nk_vec2) (uv), (nk_colorf) (col));
						vtx = nk_draw_vertex(vtx, list.config, (nk_vec2) (temp[i*4 + 3]), (nk_vec2) (uv), (nk_colorf) (col_trans));
					}
				}
				nk_buffer_reset(list.vertices, (int) (NK_BUFFER_FRONT));
			}
			else
			{
				ulong i1 = (ulong) (0);
				ulong idx = (ulong) (list.vertex_count);
				ulong idx_count = (ulong) (count*6);
				ulong vtx_count = (ulong) (count*4);
				void* vtx = nk_draw_list_alloc_vertices(list, (ulong) (vtx_count));
				ushort* ids = nk_draw_list_alloc_elements(list, (ulong) (idx_count));
				if ((vtx == null) || (ids == null)) return;
				for (i1 = (ulong) (0); (i1) < (count); ++i1)
				{
					float dx;
					float dy;
					nk_vec2 uv = (nk_vec2) (list.config._null_.uv);
					ulong i2 = (ulong) (((i1 + 1) == (points_count)) ? 0 : i1 + 1);
					nk_vec2 p1 = (nk_vec2) (points[i1]);
					nk_vec2 p2 = (nk_vec2) (points[i2]);
					nk_vec2 diff = (nk_vec2) (nk_vec2_((float) ((p2).x - (p1).x), (float) ((p2).y - (p1).y)));
					float len;
					len = (float) ((diff).x*(diff).x + (diff).y*(diff).y);
					if (len != 0.0f) len = (float) (nk_inv_sqrt((float) (len)));
					else len = (float) (1.0f);
					diff = (nk_vec2) (nk_vec2_((float) ((diff).x*(len)), (float) ((diff).y*(len))));
					dx = (float) (diff.x*(thickness*0.5f));
					dy = (float) (diff.y*(thickness*0.5f));
					vtx = nk_draw_vertex(vtx, list.config, (nk_vec2) (nk_vec2_((float) (p1.x + dy), (float) (p1.y - dx))),
						(nk_vec2) (uv), (nk_colorf) (col));
					vtx = nk_draw_vertex(vtx, list.config, (nk_vec2) (nk_vec2_((float) (p2.x + dy), (float) (p2.y - dx))),
						(nk_vec2) (uv), (nk_colorf) (col));
					vtx = nk_draw_vertex(vtx, list.config, (nk_vec2) (nk_vec2_((float) (p2.x - dy), (float) (p2.y + dx))),
						(nk_vec2) (uv), (nk_colorf) (col));
					vtx = nk_draw_vertex(vtx, list.config, (nk_vec2) (nk_vec2_((float) (p1.x - dy), (float) (p1.y + dx))),
						(nk_vec2) (uv), (nk_colorf) (col));
					ids[0] = ((ushort) (idx + 0));
					ids[1] = ((ushort) (idx + 1));
					ids[2] = ((ushort) (idx + 2));
					ids[3] = ((ushort) (idx + 0));
					ids[4] = ((ushort) (idx + 2));
					ids[5] = ((ushort) (idx + 3));
					ids += 6;
					idx += (ulong) (4);
				}
			}

		}

		public static void nk_draw_list_fill_poly_convex(nk_draw_list list, nk_vec2* points, uint points_count, nk_color color,
			int aliasing)
		{
			nk_colorf col = new nk_colorf();
			nk_colorf col_trans = new nk_colorf();
			ulong pnt_align = (ulong) (4);
			ulong pnt_size = (ulong) (sizeof (nk_vec2));
			if ((list == null) || ((points_count) < (3))) return;
			nk_draw_list_push_userdata(list, (nk_handle) (list.userdata));
			color.a = ((byte) ((float) (color.a)*list.config.global_alpha));
			nk_color_fv(&col.r, (nk_color) (color));
			col_trans = (nk_colorf) (col);
			col_trans.a = (float) (0);
			if ((aliasing) == (NK_ANTI_ALIASING_ON))
			{
				ulong i = (ulong) (0);
				ulong i0 = (ulong) (0);
				ulong i1 = (ulong) (0);
				float AA_SIZE = (float) (1.0f);
				ulong vertex_offset = (ulong) (0);
				ulong index = (ulong) (list.vertex_count);
				ulong idx_count = (ulong) ((points_count - 2)*3 + points_count*6);
				ulong vtx_count = (ulong) (points_count*2);
				void* vtx = nk_draw_list_alloc_vertices(list, (ulong) (vtx_count));
				ushort* ids = nk_draw_list_alloc_elements(list, (ulong) (idx_count));
				ulong size = (ulong) (0);
				nk_vec2* normals = null;
				uint vtx_inner_idx = (uint) (index + 0);
				uint vtx_outer_idx = (uint) (index + 1);
				if ((vtx == null) || (ids == null)) return;
				vertex_offset = ((ulong) ((byte*) (vtx) - (byte*) (list.vertices.memory.ptr)));
				nk_buffer_mark(list.vertices, (int) (NK_BUFFER_FRONT));
				size = (ulong) (pnt_size*points_count);
				normals = (nk_vec2*) (nk_buffer_alloc(list.vertices, (int) (NK_BUFFER_FRONT), (ulong) (size), (ulong) (pnt_align)));
				if (normals == null) return;
				vtx = (void*) ((byte*) (list.vertices.memory.ptr) + vertex_offset);
				for (i = (ulong) (2); (i) < (points_count); i++)
				{
					ids[0] = ((ushort) (vtx_inner_idx));
					ids[1] = ((ushort) (vtx_inner_idx + ((i - 1) << 1)));
					ids[2] = ((ushort) (vtx_inner_idx + (i << 1)));
					ids += 3;
				}
				for (i0 = (ulong) (points_count - 1) , i1 = (ulong) (0); (i1) < (points_count); i0 = (ulong) (i1++))
				{
					nk_vec2 p0 = (nk_vec2) (points[i0]);
					nk_vec2 p1 = (nk_vec2) (points[i1]);
					nk_vec2 diff = (nk_vec2) (nk_vec2_((float) ((p1).x - (p0).x), (float) ((p1).y - (p0).y)));
					float len = (float) ((diff).x*(diff).x + (diff).y*(diff).y);
					if (len != 0.0f) len = (float) (nk_inv_sqrt((float) (len)));
					else len = (float) (1.0f);
					diff = (nk_vec2) (nk_vec2_((float) ((diff).x*(len)), (float) ((diff).y*(len))));
					normals[i0].x = (float) (diff.y);
					normals[i0].y = (float) (-diff.x);
				}
				for (i0 = (ulong) (points_count - 1) , i1 = (ulong) (0); (i1) < (points_count); i0 = (ulong) (i1++))
				{
					nk_vec2 uv = (nk_vec2) (list.config._null_.uv);
					nk_vec2 n0 = (nk_vec2) (normals[i0]);
					nk_vec2 n1 = (nk_vec2) (normals[i1]);
					nk_vec2 dm =
						(nk_vec2)
							(nk_vec2_((float) ((nk_vec2_((float) ((n0).x + (n1).x), (float) ((n0).y + (n1).y))).x*(0.5f)),
								(float) ((nk_vec2_((float) ((n0).x + (n1).x), (float) ((n0).y + (n1).y))).y*(0.5f))));
					float dmr2 = (float) (dm.x*dm.x + dm.y*dm.y);
					if ((dmr2) > (0.000001f))
					{
						float scale = (float) (1.0f/dmr2);
						scale = (float) ((scale) < (100.0f) ? (scale) : (100.0f));
						dm = (nk_vec2) (nk_vec2_((float) ((dm).x*(scale)), (float) ((dm).y*(scale))));
					}
					dm = (nk_vec2) (nk_vec2_((float) ((dm).x*(AA_SIZE*0.5f)), (float) ((dm).y*(AA_SIZE*0.5f))));
					vtx = nk_draw_vertex(vtx, list.config,
						(nk_vec2) (nk_vec2_((float) ((points[i1]).x - (dm).x), (float) ((points[i1]).y - (dm).y))), (nk_vec2) (uv),
						(nk_colorf) (col));
					vtx = nk_draw_vertex(vtx, list.config,
						(nk_vec2) (nk_vec2_((float) ((points[i1]).x + (dm).x), (float) ((points[i1]).y + (dm).y))), (nk_vec2) (uv),
						(nk_colorf) (col_trans));
					ids[0] = ((ushort) (vtx_inner_idx + (i1 << 1)));
					ids[1] = ((ushort) (vtx_inner_idx + (i0 << 1)));
					ids[2] = ((ushort) (vtx_outer_idx + (i0 << 1)));
					ids[3] = ((ushort) (vtx_outer_idx + (i0 << 1)));
					ids[4] = ((ushort) (vtx_outer_idx + (i1 << 1)));
					ids[5] = ((ushort) (vtx_inner_idx + (i1 << 1)));
					ids += 6;
				}
				nk_buffer_reset(list.vertices, (int) (NK_BUFFER_FRONT));
			}
			else
			{
				ulong i = (ulong) (0);
				ulong index = (ulong) (list.vertex_count);
				ulong idx_count = (ulong) ((points_count - 2)*3);
				ulong vtx_count = (ulong) (points_count);
				void* vtx = nk_draw_list_alloc_vertices(list, (ulong) (vtx_count));
				ushort* ids = nk_draw_list_alloc_elements(list, (ulong) (idx_count));
				if ((vtx == null) || (ids == null)) return;
				for (i = (ulong) (0); (i) < (vtx_count); ++i)
				{
					vtx = nk_draw_vertex(vtx, list.config, (nk_vec2) (points[i]), (nk_vec2) (list.config._null_.uv), (nk_colorf) (col));
				}
				for (i = (ulong) (2); (i) < (points_count); ++i)
				{
					ids[0] = ((ushort) (index));
					ids[1] = ((ushort) (index + i - 1));
					ids[2] = ((ushort) (index + i));
					ids += 3;
				}
			}

		}

		public static void nk_draw_list_path_clear(nk_draw_list list)
		{
			if (list == null) return;
			nk_buffer_reset(list.buffer, (int) (NK_BUFFER_FRONT));
			list.path_count = (uint) (0);
			list.path_offset = (uint) (0);
		}

		public static void nk_draw_list_path_line_to(nk_draw_list list, nk_vec2 pos)
		{
			nk_vec2* points = null;
			nk_draw_command* cmd = null;
			if (list == null) return;
			if (list.cmd_count == 0) nk_draw_list_add_clip(list, (nk_rect) (nk_null_rect));
			cmd = nk_draw_list_command_last(list);
			if (((cmd) != null) && (cmd->texture.ptr != list.config._null_.texture.ptr))
				nk_draw_list_push_image(list, (nk_handle) (list.config._null_.texture));
			points = nk_draw_list_alloc_path(list, (int) (1));
			if (points == null) return;
			points[0] = (nk_vec2) (pos);
		}

		public static void nk_draw_list_path_arc_to_fast(nk_draw_list list, nk_vec2 center, float radius, int a_min, int a_max)
		{
			int a = (int) (0);
			if (list == null) return;
			if (a_min <= a_max)
			{
				for (a = (int) (a_min); a <= a_max; a++)
				{
					nk_vec2 c = (nk_vec2) (list.circle_vtx[(ulong) (a)%(ulong) list.circle_vtx.Length]);
					float x = (float) (center.x + c.x*radius);
					float y = (float) (center.y + c.y*radius);
					nk_draw_list_path_line_to(list, (nk_vec2) (nk_vec2_((float) (x), (float) (y))));
				}
			}

		}

		public static void nk_draw_list_path_arc_to(nk_draw_list list, nk_vec2 center, float radius, float a_min, float a_max,
			uint segments)
		{
			uint i = (uint) (0);
			if (list == null) return;
			if ((radius) == (0.0f)) return;
			{
				float d_angle = (float) ((a_max - a_min)/(float) (segments));
				float sin_d = (float) (nk_sin((float) (d_angle)));
				float cos_d = (float) (nk_cos((float) (d_angle)));
				float cx = (float) (nk_cos((float) (a_min))*radius);
				float cy = (float) (nk_sin((float) (a_min))*radius);
				for (i = (uint) (0); i <= segments; ++i)
				{
					float new_cx;
					float new_cy;
					float x = (float) (center.x + cx);
					float y = (float) (center.y + cy);
					nk_draw_list_path_line_to(list, (nk_vec2) (nk_vec2_((float) (x), (float) (y))));
					new_cx = (float) (cx*cos_d - cy*sin_d);
					new_cy = (float) (cy*cos_d + cx*sin_d);
					cx = (float) (new_cx);
					cy = (float) (new_cy);
				}
			}

		}

		public static void nk_draw_list_path_rect_to(nk_draw_list list, nk_vec2 a, nk_vec2 b, float rounding)
		{
			float r;
			if (list == null) return;
			r = (float) (rounding);
			r =
				(float)
					((r) < (((b.x - a.x) < (0)) ? -(b.x - a.x) : (b.x - a.x))
						? (r)
						: (((b.x - a.x) < (0)) ? -(b.x - a.x) : (b.x - a.x)));
			r =
				(float)
					((r) < (((b.y - a.y) < (0)) ? -(b.y - a.y) : (b.y - a.y))
						? (r)
						: (((b.y - a.y) < (0)) ? -(b.y - a.y) : (b.y - a.y)));
			if ((r) == (0.0f))
			{
				nk_draw_list_path_line_to(list, (nk_vec2) (a));
				nk_draw_list_path_line_to(list, (nk_vec2) (nk_vec2_((float) (b.x), (float) (a.y))));
				nk_draw_list_path_line_to(list, (nk_vec2) (b));
				nk_draw_list_path_line_to(list, (nk_vec2) (nk_vec2_((float) (a.x), (float) (b.y))));
			}
			else
			{
				nk_draw_list_path_arc_to_fast(list, (nk_vec2) (nk_vec2_((float) (a.x + r), (float) (a.y + r))), (float) (r),
					(int) (6), (int) (9));
				nk_draw_list_path_arc_to_fast(list, (nk_vec2) (nk_vec2_((float) (b.x - r), (float) (a.y + r))), (float) (r),
					(int) (9), (int) (12));
				nk_draw_list_path_arc_to_fast(list, (nk_vec2) (nk_vec2_((float) (b.x - r), (float) (b.y - r))), (float) (r),
					(int) (0), (int) (3));
				nk_draw_list_path_arc_to_fast(list, (nk_vec2) (nk_vec2_((float) (a.x + r), (float) (b.y - r))), (float) (r),
					(int) (3), (int) (6));
			}

		}

		public static void nk_draw_list_path_curve_to(nk_draw_list list, nk_vec2 p2, nk_vec2 p3, nk_vec2 p4, uint num_segments)
		{
			float t_step;
			uint i_step;
			nk_vec2 p1 = new nk_vec2();
			if ((list == null) || (list.path_count == 0)) return;
			num_segments = (uint) ((num_segments) < (1) ? (1) : (num_segments));
			p1 = (nk_vec2) (nk_draw_list_path_last(list));
			t_step = (float) (1.0f/(float) (num_segments));
			for (i_step = (uint) (1); i_step <= num_segments; ++i_step)
			{
				float t = (float) (t_step*(float) (i_step));
				float u = (float) (1.0f - t);
				float w1 = (float) (u*u*u);
				float w2 = (float) (3*u*u*t);
				float w3 = (float) (3*u*t*t);
				float w4 = (float) (t*t*t);
				float x = (float) (w1*p1.x + w2*p2.x + w3*p3.x + w4*p4.x);
				float y = (float) (w1*p1.y + w2*p2.y + w3*p3.y + w4*p4.y);
				nk_draw_list_path_line_to(list, (nk_vec2) (nk_vec2_((float) (x), (float) (y))));
			}
		}

		public static void nk_draw_list_path_fill(nk_draw_list list, nk_color color)
		{
			nk_vec2* points;
			if (list == null) return;
			points = (nk_vec2*) (nk_buffer_memory(list.buffer));
			nk_draw_list_fill_poly_convex(list, points, (uint) (list.path_count), (nk_color) (color),
				(int) (list.config.shape_AA));
			nk_draw_list_path_clear(list);
		}

		public static void nk_draw_list_path_stroke(nk_draw_list list, nk_color color, int closed, float thickness)
		{
			nk_vec2* points;
			if (list == null) return;
			points = (nk_vec2*) (nk_buffer_memory(list.buffer));
			nk_draw_list_stroke_poly_line(list, points, (uint) (list.path_count), (nk_color) (color), (int) (closed),
				(float) (thickness), (int) (list.config.line_AA));
			nk_draw_list_path_clear(list);
		}

		public static void nk_draw_list_stroke_line(nk_draw_list list, nk_vec2 a, nk_vec2 b, nk_color col, float thickness)
		{
			if ((list == null) || (col.a == 0)) return;
			if ((list.line_AA) == (NK_ANTI_ALIASING_ON))
			{
				nk_draw_list_path_line_to(list, (nk_vec2) (a));
				nk_draw_list_path_line_to(list, (nk_vec2) (b));
			}
			else
			{
				nk_draw_list_path_line_to(list,
					(nk_vec2)
						(nk_vec2_((float) ((a).x - (nk_vec2_((float) (0.5f), (float) (0.5f))).x),
							(float) ((a).y - (nk_vec2_((float) (0.5f), (float) (0.5f))).y))));
				nk_draw_list_path_line_to(list,
					(nk_vec2)
						(nk_vec2_((float) ((b).x - (nk_vec2_((float) (0.5f), (float) (0.5f))).x),
							(float) ((b).y - (nk_vec2_((float) (0.5f), (float) (0.5f))).y))));
			}

			nk_draw_list_path_stroke(list, (nk_color) (col), (int) (NK_STROKE_OPEN), (float) (thickness));
		}

		public static void nk_draw_list_fill_rect(nk_draw_list list, nk_rect rect, nk_color col, float rounding)
		{
			if ((list == null) || (col.a == 0)) return;
			if ((list.line_AA) == (NK_ANTI_ALIASING_ON))
			{
				nk_draw_list_path_rect_to(list, (nk_vec2) (nk_vec2_((float) (rect.x), (float) (rect.y))),
					(nk_vec2) (nk_vec2_((float) (rect.x + rect.w), (float) (rect.y + rect.h))), (float) (rounding));
			}
			else
			{
				nk_draw_list_path_rect_to(list, (nk_vec2) (nk_vec2_((float) (rect.x - 0.5f), (float) (rect.y - 0.5f))),
					(nk_vec2) (nk_vec2_((float) (rect.x + rect.w), (float) (rect.y + rect.h))), (float) (rounding));
			}

			nk_draw_list_path_fill(list, (nk_color) (col));
		}

		public static void nk_draw_list_stroke_rect(nk_draw_list list, nk_rect rect, nk_color col, float rounding,
			float thickness)
		{
			if ((list == null) || (col.a == 0)) return;
			if ((list.line_AA) == (NK_ANTI_ALIASING_ON))
			{
				nk_draw_list_path_rect_to(list, (nk_vec2) (nk_vec2_((float) (rect.x), (float) (rect.y))),
					(nk_vec2) (nk_vec2_((float) (rect.x + rect.w), (float) (rect.y + rect.h))), (float) (rounding));
			}
			else
			{
				nk_draw_list_path_rect_to(list, (nk_vec2) (nk_vec2_((float) (rect.x - 0.5f), (float) (rect.y - 0.5f))),
					(nk_vec2) (nk_vec2_((float) (rect.x + rect.w), (float) (rect.y + rect.h))), (float) (rounding));
			}

			nk_draw_list_path_stroke(list, (nk_color) (col), (int) (NK_STROKE_CLOSED), (float) (thickness));
		}

		public static void nk_draw_list_fill_rect_multi_color(nk_draw_list list, nk_rect rect, nk_color left, nk_color top,
			nk_color right, nk_color bottom)
		{
			void* vtx;
			nk_colorf col_left = new nk_colorf();
			nk_colorf col_top = new nk_colorf();
			nk_colorf col_right = new nk_colorf();
			nk_colorf col_bottom = new nk_colorf();
			ushort* idx;
			ushort index;
			nk_color_fv(&col_left.r, (nk_color) (left));
			nk_color_fv(&col_right.r, (nk_color) (right));
			nk_color_fv(&col_top.r, (nk_color) (top));
			nk_color_fv(&col_bottom.r, (nk_color) (bottom));
			if (list == null) return;
			nk_draw_list_push_image(list, (nk_handle) (list.config._null_.texture));
			index = ((ushort) (list.vertex_count));
			vtx = nk_draw_list_alloc_vertices(list, (ulong) (4));
			idx = nk_draw_list_alloc_elements(list, (ulong) (6));
			if ((vtx == null) || (idx == null)) return;
			idx[0] = ((ushort) (index + 0));
			idx[1] = ((ushort) (index + 1));
			idx[2] = ((ushort) (index + 2));
			idx[3] = ((ushort) (index + 0));
			idx[4] = ((ushort) (index + 2));
			idx[5] = ((ushort) (index + 3));
			vtx = nk_draw_vertex(vtx, list.config, (nk_vec2) (nk_vec2_((float) (rect.x), (float) (rect.y))),
				(nk_vec2) (list.config._null_.uv), (nk_colorf) (col_left));
			vtx = nk_draw_vertex(vtx, list.config, (nk_vec2) (nk_vec2_((float) (rect.x + rect.w), (float) (rect.y))),
				(nk_vec2) (list.config._null_.uv), (nk_colorf) (col_top));
			vtx = nk_draw_vertex(vtx, list.config, (nk_vec2) (nk_vec2_((float) (rect.x + rect.w), (float) (rect.y + rect.h))),
				(nk_vec2) (list.config._null_.uv), (nk_colorf) (col_right));
			vtx = nk_draw_vertex(vtx, list.config, (nk_vec2) (nk_vec2_((float) (rect.x), (float) (rect.y + rect.h))),
				(nk_vec2) (list.config._null_.uv), (nk_colorf) (col_bottom));
		}

		public static void nk_draw_list_fill_triangle(nk_draw_list list, nk_vec2 a, nk_vec2 b, nk_vec2 c, nk_color col)
		{
			if ((list == null) || (col.a == 0)) return;
			nk_draw_list_path_line_to(list, (nk_vec2) (a));
			nk_draw_list_path_line_to(list, (nk_vec2) (b));
			nk_draw_list_path_line_to(list, (nk_vec2) (c));
			nk_draw_list_path_fill(list, (nk_color) (col));
		}

		public static void nk_draw_list_stroke_triangle(nk_draw_list list, nk_vec2 a, nk_vec2 b, nk_vec2 c, nk_color col,
			float thickness)
		{
			if ((list == null) || (col.a == 0)) return;
			nk_draw_list_path_line_to(list, (nk_vec2) (a));
			nk_draw_list_path_line_to(list, (nk_vec2) (b));
			nk_draw_list_path_line_to(list, (nk_vec2) (c));
			nk_draw_list_path_stroke(list, (nk_color) (col), (int) (NK_STROKE_CLOSED), (float) (thickness));
		}

		public static void nk_draw_list_fill_circle(nk_draw_list list, nk_vec2 center, float radius, nk_color col, uint segs)
		{
			float a_max;
			if ((list == null) || (col.a == 0)) return;
			a_max = (float) (3.141592654f*2.0f*((float) (segs) - 1.0f)/(float) (segs));
			nk_draw_list_path_arc_to(list, (nk_vec2) (center), (float) (radius), (float) (0.0f), (float) (a_max), (uint) (segs));
			nk_draw_list_path_fill(list, (nk_color) (col));
		}

		public static void nk_draw_list_stroke_circle(nk_draw_list list, nk_vec2 center, float radius, nk_color col, uint segs,
			float thickness)
		{
			float a_max;
			if ((list == null) || (col.a == 0)) return;
			a_max = (float) (3.141592654f*2.0f*((float) (segs) - 1.0f)/(float) (segs));
			nk_draw_list_path_arc_to(list, (nk_vec2) (center), (float) (radius), (float) (0.0f), (float) (a_max), (uint) (segs));
			nk_draw_list_path_stroke(list, (nk_color) (col), (int) (NK_STROKE_CLOSED), (float) (thickness));
		}

		public static void nk_draw_list_stroke_curve(nk_draw_list list, nk_vec2 p0, nk_vec2 cp0, nk_vec2 cp1, nk_vec2 p1,
			nk_color col, uint segments, float thickness)
		{
			if ((list == null) || (col.a == 0)) return;
			nk_draw_list_path_line_to(list, (nk_vec2) (p0));
			nk_draw_list_path_curve_to(list, (nk_vec2) (cp0), (nk_vec2) (cp1), (nk_vec2) (p1), (uint) (segments));
			nk_draw_list_path_stroke(list, (nk_color) (col), (int) (NK_STROKE_OPEN), (float) (thickness));
		}

		public static void nk_draw_list_push_rect_uv(nk_draw_list list, nk_vec2 a, nk_vec2 c, nk_vec2 uva, nk_vec2 uvc,
			nk_color color)
		{
			void* vtx;
			nk_vec2 uvb = new nk_vec2();
			nk_vec2 uvd = new nk_vec2();
			nk_vec2 b = new nk_vec2();
			nk_vec2 d = new nk_vec2();
			nk_colorf col = new nk_colorf();
			ushort* idx;
			ushort index;
			if (list == null) return;
			nk_color_fv(&col.r, (nk_color) (color));
			uvb = (nk_vec2) (nk_vec2_((float) (uvc.x), (float) (uva.y)));
			uvd = (nk_vec2) (nk_vec2_((float) (uva.x), (float) (uvc.y)));
			b = (nk_vec2) (nk_vec2_((float) (c.x), (float) (a.y)));
			d = (nk_vec2) (nk_vec2_((float) (a.x), (float) (c.y)));
			index = ((ushort) (list.vertex_count));
			vtx = nk_draw_list_alloc_vertices(list, (ulong) (4));
			idx = nk_draw_list_alloc_elements(list, (ulong) (6));
			if ((vtx == null) || (idx == null)) return;
			idx[0] = ((ushort) (index + 0));
			idx[1] = ((ushort) (index + 1));
			idx[2] = ((ushort) (index + 2));
			idx[3] = ((ushort) (index + 0));
			idx[4] = ((ushort) (index + 2));
			idx[5] = ((ushort) (index + 3));
			vtx = nk_draw_vertex(vtx, list.config, (nk_vec2) (a), (nk_vec2) (uva), (nk_colorf) (col));
			vtx = nk_draw_vertex(vtx, list.config, (nk_vec2) (b), (nk_vec2) (uvb), (nk_colorf) (col));
			vtx = nk_draw_vertex(vtx, list.config, (nk_vec2) (c), (nk_vec2) (uvc), (nk_colorf) (col));
			vtx = nk_draw_vertex(vtx, list.config, (nk_vec2) (d), (nk_vec2) (uvd), (nk_colorf) (col));
		}

		public static void nk_draw_list_add_image(nk_draw_list list, nk_image texture, nk_rect rect, nk_color color)
		{
			if (list == null) return;
			nk_draw_list_push_image(list, (nk_handle) (texture.handle));
			if ((nk_image_is_subimage(texture)) != 0)
			{
				nk_vec2* uv = stackalloc nk_vec2[2];
				uv[0].x = (float) ((float) (texture.region[0])/(float) (texture.w));
				uv[0].y = (float) ((float) (texture.region[1])/(float) (texture.h));
				uv[1].x = (float) ((float) (texture.region[0] + texture.region[2])/(float) (texture.w));
				uv[1].y = (float) ((float) (texture.region[1] + texture.region[3])/(float) (texture.h));
				nk_draw_list_push_rect_uv(list, (nk_vec2) (nk_vec2_((float) (rect.x), (float) (rect.y))),
					(nk_vec2) (nk_vec2_((float) (rect.x + rect.w), (float) (rect.y + rect.h))), (nk_vec2) (uv[0]), (nk_vec2) (uv[1]),
					(nk_color) (color));
			}
			else
				nk_draw_list_push_rect_uv(list, (nk_vec2) (nk_vec2_((float) (rect.x), (float) (rect.y))),
					(nk_vec2) (nk_vec2_((float) (rect.x + rect.w), (float) (rect.y + rect.h))),
					(nk_vec2) (nk_vec2_((float) (0.0f), (float) (0.0f))), (nk_vec2) (nk_vec2_((float) (1.0f), (float) (1.0f))),
					(nk_color) (color));
		}

		public static void nk_draw_list_add_text(nk_draw_list list, nk_user_font font, nk_rect rect, char* text, int len,
			float font_height, nk_color fg)
		{
			float x = (float) (0);
			int text_len = (int) (0);
			char unicode = (char) 0;
			char next = (char) (0);
			int glyph_len = (int) (0);
			int next_glyph_len = (int) (0);
			nk_user_font_glyph g = new nk_user_font_glyph();
			if (((list == null) || (len == 0)) || (text == null)) return;
			if (
				!(!(((((list.clip_rect.x) > (rect.x + rect.w)) || ((list.clip_rect.x + list.clip_rect.w) < (rect.x))) ||
				     ((list.clip_rect.y) > (rect.y + rect.h))) || ((list.clip_rect.y + list.clip_rect.h) < (rect.y))))) return;
			nk_draw_list_push_image(list, (nk_handle) (font.texture));
			x = (float) (rect.x);
			glyph_len = (int) (nk_utf_decode(text, &unicode, (int) (len)));
			if (glyph_len == 0) return;
			fg.a = ((byte) ((float) (fg.a)*list.config.global_alpha));
			while (((text_len) < (len)) && ((glyph_len) != 0))
			{
				float gx;
				float gy;
				float gh;
				float gw;
				float char_width = (float) (0);
				if ((unicode) == (0xFFFD)) break;
				next_glyph_len = (int) (nk_utf_decode(text + text_len + glyph_len, &next, (int) (len - text_len)));
				font.query((nk_handle) (font.userdata), (float) (font_height), &g, unicode, (next == 0xFFFD) ? '\0' : next);
				gx = (float) (x + g.offset.x);
				gy = (float) (rect.y + g.offset.y);
				gw = (float) (g.width);
				gh = (float) (g.height);
				char_width = (float) (g.xadvance);
				nk_draw_list_push_rect_uv(list, (nk_vec2) (nk_vec2_((float) (gx), (float) (gy))),
					(nk_vec2) (nk_vec2_((float) (gx + gw), (float) (gy + gh))), nk_vec2_(g.uv_x[0], g.uv_y[0]),
					nk_vec2_(g.uv_x[1], g.uv_y[1]), (nk_color) (fg));
				text_len += (int) (glyph_len);
				x += (float) (char_width);
				glyph_len = (int) (next_glyph_len);
				unicode = (char) (next);
			}
		}

		public static uint nk_convert(nk_context ctx, nk_buffer cmds, nk_buffer vertices, nk_buffer elements,
			nk_convert_config config)
		{
			uint res = (uint) (NK_CONVERT_SUCCESS);

			if ((((((ctx == null) || (cmds == null)) || (vertices == null)) || (elements == null)) || (config == null)) ||
			    (config.vertex_layout == null)) return (uint) (NK_CONVERT_INVALID_PARAM);
			nk_draw_list_setup(ctx.draw_list, config, cmds, vertices, elements, (int) (config.line_AA), (int) (config.shape_AA));
			var top_window = nk__begin(ctx);
			foreach (var cmd in top_window.buffer.commands)
			{
				ctx.draw_list.userdata = (nk_handle) (cmd.userdata);
				switch (cmd.header.type)
				{
					case NK_COMMAND_NOP:
						break;
					case NK_COMMAND_SCISSOR:
					{
						nk_command_scissor s = (nk_command_scissor) (cmd);
						nk_draw_list_add_clip(ctx.draw_list,
							(nk_rect) (nk_rect_((float) (s.x), (float) (s.y), (float) (s.w), (float) (s.h))));
					}
						break;
					case NK_COMMAND_LINE:
					{
						nk_command_line l = (nk_command_line) (cmd);
						nk_draw_list_stroke_line(ctx.draw_list, (nk_vec2) (nk_vec2_((float) (l.begin.x), (float) (l.begin.y))),
							(nk_vec2) (nk_vec2_((float) (l.end.x), (float) (l.end.y))), (nk_color) (l.color), (float) (l.line_thickness));
					}
						break;
					case NK_COMMAND_CURVE:
					{
						nk_command_curve q = (nk_command_curve) (cmd);
						nk_draw_list_stroke_curve(ctx.draw_list, (nk_vec2) (nk_vec2_((float) (q.begin.x), (float) (q.begin.y))),
							(nk_vec2) (nk_vec2_((float) (q.ctrl_0.x), (float) (q.ctrl_0.y))),
							(nk_vec2) (nk_vec2_((float) (q.ctrl_1.x), (float) (q.ctrl_1.y))),
							(nk_vec2) (nk_vec2_((float) (q.end.x), (float) (q.end.y))), (nk_color) (q.color),
							(uint) (config.curve_segment_count), (float) (q.line_thickness));
					}
						break;
					case NK_COMMAND_RECT:
					{
						nk_command_rect r = (nk_command_rect) (cmd);
						nk_draw_list_stroke_rect(ctx.draw_list,
							(nk_rect) (nk_rect_((float) (r.x), (float) (r.y), (float) (r.w), (float) (r.h))), (nk_color) (r.color),
							(float) (r.rounding), (float) (r.line_thickness));
					}
						break;
					case NK_COMMAND_RECT_FILLED:
					{
						nk_command_rect_filled r = (nk_command_rect_filled) (cmd);
						nk_draw_list_fill_rect(ctx.draw_list,
							(nk_rect) (nk_rect_((float) (r.x), (float) (r.y), (float) (r.w), (float) (r.h))), (nk_color) (r.color),
							(float) (r.rounding));
					}
						break;
					case NK_COMMAND_RECT_MULTI_COLOR:
					{
						nk_command_rect_multi_color r = (nk_command_rect_multi_color) (cmd);
						nk_draw_list_fill_rect_multi_color(ctx.draw_list,
							(nk_rect) (nk_rect_((float) (r.x), (float) (r.y), (float) (r.w), (float) (r.h))), (nk_color) (r.left),
							(nk_color) (r.top), (nk_color) (r.right), (nk_color) (r.bottom));
					}
						break;
					case NK_COMMAND_CIRCLE:
					{
						nk_command_circle c = (nk_command_circle) (cmd);
						nk_draw_list_stroke_circle(ctx.draw_list,
							(nk_vec2) (nk_vec2_((float) ((float) (c.x) + (float) (c.w)/2), (float) ((float) (c.y) + (float) (c.h)/2))),
							(float) ((float) (c.w)/2), (nk_color) (c.color), (uint) (config.circle_segment_count), (float) (c.line_thickness));
					}
						break;
					case NK_COMMAND_CIRCLE_FILLED:
					{
						nk_command_circle_filled c = (nk_command_circle_filled) (cmd);
						nk_draw_list_fill_circle(ctx.draw_list,
							(nk_vec2) (nk_vec2_((float) ((float) (c.x) + (float) (c.w)/2), (float) ((float) (c.y) + (float) (c.h)/2))),
							(float) ((float) (c.w)/2), (nk_color) (c.color), (uint) (config.circle_segment_count));
					}
						break;
					case NK_COMMAND_ARC:
					{
						nk_command_arc c = (nk_command_arc) (cmd);
						nk_draw_list_path_line_to(ctx.draw_list, (nk_vec2) (nk_vec2_((float) (c.cx), (float) (c.cy))));
						nk_draw_list_path_arc_to(ctx.draw_list, (nk_vec2) (nk_vec2_((float) (c.cx), (float) (c.cy))), (float) (c.r),
							(float) (c.a[0]), (float) (c.a[1]), (uint) (config.arc_segment_count));
						nk_draw_list_path_stroke(ctx.draw_list, (nk_color) (c.color), (int) (NK_STROKE_CLOSED), (float) (c.line_thickness));
					}
						break;
					case NK_COMMAND_ARC_FILLED:
					{
						nk_command_arc_filled c = (nk_command_arc_filled) (cmd);
						nk_draw_list_path_line_to(ctx.draw_list, (nk_vec2) (nk_vec2_((float) (c.cx), (float) (c.cy))));
						nk_draw_list_path_arc_to(ctx.draw_list, (nk_vec2) (nk_vec2_((float) (c.cx), (float) (c.cy))), (float) (c.r),
							(float) (c.a[0]), (float) (c.a[1]), (uint) (config.arc_segment_count));
						nk_draw_list_path_fill(ctx.draw_list, (nk_color) (c.color));
					}
						break;
					case NK_COMMAND_TRIANGLE:
					{
						nk_command_triangle t = (nk_command_triangle) (cmd);
						nk_draw_list_stroke_triangle(ctx.draw_list, (nk_vec2) (nk_vec2_((float) (t.a.x), (float) (t.a.y))),
							(nk_vec2) (nk_vec2_((float) (t.b.x), (float) (t.b.y))), (nk_vec2) (nk_vec2_((float) (t.c.x), (float) (t.c.y))),
							(nk_color) (t.color), (float) (t.line_thickness));
					}
						break;
					case NK_COMMAND_TRIANGLE_FILLED:
					{
						nk_command_triangle_filled t = (nk_command_triangle_filled) (cmd);
						nk_draw_list_fill_triangle(ctx.draw_list, (nk_vec2) (nk_vec2_((float) (t.a.x), (float) (t.a.y))),
							(nk_vec2) (nk_vec2_((float) (t.b.x), (float) (t.b.y))), (nk_vec2) (nk_vec2_((float) (t.c.x), (float) (t.c.y))),
							(nk_color) (t.color));
					}
						break;
					case NK_COMMAND_POLYGON:
					{
						int i;
						nk_command_polygon p = (nk_command_polygon) (cmd);
						for (i = (int) (0); (i) < (p.point_count); ++i)
						{
							nk_vec2 pnt = (nk_vec2) (nk_vec2_((float) (p.points[i].x), (float) (p.points[i].y)));
							nk_draw_list_path_line_to(ctx.draw_list, (nk_vec2) (pnt));
						}
						nk_draw_list_path_stroke(ctx.draw_list, (nk_color) (p.color), (int) (NK_STROKE_CLOSED), (float) (p.line_thickness));
					}
						break;
					case NK_COMMAND_POLYGON_FILLED:
					{
						int i;
						nk_command_polygon_filled p = (nk_command_polygon_filled) (cmd);
						for (i = (int) (0); (i) < (p.point_count); ++i)
						{
							nk_vec2 pnt = (nk_vec2) (nk_vec2_((float) (p.points[i].x), (float) (p.points[i].y)));
							nk_draw_list_path_line_to(ctx.draw_list, (nk_vec2) (pnt));
						}
						nk_draw_list_path_fill(ctx.draw_list, (nk_color) (p.color));
					}
						break;
					case NK_COMMAND_POLYLINE:
					{
						int i;
						nk_command_polyline p = (nk_command_polyline) (cmd);
						for (i = (int) (0); (i) < (p.point_count); ++i)
						{
							nk_vec2 pnt = (nk_vec2) (nk_vec2_((float) (p.points[i].x), (float) (p.points[i].y)));
							nk_draw_list_path_line_to(ctx.draw_list, (nk_vec2) (pnt));
						}
						nk_draw_list_path_stroke(ctx.draw_list, (nk_color) (p.color), (int) (NK_STROKE_OPEN), (float) (p.line_thickness));
					}
						break;
					case NK_COMMAND_TEXT:
					{
						nk_command_text t = (nk_command_text) (cmd);
						nk_draw_list_add_text(ctx.draw_list, t.font,
							(nk_rect) (nk_rect_((float) (t.x), (float) (t.y), (float) (t.w), (float) (t.h))), t._string_, (int) (t.length),
							(float) (t.height), (nk_color) (t.foreground));
					}
						break;
					case NK_COMMAND_IMAGE:
					{
						nk_command_image i = (nk_command_image) (cmd);
						nk_draw_list_add_image(ctx.draw_list, (nk_image) (i.img),
							(nk_rect) (nk_rect_((float) (i.x), (float) (i.y), (float) (i.w), (float) (i.h))), (nk_color) (i.col));
					}
						break;
					case NK_COMMAND_CUSTOM:
					{
						nk_command_custom c = (nk_command_custom) (cmd);
						c.callback(ctx.draw_list, (short) (c.x), (short) (c.y), (ushort) (c.w), (ushort) (c.h),
							(nk_handle) (c.callback_data));
					}
						break;
					default:
						break;
				}
			}
			res |=
				(uint) (((cmds.needed) > (cmds.allocated + (cmds.memory.size - cmds.size))) ? NK_CONVERT_COMMAND_BUFFER_FULL : 0);
			res |= (uint) (((vertices.needed) > (vertices.allocated)) ? NK_CONVERT_VERTEX_BUFFER_FULL : 0);
			res |= (uint) (((elements.needed) > (elements.allocated)) ? NK_CONVERT_ELEMENT_BUFFER_FULL : 0);
			return (uint) (res);
		}

		public static nk_draw_command* nk__draw_begin(nk_context ctx, nk_buffer buffer)
		{
			return nk__draw_list_begin(ctx.draw_list, buffer);
		}

		public static nk_draw_command* nk__draw_end(nk_context ctx, nk_buffer buffer)
		{
			return nk__draw_list_end(ctx.draw_list, buffer);
		}

		public static nk_draw_command* nk__draw_next(nk_draw_command* cmd, nk_buffer buffer, nk_context ctx)
		{
			return nk__draw_list_next(cmd, buffer, ctx.draw_list);
		}

		public static void nk_rp_setup_allow_out_of_mem(nk_rp_context* context, int allow_out_of_mem)
		{
			if ((allow_out_of_mem) != 0) context->align = (int) (1);
			else
			{
				context->align = (int) ((context->width + context->num_nodes - 1)/context->num_nodes);
			}

		}

		public static void nk_rp_init_target(nk_rp_context* context, int width, int height, nk_rp_node* nodes, int num_nodes)
		{
			int i;
			for (i = (int) (0); (i) < (num_nodes - 1); ++i)
			{
				nodes[i].next = &nodes[i + 1];
			}
			nodes[i].next = null;
			context->init_mode = (int) (NK_RP__INIT_skyline);
			context->heuristic = (int) (NK_RP_HEURISTIC_Skyline_default);
			context->free_head = &nodes[0];
			context->active_head = &context->extra_0;
			context->width = (int) (width);
			context->height = (int) (height);
			context->num_nodes = (int) (num_nodes);
			nk_rp_setup_allow_out_of_mem(context, (int) (0));
			context->extra_0.x = (ushort) (0);
			context->extra_0.y = (ushort) (0);
			context->extra_0.next = &context->extra_1;
			context->extra_1.x = ((ushort) (width));
			context->extra_1.y = (ushort) (65535);
			context->extra_1.next = null;
		}

		public static int nk_rp__skyline_find_min_y(nk_rp_context* c, nk_rp_node* first, int x0, int width, int* pwaste)
		{
			nk_rp_node* node = first;
			int x1 = (int) (x0 + width);
			int min_y;
			int visited_width;
			int waste_area;
			min_y = (int) (0);
			waste_area = (int) (0);
			visited_width = (int) (0);
			while ((node->x) < (x1))
			{
				if ((node->y) > (min_y))
				{
					waste_area += (int) (visited_width*(node->y - min_y));
					min_y = (int) (node->y);
					if ((node->x) < (x0)) visited_width += (int) (node->next->x - x0);
					else visited_width += (int) (node->next->x - node->x);
				}
				else
				{
					int under_width = (int) (node->next->x - node->x);
					if ((under_width + visited_width) > (width)) under_width = (int) (width - visited_width);
					waste_area += (int) (under_width*(min_y - node->y));
					visited_width += (int) (under_width);
				}
				node = node->next;
			}
			*pwaste = (int) (waste_area);
			return (int) (min_y);
		}

		public static nk_rp__findresult nk_rp__skyline_find_best_pos(nk_rp_context* c, int width, int height)
		{
			int best_waste = (int) (1 << 30);
			int best_x;
			int best_y = (int) (1 << 30);
			nk_rp__findresult fr = new nk_rp__findresult();
			nk_rp_node** prev;
			nk_rp_node* node;
			nk_rp_node* tail;
			nk_rp_node** best = null;
			width = (int) (width + c->align - 1);
			width -= (int) (width%c->align);
			node = c->active_head;
			prev = &c->active_head;
			while (node->x + width <= c->width)
			{
				int y;
				int waste;
				y = (int) (nk_rp__skyline_find_min_y(c, node, (int) (node->x), (int) (width), &waste));
				if ((c->heuristic) == (NK_RP_HEURISTIC_Skyline_BL_sortHeight))
				{
					if ((y) < (best_y))
					{
						best_y = (int) (y);
						best = prev;
					}
				}
				else
				{
					if (y + height <= c->height)
					{
						if (((y) < (best_y)) || (((y) == (best_y)) && ((waste) < (best_waste))))
						{
							best_y = (int) (y);
							best_waste = (int) (waste);
							best = prev;
						}
					}
				}
				prev = &node->next;
				node = node->next;
			}
			best_x = (int) (((best) == (null)) ? 0 : (*best)->x);
			if ((c->heuristic) == (NK_RP_HEURISTIC_Skyline_BF_sortHeight))
			{
				tail = c->active_head;
				node = c->active_head;
				prev = &c->active_head;
				while ((tail->x) < (width))
				{
					tail = tail->next;
				}
				while ((tail) != null)
				{
					int xpos = (int) (tail->x - width);
					int y;
					int waste;
					while (node->next->x <= xpos)
					{
						prev = &node->next;
						node = node->next;
					}
					y = (int) (nk_rp__skyline_find_min_y(c, node, (int) (xpos), (int) (width), &waste));
					if ((y + height) < (c->height))
					{
						if (y <= best_y)
						{
							if ((((y) < (best_y)) || ((waste) < (best_waste))) || (((waste) == (best_waste)) && ((xpos) < (best_x))))
							{
								best_x = (int) (xpos);
								best_y = (int) (y);
								best_waste = (int) (waste);
								best = prev;
							}
						}
					}
					tail = tail->next;
				}
			}

			fr.prev_link = best;
			fr.x = (int) (best_x);
			fr.y = (int) (best_y);
			return (nk_rp__findresult) (fr);
		}

		public static nk_rp__findresult nk_rp__skyline_pack_rectangle(nk_rp_context* context, int width, int height)
		{
			nk_rp__findresult res = (nk_rp__findresult) (nk_rp__skyline_find_best_pos(context, (int) (width), (int) (height)));
			nk_rp_node* node;
			nk_rp_node* cur;
			if ((((res.prev_link) == (null)) || ((res.y + height) > (context->height))) || ((context->free_head) == (null)))
			{
				res.prev_link = null;
				return (nk_rp__findresult) (res);
			}

			node = context->free_head;
			node->x = ((ushort) (res.x));
			node->y = ((ushort) (res.y + height));
			context->free_head = node->next;
			cur = *res.prev_link;
			if ((cur->x) < (res.x))
			{
				nk_rp_node* next = cur->next;
				cur->next = node;
				cur = next;
			}
			else
			{
				*res.prev_link = node;
			}

			while (((cur->next) != null) && (cur->next->x <= res.x + width))
			{
				nk_rp_node* next = cur->next;
				cur->next = context->free_head;
				context->free_head = cur;
				cur = next;
			}
			node->next = cur;
			if ((cur->x) < (res.x + width)) cur->x = ((ushort) (res.x + width));
			return (nk_rp__findresult) (res);
		}

		public static int nk_rect_height_compare(void* a, void* b)
		{
			nk_rp_rect* p = (nk_rp_rect*) (a);
			nk_rp_rect* q = (nk_rp_rect*) (b);
			if ((p->h) > (q->h)) return (int) (-1);
			if ((p->h) < (q->h)) return (int) (1);
			return (int) (((p->w) > (q->w)) ? -1 : ((p->w) < (q->w)) ? 1 : 0);
		}

		public static int nk_rect_original_order(void* a, void* b)
		{
			nk_rp_rect* p = (nk_rp_rect*) (a);
			nk_rp_rect* q = (nk_rp_rect*) (b);
			return (int) (((p->was_packed) < (q->was_packed)) ? -1 : ((p->was_packed) > (q->was_packed)) ? 1 : 0);
		}

		public static void nk_rp_qsort(nk_rp_rect* array, uint len, QSortComparer cmp)
		{
			uint right;
			uint left = (uint) (0);
			uint* stack = stackalloc uint[64];
			uint pos = (uint) (0);
			uint seed = (uint) (len/2*69069 + 1);
			for (;;)
			{
				for (; (left + 1) < (len); len++)
				{
					nk_rp_rect pivot = new nk_rp_rect();
					nk_rp_rect tmp = new nk_rp_rect();
					if ((pos) == (64)) len = (uint) (stack[pos = (uint) (0)]);
					pivot = (nk_rp_rect) (array[left + seed%(len - left)]);
					seed = (uint) (seed*69069 + 1);
					stack[pos++] = (uint) (len);
					for (right = (uint) (left - 1);;)
					{
						while ((cmp(&array[++right], &pivot)) < (0))
						{
						}
						while ((cmp(&pivot, &array[--len])) < (0))
						{
						}
						if ((right) >= (len)) break;
						tmp = (nk_rp_rect) (array[right]);
						array[right] = (nk_rp_rect) (array[len]);
						array[len] = (nk_rp_rect) (tmp);
					}
				}
				if ((pos) == (0)) break;
				left = (uint) (len);
				len = (uint) (stack[--pos]);
			}
		}

		public static void nk_rp_pack_rects(nk_rp_context* context, nk_rp_rect* rects, int num_rects)
		{
			int i;
			for (i = (int) (0); (i) < (num_rects); ++i)
			{
				rects[i].was_packed = (int) (i);
			}
			nk_rp_qsort(rects, (uint) (num_rects), nk_rect_height_compare);
			for (i = (int) (0); (i) < (num_rects); ++i)
			{
				nk_rp__findresult fr =
					(nk_rp__findresult) (nk_rp__skyline_pack_rectangle(context, (int) (rects[i].w), (int) (rects[i].h)));
				if ((fr.prev_link) != null)
				{
					rects[i].x = ((ushort) (fr.x));
					rects[i].y = ((ushort) (fr.y));
				}
				else
				{
					rects[i].x = (ushort) (rects[i].y = (ushort) (0xffff));
				}
			}
			nk_rp_qsort(rects, (uint) (num_rects), nk_rect_original_order);
			for (i = (int) (0); (i) < (num_rects); ++i)
			{
				rects[i].was_packed = (int) ((((rects[i].x) == (0xffff)) && ((rects[i].y) == (0xffff))) ? 0 : 1);
			}
		}

		public static ushort nk_ttUSHORT(byte* p)
		{
			return (ushort) (p[0]*256 + p[1]);
		}

		public static short nk_ttSHORT(byte* p)
		{
			return (short) (p[0]*256 + p[1]);
		}

		public static uint nk_ttULONG(byte* p)
		{
			return (uint) ((p[0] << 24) + (p[1] << 16) + (p[2] << 8) + p[3]);
		}

		public static uint nk_tt__find_table(byte* data, uint fontstart, string tag)
		{
			int num_tables = (int) (nk_ttUSHORT(data + fontstart + 4));
			uint tabledir = (uint) (fontstart + 12);
			int i;
			for (i = (int) (0); (i) < (num_tables); ++i)
			{
				uint loc = (uint) (tabledir + (uint) (16*i));
				if (((((((data + loc + 0)[0]) == (tag[0])) && (((data + loc + 0)[1]) == (tag[1]))) &&
				      (((data + loc + 0)[2]) == (tag[2]))) && (((data + loc + 0)[3]) == (tag[3]))))
					return (uint) (nk_ttULONG(data + loc + 8));
			}
			return (uint) (0);
		}

		public static int nk_tt_InitFont(nk_tt_fontinfo* info, byte* data2, int fontstart)
		{
			uint cmap;
			uint t;
			int i;
			int numTables;
			byte* data = data2;
			info->data = data;
			info->fontstart = (int) (fontstart);
			cmap = (uint) (nk_tt__find_table(data, (uint) (fontstart), "cmap"));
			info->loca = ((int) (nk_tt__find_table(data, (uint) (fontstart), "loca")));
			info->head = ((int) (nk_tt__find_table(data, (uint) (fontstart), "head")));
			info->glyf = ((int) (nk_tt__find_table(data, (uint) (fontstart), "glyf")));
			info->hhea = ((int) (nk_tt__find_table(data, (uint) (fontstart), "hhea")));
			info->hmtx = ((int) (nk_tt__find_table(data, (uint) (fontstart), "hmtx")));
			info->kern = ((int) (nk_tt__find_table(data, (uint) (fontstart), "kern")));
			if ((((((cmap == 0) || (info->loca == 0)) || (info->head == 0)) || (info->glyf == 0)) || (info->hhea == 0)) ||
			    (info->hmtx == 0)) return (int) (0);
			t = (uint) (nk_tt__find_table(data, (uint) (fontstart), "maxp"));
			if ((t) != 0) info->numGlyphs = (int) (nk_ttUSHORT(data + t + 4));
			else info->numGlyphs = (int) (0xffff);
			numTables = (int) (nk_ttUSHORT(data + cmap + 2));
			info->index_map = (int) (0);
			for (i = (int) (0); (i) < (numTables); ++i)
			{
				uint encoding_record = (uint) (cmap + 4 + 8*(uint) (i));
				switch (nk_ttUSHORT(data + encoding_record))
				{
					case NK_TT_PLATFORM_ID_MICROSOFT:
						switch (nk_ttUSHORT(data + encoding_record + 2))
						{
							case NK_TT_MS_EID_UNICODE_BMP:
							case NK_TT_MS_EID_UNICODE_FULL:
								info->index_map = ((int) (cmap + nk_ttULONG(data + encoding_record + 4)));
								break;
							default:
								break;
						}
						break;
					case NK_TT_PLATFORM_ID_UNICODE:
						info->index_map = ((int) (cmap + nk_ttULONG(data + encoding_record + 4)));
						break;
					default:
						break;
				}
			}
			if ((info->index_map) == (0)) return (int) (0);
			info->indexToLocFormat = (int) (nk_ttUSHORT(data + info->head + 50));
			return (int) (1);
		}

		public static int nk_tt_FindGlyphIndex(nk_tt_fontinfo* info, int unicode_codepoint)
		{
			byte* data = info->data;
			uint index_map = (uint) (info->index_map);
			ushort format = (ushort) (nk_ttUSHORT(data + index_map + 0));
			if ((format) == (0))
			{
				int bytes = (int) (nk_ttUSHORT(data + index_map + 2));
				if ((unicode_codepoint) < (bytes - 6)) return (int) (*(data + index_map + 6 + unicode_codepoint));
				return (int) (0);
			}
			else if ((format) == (6))
			{
				uint first = (uint) (nk_ttUSHORT(data + index_map + 6));
				uint count = (uint) (nk_ttUSHORT(data + index_map + 8));
				if ((((uint) (unicode_codepoint)) >= (first)) && (((uint) (unicode_codepoint)) < (first + count)))
					return (int) (nk_ttUSHORT(data + index_map + 10 + (unicode_codepoint - (int) (first))*2));
				return (int) (0);
			}
			else if ((format) == (2))
			{
				return (int) (0);
			}
			else if ((format) == (4))
			{
				ushort segcount = (ushort) (nk_ttUSHORT(data + index_map + 6) >> 1);
				ushort searchRange = (ushort) (nk_ttUSHORT(data + index_map + 8) >> 1);
				ushort entrySelector = (ushort) (nk_ttUSHORT(data + index_map + 10));
				ushort rangeShift = (ushort) (nk_ttUSHORT(data + index_map + 12) >> 1);
				uint endCount = (uint) (index_map + 14);
				uint search = (uint) (endCount);
				if ((unicode_codepoint) > (0xffff)) return (int) (0);
				if ((unicode_codepoint) >= (nk_ttUSHORT(data + search + rangeShift*2))) search += ((uint) (rangeShift*2));
				search -= (uint) (2);
				while ((entrySelector) != 0)
				{
					ushort end;
					searchRange >>= 1;
					end = (ushort) (nk_ttUSHORT(data + search + searchRange*2));
					if ((unicode_codepoint) > (end)) search += ((uint) (searchRange*2));
					--entrySelector;
				}
				search += (uint) (2);
				{
					ushort offset;
					ushort start;
					ushort item = (ushort) ((search - endCount) >> 1);
					start = (ushort) (nk_ttUSHORT(data + index_map + 14 + segcount*2 + 2 + 2*item));
					if ((unicode_codepoint) < (start)) return (int) (0);
					offset = (ushort) (nk_ttUSHORT(data + index_map + 14 + segcount*6 + 2 + 2*item));
					if ((offset) == (0))
						return (int) ((ushort) (unicode_codepoint + nk_ttSHORT(data + index_map + 14 + segcount*4 + 2 + 2*item)));
					return
						(int) (nk_ttUSHORT(data + offset + (unicode_codepoint - start)*2 + index_map + 14 + segcount*6 + 2 + 2*item));
				}
			}
			else if (((format) == (12)) || ((format) == (13)))
			{
				uint ngroups = (uint) (nk_ttULONG(data + index_map + 12));
				int low;
				int high;
				low = (int) (0);
				high = ((int) (ngroups));
				while ((low) < (high))
				{
					int mid = (int) (low + ((high - low) >> 1));
					uint start_char = (uint) (nk_ttULONG(data + index_map + 16 + mid*12));
					uint end_char = (uint) (nk_ttULONG(data + index_map + 16 + mid*12 + 4));
					if (((uint) (unicode_codepoint)) < (start_char)) high = (int) (mid);
					else if (((uint) (unicode_codepoint)) > (end_char)) low = (int) (mid + 1);
					else
					{
						uint start_glyph = (uint) (nk_ttULONG(data + index_map + 16 + mid*12 + 8));
						if ((format) == (12)) return (int) ((int) (start_glyph) + unicode_codepoint - (int) (start_char));
						else return (int) (start_glyph);
					}
				}
				return (int) (0);
			}

			return (int) (0);
		}

		public static void nk_tt_setvertex(nk_tt_vertex* v, byte type, int x, int y, int cx, int cy)
		{
			v->type = (byte) (type);
			v->x = ((short) (x));
			v->y = ((short) (y));
			v->cx = ((short) (cx));
			v->cy = ((short) (cy));
		}

		public static int nk_tt__GetGlyfOffset(nk_tt_fontinfo* info, int glyph_index)
		{
			int g1;
			int g2;
			if ((glyph_index) >= (info->numGlyphs)) return (int) (-1);
			if ((info->indexToLocFormat) >= (2)) return (int) (-1);
			if ((info->indexToLocFormat) == (0))
			{
				g1 = (int) (info->glyf + nk_ttUSHORT(info->data + info->loca + glyph_index*2)*2);
				g2 = (int) (info->glyf + nk_ttUSHORT(info->data + info->loca + glyph_index*2 + 2)*2);
			}
			else
			{
				g1 = (int) (info->glyf + (int) (nk_ttULONG(info->data + info->loca + glyph_index*4)));
				g2 = (int) (info->glyf + (int) (nk_ttULONG(info->data + info->loca + glyph_index*4 + 4)));
			}

			return (int) ((g1) == (g2) ? -1 : g1);
		}

		public static int nk_tt_GetGlyphBox(nk_tt_fontinfo* info, int glyph_index, int* x0, int* y0, int* x1, int* y1)
		{
			int g = (int) (nk_tt__GetGlyfOffset(info, (int) (glyph_index)));
			if ((g) < (0)) return (int) (0);
			if ((x0) != null) *x0 = (int) (nk_ttSHORT(info->data + g + 2));
			if ((y0) != null) *y0 = (int) (nk_ttSHORT(info->data + g + 4));
			if ((x1) != null) *x1 = (int) (nk_ttSHORT(info->data + g + 6));
			if ((y1) != null) *y1 = (int) (nk_ttSHORT(info->data + g + 8));
			return (int) (1);
		}

		public static int stbtt__close_shape(nk_tt_vertex* vertices, int num_vertices, int was_off, int start_off, int sx,
			int sy, int scx, int scy, int cx, int cy)
		{
			if ((start_off) != 0)
			{
				if ((was_off) != 0)
					nk_tt_setvertex(&vertices[num_vertices++], (byte) (NK_TT_vcurve), (int) ((cx + scx) >> 1), (int) ((cy + scy) >> 1),
						(int) (cx), (int) (cy));
				nk_tt_setvertex(&vertices[num_vertices++], (byte) (NK_TT_vcurve), (int) (sx), (int) (sy), (int) (scx), (int) (scy));
			}
			else
			{
				if ((was_off) != 0)
					nk_tt_setvertex(&vertices[num_vertices++], (byte) (NK_TT_vcurve), (int) (sx), (int) (sy), (int) (cx), (int) (cy));
				else nk_tt_setvertex(&vertices[num_vertices++], (byte) (NK_TT_vline), (int) (sx), (int) (sy), (int) (0), (int) (0));
			}

			return (int) (num_vertices);
		}

		public static int nk_tt_GetGlyphShape(nk_tt_fontinfo* info, int glyph_index, nk_tt_vertex** pvertices)
		{
			short numberOfContours;
			byte* endPtsOfContours;
			byte* data = info->data;
			nk_tt_vertex* vertices = null;
			int num_vertices = (int) (0);
			int g = (int) (nk_tt__GetGlyfOffset(info, (int) (glyph_index)));
			*pvertices = null;
			if ((g) < (0)) return (int) (0);
			numberOfContours = (short) (nk_ttSHORT(data + g));
			if ((numberOfContours) > (0))
			{
				byte flags = (byte) (0);
				byte flagcount;
				int ins;
				int i;
				int j = (int) (0);
				int m;
				int n;
				int next_move;
				int was_off = (int) (0);
				int off;
				int start_off = (int) (0);
				int x;
				int y;
				int cx;
				int cy;
				int sx;
				int sy;
				int scx;
				int scy;
				byte* points;
				endPtsOfContours = (data + g + 10);
				ins = (int) (nk_ttUSHORT(data + g + 10 + numberOfContours*2));
				points = data + g + 10 + numberOfContours*2 + 2 + ins;
				n = (int) (1 + nk_ttUSHORT(endPtsOfContours + numberOfContours*2 - 2));
				m = (int) (n + 2*numberOfContours);
				vertices = (nk_tt_vertex*) (CRuntime.malloc((ulong) ((ulong) (m)*(ulong) sizeof (nk_tt_vertex))));
				if ((vertices) == (null)) return (int) (0);
				next_move = (int) (0);
				flagcount = (byte) (0);
				off = (int) (m - n);
				for (i = (int) (0); (i) < (n); ++i)
				{
					if ((flagcount) == (0))
					{
						flags = (byte) (*points++);
						if ((flags & 8) != 0) flagcount = (byte) (*points++);
					}
					else --flagcount;
					vertices[off + i].type = (byte) (flags);
				}
				x = (int) (0);
				for (i = (int) (0); (i) < (n); ++i)
				{
					flags = (byte) (vertices[off + i].type);
					if ((flags & 2) != 0)
					{
						short dx = (short) (*points++);
						x += (int) ((flags & 16) != 0 ? dx : -dx);
					}
					else
					{
						if ((flags & 16) == 0)
						{
							x = (int) (x + (short) (points[0]*256 + points[1]));
							points += 2;
						}
					}
					vertices[off + i].x = ((short) (x));
				}
				y = (int) (0);
				for (i = (int) (0); (i) < (n); ++i)
				{
					flags = (byte) (vertices[off + i].type);
					if ((flags & 4) != 0)
					{
						short dy = (short) (*points++);
						y += (int) ((flags & 32) != 0 ? dy : -dy);
					}
					else
					{
						if ((flags & 32) == 0)
						{
							y = (int) (y + (short) (points[0]*256 + points[1]));
							points += 2;
						}
					}
					vertices[off + i].y = ((short) (y));
				}
				num_vertices = (int) (0);
				sx = (int) (sy = (int) (cx = (int) (cy = (int) (scx = (int) (scy = (int) (0))))));
				for (i = (int) (0); (i) < (n); ++i)
				{
					flags = (byte) (vertices[off + i].type);
					x = (int) (vertices[off + i].x);
					y = (int) (vertices[off + i].y);
					if ((next_move) == (i))
					{
						if (i != 0)
							num_vertices =
								(int)
									(stbtt__close_shape(vertices, (int) (num_vertices), (int) (was_off), (int) (start_off), (int) (sx), (int) (sy),
										(int) (scx), (int) (scy), (int) (cx), (int) (cy)));
						start_off = (int) ((flags & 1) == 0 ? 1 : 0);
						if ((start_off) != 0)
						{
							scx = (int) (x);
							scy = (int) (y);
							if ((vertices[off + i + 1].type & 1) == 0)
							{
								sx = (int) ((x + (int) (vertices[off + i + 1].x)) >> 1);
								sy = (int) ((y + (int) (vertices[off + i + 1].y)) >> 1);
							}
							else
							{
								sx = ((int) (vertices[off + i + 1].x));
								sy = ((int) (vertices[off + i + 1].y));
								++i;
							}
						}
						else
						{
							sx = (int) (x);
							sy = (int) (y);
						}
						nk_tt_setvertex(&vertices[num_vertices++], (byte) (NK_TT_vmove), (int) (sx), (int) (sy), (int) (0), (int) (0));
						was_off = (int) (0);
						next_move = (int) (1 + nk_ttUSHORT(endPtsOfContours + j*2));
						++j;
					}
					else
					{
						if ((flags & 1) == 0)
						{
							if ((was_off) != 0)
								nk_tt_setvertex(&vertices[num_vertices++], (byte) (NK_TT_vcurve), (int) ((cx + x) >> 1), (int) ((cy + y) >> 1),
									(int) (cx), (int) (cy));
							cx = (int) (x);
							cy = (int) (y);
							was_off = (int) (1);
						}
						else
						{
							if ((was_off) != 0)
								nk_tt_setvertex(&vertices[num_vertices++], (byte) (NK_TT_vcurve), (int) (x), (int) (y), (int) (cx), (int) (cy));
							else
								nk_tt_setvertex(&vertices[num_vertices++], (byte) (NK_TT_vline), (int) (x), (int) (y), (int) (0), (int) (0));
							was_off = (int) (0);
						}
					}
				}
				num_vertices =
					(int)
						(stbtt__close_shape(vertices, (int) (num_vertices), (int) (was_off), (int) (start_off), (int) (sx), (int) (sy),
							(int) (scx), (int) (scy), (int) (cx), (int) (cy)));
			}
			else if ((numberOfContours) == (-1))
			{
				int more = (int) (1);
				byte* comp = data + g + 10;
				num_vertices = (int) (0);
				vertices = null;
				while ((more) != 0)
				{
					ushort flags;
					ushort gidx;
					int comp_num_verts = (int) (0);
					int i;
					nk_tt_vertex* comp_verts = null;
					nk_tt_vertex* tmp = null;
					float* mtx = stackalloc float[6];
					mtx[0] = (float) (1);
					mtx[1] = (float) (0);
					mtx[2] = (float) (0);
					mtx[3] = (float) (1);
					mtx[4] = (float) (0);
					mtx[5] = (float) (0);
					float m;
					float n;
					flags = ((ushort) (nk_ttSHORT(comp)));
					comp += 2;
					gidx = ((ushort) (nk_ttSHORT(comp)));
					comp += 2;
					if ((flags & 2) != 0)
					{
						if ((flags & 1) != 0)
						{
							mtx[4] = (float) (nk_ttSHORT(comp));
							comp += 2;
							mtx[5] = (float) (nk_ttSHORT(comp));
							comp += 2;
						}
						else
						{
							mtx[4] = (float) (*(sbyte*) (comp));
							comp += 1;
							mtx[5] = (float) (*(sbyte*) (comp));
							comp += 1;
						}
					}
					else
					{
					}
					if ((flags & (1 << 3)) != 0)
					{
						mtx[0] = (float) (mtx[3] = (float) (nk_ttSHORT(comp)/16384.0f));
						comp += 2;
						mtx[1] = (float) (mtx[2] = (float) (0));
					}
					else if ((flags & (1 << 6)) != 0)
					{
						mtx[0] = (float) (nk_ttSHORT(comp)/16384.0f);
						comp += 2;
						mtx[1] = (float) (mtx[2] = (float) (0));
						mtx[3] = (float) (nk_ttSHORT(comp)/16384.0f);
						comp += 2;
					}
					else if ((flags & (1 << 7)) != 0)
					{
						mtx[0] = (float) (nk_ttSHORT(comp)/16384.0f);
						comp += 2;
						mtx[1] = (float) (nk_ttSHORT(comp)/16384.0f);
						comp += 2;
						mtx[2] = (float) (nk_ttSHORT(comp)/16384.0f);
						comp += 2;
						mtx[3] = (float) (nk_ttSHORT(comp)/16384.0f);
						comp += 2;
					}
					m = (float) (nk_sqrt((float) (mtx[0]*mtx[0] + mtx[1]*mtx[1])));
					n = (float) (nk_sqrt((float) (mtx[2]*mtx[2] + mtx[3]*mtx[3])));
					comp_num_verts = (int) (nk_tt_GetGlyphShape(info, (int) (gidx), &comp_verts));
					if ((comp_num_verts) > (0))
					{
						for (i = (int) (0); (i) < (comp_num_verts); ++i)
						{
							nk_tt_vertex* v = &comp_verts[i];
							short x;
							short y;
							x = (short) (v->x);
							y = (short) (v->y);
							v->x = ((short) (m*(mtx[0]*x + mtx[2]*y + mtx[4])));
							v->y = ((short) (n*(mtx[1]*x + mtx[3]*y + mtx[5])));
							x = (short) (v->cx);
							y = (short) (v->cy);
							v->cx = ((short) (m*(mtx[0]*x + mtx[2]*y + mtx[4])));
							v->cy = ((short) (n*(mtx[1]*x + mtx[3]*y + mtx[5])));
						}
						tmp =
							(nk_tt_vertex*)
								(CRuntime.malloc((ulong) ((ulong) (num_vertices + comp_num_verts)*(ulong) sizeof (nk_tt_vertex))));
						if (tmp == null)
						{
							if ((vertices) != null) CRuntime.free(vertices);
							if ((comp_verts) != null) CRuntime.free(comp_verts);
							return (int) (0);
						}
						if ((num_vertices) > (0))
							nk_memcopy(tmp, vertices, (ulong) ((ulong) (num_vertices)*(ulong) sizeof (nk_tt_vertex)));
						nk_memcopy(tmp + num_vertices, comp_verts, (ulong) ((ulong) (comp_num_verts)*(ulong) sizeof (nk_tt_vertex)));
						if ((vertices) != null) CRuntime.free(vertices);
						vertices = tmp;
						CRuntime.free(comp_verts);
						num_vertices += (int) (comp_num_verts);
					}
					more = (int) (flags & (1 << 5));
				}
			}
			else if ((numberOfContours) < (0))
			{
			}
			else
			{
			}

			*pvertices = vertices;
			return (int) (num_vertices);
		}

		public static void nk_tt_GetGlyphHMetrics(nk_tt_fontinfo* info, int glyph_index, int* advanceWidth,
			int* leftSideBearing)
		{
			ushort numOfLongHorMetrics = (ushort) (nk_ttUSHORT(info->data + info->hhea + 34));
			if ((glyph_index) < (numOfLongHorMetrics))
			{
				if ((advanceWidth) != null) *advanceWidth = (int) (nk_ttSHORT(info->data + info->hmtx + 4*glyph_index));
				if ((leftSideBearing) != null) *leftSideBearing = (int) (nk_ttSHORT(info->data + info->hmtx + 4*glyph_index + 2));
			}
			else
			{
				if ((advanceWidth) != null)
					*advanceWidth = (int) (nk_ttSHORT(info->data + info->hmtx + 4*(numOfLongHorMetrics - 1)));
				if ((leftSideBearing) != null)
					*leftSideBearing =
						(int) (nk_ttSHORT(info->data + info->hmtx + 4*numOfLongHorMetrics + 2*(glyph_index - numOfLongHorMetrics)));
			}

		}

		public static void nk_tt_GetFontVMetrics(nk_tt_fontinfo* info, int* ascent, int* descent, int* lineGap)
		{
			if ((ascent) != null) *ascent = (int) (nk_ttSHORT(info->data + info->hhea + 4));
			if ((descent) != null) *descent = (int) (nk_ttSHORT(info->data + info->hhea + 6));
			if ((lineGap) != null) *lineGap = (int) (nk_ttSHORT(info->data + info->hhea + 8));
		}

		public static float nk_tt_ScaleForPixelHeight(nk_tt_fontinfo* info, float height)
		{
			int fheight = (int) (nk_ttSHORT(info->data + info->hhea + 4) - nk_ttSHORT(info->data + info->hhea + 6));
			return (float) (height/(float) (fheight));
		}

		public static float nk_tt_ScaleForMappingEmToPixels(nk_tt_fontinfo* info, float pixels)
		{
			int unitsPerEm = (int) (nk_ttUSHORT(info->data + info->head + 18));
			return (float) (pixels/(float) (unitsPerEm));
		}

		public static void nk_tt_GetGlyphBitmapBoxSubpixel(nk_tt_fontinfo* font, int glyph, float scale_x, float scale_y,
			float shift_x, float shift_y, int* ix0, int* iy0, int* ix1, int* iy1)
		{
			int x0;
			int y0;
			int x1;
			int y1;
			if (nk_tt_GetGlyphBox(font, (int) (glyph), &x0, &y0, &x1, &y1) == 0)
			{
				if ((ix0) != null) *ix0 = (int) (0);
				if ((iy0) != null) *iy0 = (int) (0);
				if ((ix1) != null) *ix1 = (int) (0);
				if ((iy1) != null) *iy1 = (int) (0);
			}
			else
			{
				if ((ix0) != null) *ix0 = (int) (nk_ifloorf((float) ((float) (x0)*scale_x + shift_x)));
				if ((iy0) != null) *iy0 = (int) (nk_ifloorf((float) ((float) (-y1)*scale_y + shift_y)));
				if ((ix1) != null) *ix1 = (int) (nk_iceilf((float) ((float) (x1)*scale_x + shift_x)));
				if ((iy1) != null) *iy1 = (int) (nk_iceilf((float) ((float) (-y0)*scale_y + shift_y)));
			}

		}

		public static void nk_tt_GetGlyphBitmapBox(nk_tt_fontinfo* font, int glyph, float scale_x, float scale_y, int* ix0,
			int* iy0, int* ix1, int* iy1)
		{
			nk_tt_GetGlyphBitmapBoxSubpixel(font, (int) (glyph), (float) (scale_x), (float) (scale_y), (float) (0.0f),
				(float) (0.0f), ix0, iy0, ix1, iy1);
		}

		public static void* nk_tt__hheap_alloc(nk_tt__hheap* hh, ulong size)
		{
			if ((hh->first_free) != null)
			{
				void* p = hh->first_free;
				hh->first_free = *(void**) (p);
				return p;
			}
			else
			{
				if ((hh->num_remaining_in_head_chunk) == (0))
				{
					int count = (int) ((size) < (32) ? 2000 : (size) < (128) ? 800 : 100);
					nk_tt__hheap_chunk* c =
						(nk_tt__hheap_chunk*) (CRuntime.malloc((ulong) ((ulong) sizeof (nk_tt__hheap_chunk) + size*(ulong) (count))));
					if ((c) == (null)) return null;
					c->next = hh->head;
					hh->head = c;
					hh->num_remaining_in_head_chunk = (int) (count);
				}
				--hh->num_remaining_in_head_chunk;
				return (sbyte*) (hh->head) + size*(ulong) (hh->num_remaining_in_head_chunk);
			}

		}

		public static void nk_tt__hheap_free(nk_tt__hheap* hh, void* p)
		{
			*(void**) (p) = hh->first_free;
			hh->first_free = p;
		}

		public static void nk_tt__hheap_cleanup(nk_tt__hheap* hh)
		{
			nk_tt__hheap_chunk* c = hh->head;
			while ((c) != null)
			{
				nk_tt__hheap_chunk* n = c->next;
				CRuntime.free(c);
				c = n;
			}
		}

		public static nk_tt__active_edge* nk_tt__new_active(nk_tt__hheap* hh, nk_tt__edge* e, int off_x, float start_point)
		{
			nk_tt__active_edge* z = (nk_tt__active_edge*) (nk_tt__hheap_alloc(hh, (ulong) (sizeof (nk_tt__active_edge))));
			float dxdy = (float) ((e->x1 - e->x0)/(e->y1 - e->y0));
			if (z == null) return z;
			z->fdx = (float) (dxdy);
			z->fdy = (float) ((dxdy != 0) ? (1/dxdy) : 0);
			z->fx = (float) (e->x0 + dxdy*(start_point - e->y0));
			z->fx -= ((float) (off_x));
			z->direction = (float) ((e->invert) != 0 ? 1.0f : -1.0f);
			z->sy = (float) (e->y0);
			z->ey = (float) (e->y1);
			z->next = null;
			return z;
		}

		public static void nk_tt__handle_clipped_edge(float* scanline, int x, nk_tt__active_edge* e, float x0, float y0,
			float x1, float y1)
		{
			if ((y0) == (y1)) return;
			if ((y0) > (e->ey)) return;
			if ((y1) < (e->sy)) return;
			if ((y0) < (e->sy))
			{
				x0 += (float) ((x1 - x0)*(e->sy - y0)/(y1 - y0));
				y0 = (float) (e->sy);
			}

			if ((y1) > (e->ey))
			{
				x1 += (float) ((x1 - x0)*(e->ey - y1)/(y1 - y0));
				y1 = (float) (e->ey);
			}

			if ((x0 <= x) && (x1 <= x)) scanline[x] += (float) (e->direction*(y1 - y0));
			else if (((x0) >= (x + 1)) && ((x1) >= (x + 1)))
			{
			}
			else
			{
				scanline[x] += (float) (e->direction*(y1 - y0)*(1.0f - ((x0 - (float) (x)) + (x1 - (float) (x)))/2.0f));
			}

		}

		public static void nk_tt__fill_active_edges_new(float* scanline, float* scanline_fill, int len, nk_tt__active_edge* e,
			float y_top)
		{
			float y_bottom = (float) (y_top + 1);
			while ((e) != null)
			{
				if ((e->fdx) == (0))
				{
					float x0 = (float) (e->fx);
					if ((x0) < (len))
					{
						if ((x0) >= (0))
						{
							nk_tt__handle_clipped_edge(scanline, (int) (x0), e, (float) (x0), (float) (y_top), (float) (x0),
								(float) (y_bottom));
							nk_tt__handle_clipped_edge(scanline_fill - 1, (int) ((int) (x0) + 1), e, (float) (x0), (float) (y_top),
								(float) (x0), (float) (y_bottom));
						}
						else
						{
							nk_tt__handle_clipped_edge(scanline_fill - 1, (int) (0), e, (float) (x0), (float) (y_top), (float) (x0),
								(float) (y_bottom));
						}
					}
				}
				else
				{
					float x0 = (float) (e->fx);
					float dx = (float) (e->fdx);
					float xb = (float) (x0 + dx);
					float x_top;
					float x_bottom;
					float y0;
					float y1;
					float dy = (float) (e->fdy);
					if ((e->sy) > (y_top))
					{
						x_top = (float) (x0 + dx*(e->sy - y_top));
						y0 = (float) (e->sy);
					}
					else
					{
						x_top = (float) (x0);
						y0 = (float) (y_top);
					}
					if ((e->ey) < (y_bottom))
					{
						x_bottom = (float) (x0 + dx*(e->ey - y_top));
						y1 = (float) (e->ey);
					}
					else
					{
						x_bottom = (float) (xb);
						y1 = (float) (y_bottom);
					}
					if (((((x_top) >= (0)) && ((x_bottom) >= (0))) && ((x_top) < (len))) && ((x_bottom) < (len)))
					{
						if (((int) (x_top)) == ((int) (x_bottom)))
						{
							float height;
							int x = (int) (x_top);
							height = (float) (y1 - y0);
							scanline[x] += (float) (e->direction*(1.0f - ((x_top - (float) (x)) + (x_bottom - (float) (x)))/2.0f)*height);
							scanline_fill[x] += (float) (e->direction*height);
						}
						else
						{
							int x;
							int x1;
							int x2;
							float y_crossing;
							float step;
							float sign;
							float area;
							if ((x_top) > (x_bottom))
							{
								float t;
								y0 = (float) (y_bottom - (y0 - y_top));
								y1 = (float) (y_bottom - (y1 - y_top));
								t = (float) (y0);
								y0 = (float) (y1);
								y1 = (float) (t);
								t = (float) (x_bottom);
								x_bottom = (float) (x_top);
								x_top = (float) (t);
								dx = (float) (-dx);
								dy = (float) (-dy);
								t = (float) (x0);
								x0 = (float) (xb);
								xb = (float) (t);
							}
							x1 = ((int) (x_top));
							x2 = ((int) (x_bottom));
							y_crossing = (float) (((float) (x1) + 1 - x0)*dy + y_top);
							sign = (float) (e->direction);
							area = (float) (sign*(y_crossing - y0));
							scanline[x1] += (float) (area*(1.0f - ((x_top - (float) (x1)) + (float) (x1 + 1 - x1))/2.0f));
							step = (float) (sign*dy);
							for (x = (int) (x1 + 1); (x) < (x2); ++x)
							{
								scanline[x] += (float) (area + step/2);
								area += (float) (step);
							}
							y_crossing += (float) (dy*(float) (x2 - (x1 + 1)));
							scanline[x2] +=
								(float) (area + sign*(1.0f - ((float) (x2 - x2) + (x_bottom - (float) (x2)))/2.0f)*(y1 - y_crossing));
							scanline_fill[x2] += (float) (sign*(y1 - y0));
						}
					}
					else
					{
						int x;
						for (x = (int) (0); (x) < (len); ++x)
						{
							float ya = (float) (y_top);
							float x1 = (float) (x);
							float x2 = (float) (x + 1);
							float x3 = (float) (xb);
							float y3 = (float) (y_bottom);
							float yb;
							float y2;
							yb = (float) (((float) (x) - x0)/dx + y_top);
							y2 = (float) (((float) (x) + 1 - x0)/dx + y_top);
							if (((x0) < (x1)) && ((x3) > (x2)))
							{
								nk_tt__handle_clipped_edge(scanline, (int) (x), e, (float) (x0), (float) (ya), (float) (x1), (float) (yb));
								nk_tt__handle_clipped_edge(scanline, (int) (x), e, (float) (x1), (float) (yb), (float) (x2), (float) (y2));
								nk_tt__handle_clipped_edge(scanline, (int) (x), e, (float) (x2), (float) (y2), (float) (x3), (float) (y3));
							}
							else if (((x3) < (x1)) && ((x0) > (x2)))
							{
								nk_tt__handle_clipped_edge(scanline, (int) (x), e, (float) (x0), (float) (ya), (float) (x2), (float) (y2));
								nk_tt__handle_clipped_edge(scanline, (int) (x), e, (float) (x2), (float) (y2), (float) (x1), (float) (yb));
								nk_tt__handle_clipped_edge(scanline, (int) (x), e, (float) (x1), (float) (yb), (float) (x3), (float) (y3));
							}
							else if (((x0) < (x1)) && ((x3) > (x1)))
							{
								nk_tt__handle_clipped_edge(scanline, (int) (x), e, (float) (x0), (float) (ya), (float) (x1), (float) (yb));
								nk_tt__handle_clipped_edge(scanline, (int) (x), e, (float) (x1), (float) (yb), (float) (x3), (float) (y3));
							}
							else if (((x3) < (x1)) && ((x0) > (x1)))
							{
								nk_tt__handle_clipped_edge(scanline, (int) (x), e, (float) (x0), (float) (ya), (float) (x1), (float) (yb));
								nk_tt__handle_clipped_edge(scanline, (int) (x), e, (float) (x1), (float) (yb), (float) (x3), (float) (y3));
							}
							else if (((x0) < (x2)) && ((x3) > (x2)))
							{
								nk_tt__handle_clipped_edge(scanline, (int) (x), e, (float) (x0), (float) (ya), (float) (x2), (float) (y2));
								nk_tt__handle_clipped_edge(scanline, (int) (x), e, (float) (x2), (float) (y2), (float) (x3), (float) (y3));
							}
							else if (((x3) < (x2)) && ((x0) > (x2)))
							{
								nk_tt__handle_clipped_edge(scanline, (int) (x), e, (float) (x0), (float) (ya), (float) (x2), (float) (y2));
								nk_tt__handle_clipped_edge(scanline, (int) (x), e, (float) (x2), (float) (y2), (float) (x3), (float) (y3));
							}
							else
							{
								nk_tt__handle_clipped_edge(scanline, (int) (x), e, (float) (x0), (float) (ya), (float) (x3), (float) (y3));
							}
						}
					}
				}
				e = e->next;
			}
		}

		public static void nk_tt__rasterize_sorted_edges(nk_tt__bitmap* result, nk_tt__edge* e, int n, int vsubsample,
			int off_x, int off_y)
		{
			nk_tt__hheap hh = new nk_tt__hheap();
			nk_tt__active_edge* active = null;
			int y;
			int j = (int) (0);
			int i;
			float* scanline_data = stackalloc float[129];
			float* scanline;
			float* scanline2;
			nk_zero(&hh, (ulong) (sizeof (nk_tt__hheap)));

			if ((result->w) > (64)) scanline = (float*) (CRuntime.malloc((ulong) ((ulong) (result->w*2 + 1)*sizeof (float))));
			else scanline = scanline_data;
			scanline2 = scanline + result->w;
			y = (int) (off_y);
			e[n].y0 = (float) ((float) (off_y + result->h) + 1);
			while ((j) < (result->h))
			{
				float scan_y_top = (float) ((float) (y) + 0.0f);
				float scan_y_bottom = (float) ((float) (y) + 1.0f);
				nk_tt__active_edge** step = &active;
				nk_memset(scanline, (int) (0), (ulong) ((ulong) (result->w)*sizeof (float)));
				nk_memset(scanline2, (int) (0), (ulong) ((ulong) (result->w + 1)*sizeof (float)));
				while ((*step) != null)
				{
					nk_tt__active_edge* z = *step;
					if (z->ey <= scan_y_top)
					{
						*step = z->next;
						z->direction = (float) (0);
						nk_tt__hheap_free(&hh, z);
					}
					else
					{
						step = &((*step)->next);
					}
				}
				while (e->y0 <= scan_y_bottom)
				{
					if (e->y0 != e->y1)
					{
						nk_tt__active_edge* z = nk_tt__new_active(&hh, e, (int) (off_x), (float) (scan_y_top));
						if (z != null)
						{
							z->next = active;
							active = z;
						}
					}
					++e;
				}
				if ((active) != null)
					nk_tt__fill_active_edges_new(scanline, scanline2 + 1, (int) (result->w), active, (float) (scan_y_top));
				{
					float sum = (float) (0);
					for (i = (int) (0); (i) < (result->w); ++i)
					{
						float k;
						int m;
						sum += (float) (scanline2[i]);
						k = (float) (scanline[i] + sum);
						k = (float) ((((k) < (0)) ? -(k) : (k))*255.0f + 0.5f);
						m = ((int) (k));
						if ((m) > (255)) m = (int) (255);
						result->pixels[j*result->stride + i] = ((byte) (m));
					}
				}
				step = &active;
				while ((*step) != null)
				{
					nk_tt__active_edge* z = *step;
					z->fx += (float) (z->fdx);
					step = &((*step)->next);
				}
				++y;
				++j;
			}
			nk_tt__hheap_cleanup(&hh);
			if (scanline != scanline_data) CRuntime.free(scanline);
		}

		public static void nk_tt__sort_edges_ins_sort(nk_tt__edge* p, int n)
		{
			int i;
			int j;
			for (i = (int) (1); (i) < (n); ++i)
			{
				nk_tt__edge t = (nk_tt__edge) (p[i]);
				nk_tt__edge* a = &t;
				j = (int) (i);
				while ((j) > (0))
				{
					nk_tt__edge* b = &p[j - 1];
					int c = (int) (((a)->y0) < ((b)->y0) ? 1 : 0);
					if (c == 0) break;
					p[j] = (nk_tt__edge) (p[j - 1]);
					--j;
				}
				if (i != j) p[j] = (nk_tt__edge) (t);
			}
		}

		public static void nk_tt__sort_edges_quicksort(nk_tt__edge* p, int n)
		{
			while ((n) > (12))
			{
				nk_tt__edge t = new nk_tt__edge();
				int c01;
				int c12;
				int c;
				int m;
				int i;
				int j;
				m = (int) (n >> 1);
				c01 = (int) (((&p[0])->y0) < ((&p[m])->y0) ? 1 : 0);
				c12 = (int) (((&p[m])->y0) < ((&p[n - 1])->y0) ? 1 : 0);
				if (c01 != c12)
				{
					int z;
					c = (int) (((&p[0])->y0) < ((&p[n - 1])->y0) ? 1 : 0);
					z = (int) (((c) == (c12)) ? 0 : n - 1);
					t = (nk_tt__edge) (p[z]);
					p[z] = (nk_tt__edge) (p[m]);
					p[m] = (nk_tt__edge) (t);
				}
				t = (nk_tt__edge) (p[0]);
				p[0] = (nk_tt__edge) (p[m]);
				p[m] = (nk_tt__edge) (t);
				i = (int) (1);
				j = (int) (n - 1);
				for (;;)
				{
					for (;; ++i)
					{
						if (!(((&p[i])->y0) < ((&p[0])->y0))) break;
					}
					for (;; --j)
					{
						if (!(((&p[0])->y0) < ((&p[j])->y0))) break;
					}
					if ((i) >= (j)) break;
					t = (nk_tt__edge) (p[i]);
					p[i] = (nk_tt__edge) (p[j]);
					p[j] = (nk_tt__edge) (t);
					++i;
					--j;
				}
				if ((j) < (n - i))
				{
					nk_tt__sort_edges_quicksort(p, (int) (j));
					p = p + i;
					n = (int) (n - i);
				}
				else
				{
					nk_tt__sort_edges_quicksort(p + i, (int) (n - i));
					n = (int) (j);
				}
			}
		}

		public static void nk_tt__sort_edges(nk_tt__edge* p, int n)
		{
			nk_tt__sort_edges_quicksort(p, (int) (n));
			nk_tt__sort_edges_ins_sort(p, (int) (n));
		}

		public static void nk_tt__rasterize(nk_tt__bitmap* result, nk_tt__point* pts, int* wcount, int windings, float scale_x,
			float scale_y, float shift_x, float shift_y, int off_x, int off_y, int invert)
		{
			float y_scale_inv = (float) ((invert) != 0 ? -scale_y : scale_y);
			nk_tt__edge* e;
			int n;
			int i;
			int j;
			int k;
			int m;
			int vsubsample = (int) (1);
			n = (int) (0);
			for (i = (int) (0); (i) < (windings); ++i)
			{
				n += (int) (wcount[i]);
			}
			e = (nk_tt__edge*) (CRuntime.malloc((ulong) ((ulong) sizeof (nk_tt__edge)*(ulong) (n + 1))));
			if ((e) == (null)) return;
			n = (int) (0);
			m = (int) (0);
			for (i = (int) (0); (i) < (windings); ++i)
			{
				nk_tt__point* p = pts + m;
				m += (int) (wcount[i]);
				j = (int) (wcount[i] - 1);
				for (k = (int) (0); (k) < (wcount[i]); j = (int) (k++))
				{
					int a = (int) (k);
					int b = (int) (j);
					if ((p[j].y) == (p[k].y)) continue;
					e[n].invert = (int) (0);
					if (invert != 0 ? (p[j].y > p[k].y) : (p[j].y < p[k].y))
					{
						e[n].invert = (int) (1);
						a = (int) (j);
						b = (int) (k);
					}
					e[n].x0 = (float) (p[a].x*scale_x + shift_x);
					e[n].y0 = (float) ((p[a].y*y_scale_inv + shift_y)*(float) (vsubsample));
					e[n].x1 = (float) (p[b].x*scale_x + shift_x);
					e[n].y1 = (float) ((p[b].y*y_scale_inv + shift_y)*(float) (vsubsample));
					++n;
				}
			}
			nk_tt__sort_edges(e, (int) (n));
			nk_tt__rasterize_sorted_edges(result, e, (int) (n), (int) (vsubsample), (int) (off_x), (int) (off_y));
			CRuntime.free(e);
		}

		public static void nk_tt__add_point(nk_tt__point* points, int n, float x, float y)
		{
			if (points == null) return;
			points[n].x = (float) (x);
			points[n].y = (float) (y);
		}

		public static int nk_tt__tesselate_curve(nk_tt__point* points, int* num_points, float x0, float y0, float x1, float y1,
			float x2, float y2, float objspace_flatness_squared, int n)
		{
			float mx = (float) ((x0 + 2*x1 + x2)/4);
			float my = (float) ((y0 + 2*y1 + y2)/4);
			float dx = (float) ((x0 + x2)/2 - mx);
			float dy = (float) ((y0 + y2)/2 - my);
			if ((n) > (16)) return (int) (1);
			if ((dx*dx + dy*dy) > (objspace_flatness_squared))
			{
				nk_tt__tesselate_curve(points, num_points, (float) (x0), (float) (y0), (float) ((x0 + x1)/2.0f),
					(float) ((y0 + y1)/2.0f), (float) (mx), (float) (my), (float) (objspace_flatness_squared), (int) (n + 1));
				nk_tt__tesselate_curve(points, num_points, (float) (mx), (float) (my), (float) ((x1 + x2)/2.0f),
					(float) ((y1 + y2)/2.0f), (float) (x2), (float) (y2), (float) (objspace_flatness_squared), (int) (n + 1));
			}
			else
			{
				nk_tt__add_point(points, (int) (*num_points), (float) (x2), (float) (y2));
				*num_points = (int) (*num_points + 1);
			}

			return (int) (1);
		}

		public static nk_tt__point* nk_tt_FlattenCurves(nk_tt_vertex* vertices, int num_verts, float objspace_flatness,
			int** contour_lengths, int* num_contours)
		{
			nk_tt__point* points = null;
			int num_points = (int) (0);
			float objspace_flatness_squared = (float) (objspace_flatness*objspace_flatness);
			int i;
			int n = (int) (0);
			int start = (int) (0);
			int pass;
			for (i = (int) (0); (i) < (num_verts); ++i)
			{
				if ((vertices[i].type) == (NK_TT_vmove)) ++n;
			}
			*num_contours = (int) (n);
			if ((n) == (0)) return null;
			*contour_lengths = (int*) (CRuntime.malloc((ulong) ((ulong) sizeof (int)*(ulong) (n))));
			if ((*contour_lengths) == (null))
			{
				*num_contours = (int) (0);
				return null;
			}

			for (pass = (int) (0); (pass) < (2); ++pass)
			{
				float x = (float) (0);
				float y = (float) (0);
				if ((pass) == (1))
				{
					points = (nk_tt__point*) (CRuntime.malloc((ulong) ((ulong) (num_points)*(ulong) sizeof (nk_tt__point))));
					if ((points) == (null)) goto error;
				}
				num_points = (int) (0);
				n = (int) (-1);
				for (i = (int) (0); (i) < (num_verts); ++i)
				{
					switch (vertices[i].type)
					{
						case NK_TT_vmove:
							if ((n) >= (0)) (*contour_lengths)[n] = (int) (num_points - start);
							++n;
							start = (int) (num_points);
							x = (float) (vertices[i].x);
							y = (float) (vertices[i].y);
							nk_tt__add_point(points, (int) (num_points++), (float) (x), (float) (y));
							break;
						case NK_TT_vline:
							x = (float) (vertices[i].x);
							y = (float) (vertices[i].y);
							nk_tt__add_point(points, (int) (num_points++), (float) (x), (float) (y));
							break;
						case NK_TT_vcurve:
							nk_tt__tesselate_curve(points, &num_points, (float) (x), (float) (y), (float) (vertices[i].cx),
								(float) (vertices[i].cy), (float) (vertices[i].x), (float) (vertices[i].y), (float) (objspace_flatness_squared),
								(int) (0));
							x = (float) (vertices[i].x);
							y = (float) (vertices[i].y);
							break;
						default:
							break;
					}
				}
				(*contour_lengths)[n] = (int) (num_points - start);
			}
			return points;
			error:
			;
			CRuntime.free(points);
			CRuntime.free(*contour_lengths);
			*contour_lengths = null;
			*num_contours = (int) (0);
			return null;
		}

		public static void nk_tt_Rasterize(nk_tt__bitmap* result, float flatness_in_pixels, nk_tt_vertex* vertices,
			int num_verts, float scale_x, float scale_y, float shift_x, float shift_y, int x_off, int y_off, int invert)
		{
			float scale = (float) ((scale_x) > (scale_y) ? scale_y : scale_x);
			int winding_count;
			int* winding_lengths;
			nk_tt__point* windings = nk_tt_FlattenCurves(vertices, (int) (num_verts), (float) (flatness_in_pixels/scale),
				&winding_lengths, &winding_count);
			if ((windings) != null)
			{
				nk_tt__rasterize(result, windings, winding_lengths, (int) (winding_count), (float) (scale_x), (float) (scale_y),
					(float) (shift_x), (float) (shift_y), (int) (x_off), (int) (y_off), (int) (invert));
				CRuntime.free(winding_lengths);
				CRuntime.free(windings);
			}

		}

		public static void nk_tt_MakeGlyphBitmapSubpixel(nk_tt_fontinfo* info, byte* output, int out_w, int out_h,
			int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int glyph)
		{
			int ix0;
			int iy0;
			nk_tt_vertex* vertices;
			int num_verts = (int) (nk_tt_GetGlyphShape(info, (int) (glyph), &vertices));
			nk_tt__bitmap gbm = new nk_tt__bitmap();
			nk_tt_GetGlyphBitmapBoxSubpixel(info, (int) (glyph), (float) (scale_x), (float) (scale_y), (float) (shift_x),
				(float) (shift_y), &ix0, &iy0, null, null);
			gbm.pixels = output;
			gbm.w = (int) (out_w);
			gbm.h = (int) (out_h);
			gbm.stride = (int) (out_stride);
			if (((gbm.w) != 0) && ((gbm.h) != 0))
				nk_tt_Rasterize(&gbm, (float) (0.35f), vertices, (int) (num_verts), (float) (scale_x), (float) (scale_y),
					(float) (shift_x), (float) (shift_y), (int) (ix0), (int) (iy0), (int) (1));
			CRuntime.free(vertices);
		}

		public static int nk_tt_PackBegin(nk_tt_pack_context* spc, byte* pixels, int pw, int ph, int stride_in_bytes,
			int padding)
		{
			int num_nodes = (int) (pw - padding);
			nk_rp_context* context = (nk_rp_context*) (CRuntime.malloc((ulong) (sizeof (nk_rp_context))));
			nk_rp_node* nodes = (nk_rp_node*) (CRuntime.malloc((ulong) ((ulong) sizeof (nk_rp_node)*(ulong) (num_nodes))));
			if (((context) == (null)) || ((nodes) == (null)))
			{
				if (context != null) CRuntime.free(context);
				if (nodes != null) CRuntime.free(nodes);
				return (int) (0);
			}

			spc->width = (int) (pw);
			spc->height = (int) (ph);
			spc->pixels = pixels;
			spc->pack_info = context;
			spc->nodes = nodes;
			spc->padding = (int) (padding);
			spc->stride_in_bytes = (int) ((stride_in_bytes != 0) ? stride_in_bytes : pw);
			spc->h_oversample = (uint) (1);
			spc->v_oversample = (uint) (1);
			nk_rp_init_target(context, (int) (pw - padding), (int) (ph - padding), nodes, (int) (num_nodes));
			if ((pixels) != null) nk_memset(pixels, (int) (0), (ulong) (pw*ph));
			return (int) (1);
		}

		public static void nk_tt_PackEnd(nk_tt_pack_context* spc)
		{
			CRuntime.free(spc->nodes);
			CRuntime.free(spc->pack_info);
		}

		public static void nk_tt_PackSetOversampling(nk_tt_pack_context* spc, uint h_oversample, uint v_oversample)
		{
			if (h_oversample <= 8) spc->h_oversample = (uint) (h_oversample);
			if (v_oversample <= 8) spc->v_oversample = (uint) (v_oversample);
		}

		public static void nk_tt__h_prefilter(byte* pixels, int w, int h, int stride_in_bytes, int kernel_width)
		{
			byte* buffer = stackalloc byte[8];
			int safe_w = (int) (w - kernel_width);
			int j;
			for (j = (int) (0); (j) < (h); ++j)
			{
				int i;
				uint total;
				nk_memset(buffer, (int) (0), (ulong) (kernel_width));
				total = (uint) (0);
				switch (kernel_width)
				{
					case 2:
						for (i = (int) (0); i <= safe_w; ++i)
						{
							total += ((uint) (pixels[i] - buffer[i & (8 - 1)]));
							buffer[(i + kernel_width) & (8 - 1)] = (byte) (pixels[i]);
							pixels[i] = ((byte) (total/2));
						}
						break;
					case 3:
						for (i = (int) (0); i <= safe_w; ++i)
						{
							total += ((uint) (pixels[i] - buffer[i & (8 - 1)]));
							buffer[(i + kernel_width) & (8 - 1)] = (byte) (pixels[i]);
							pixels[i] = ((byte) (total/3));
						}
						break;
					case 4:
						for (i = (int) (0); i <= safe_w; ++i)
						{
							total += (uint) ((uint) (pixels[i]) - buffer[i & (8 - 1)]);
							buffer[(i + kernel_width) & (8 - 1)] = (byte) (pixels[i]);
							pixels[i] = ((byte) (total/4));
						}
						break;
					case 5:
						for (i = (int) (0); i <= safe_w; ++i)
						{
							total += ((uint) (pixels[i] - buffer[i & (8 - 1)]));
							buffer[(i + kernel_width) & (8 - 1)] = (byte) (pixels[i]);
							pixels[i] = ((byte) (total/5));
						}
						break;
					default:
						for (i = (int) (0); i <= safe_w; ++i)
						{
							total += ((uint) (pixels[i] - buffer[i & (8 - 1)]));
							buffer[(i + kernel_width) & (8 - 1)] = (byte) (pixels[i]);
							pixels[i] = ((byte) (total/(uint) (kernel_width)));
						}
						break;
				}
				for (; (i) < (w); ++i)
				{
					total -= ((uint) (buffer[i & (8 - 1)]));
					pixels[i] = ((byte) (total/(uint) (kernel_width)));
				}
				pixels += stride_in_bytes;
			}
		}

		public static void nk_tt__v_prefilter(byte* pixels, int w, int h, int stride_in_bytes, int kernel_width)
		{
			byte* buffer = stackalloc byte[8];
			int safe_h = (int) (h - kernel_width);
			int j;
			for (j = (int) (0); (j) < (w); ++j)
			{
				int i;
				uint total;
				nk_memset(buffer, (int) (0), (ulong) (kernel_width));
				total = (uint) (0);
				switch (kernel_width)
				{
					case 2:
						for (i = (int) (0); i <= safe_h; ++i)
						{
							total += ((uint) (pixels[i*stride_in_bytes] - buffer[i & (8 - 1)]));
							buffer[(i + kernel_width) & (8 - 1)] = (byte) (pixels[i*stride_in_bytes]);
							pixels[i*stride_in_bytes] = ((byte) (total/2));
						}
						break;
					case 3:
						for (i = (int) (0); i <= safe_h; ++i)
						{
							total += ((uint) (pixels[i*stride_in_bytes] - buffer[i & (8 - 1)]));
							buffer[(i + kernel_width) & (8 - 1)] = (byte) (pixels[i*stride_in_bytes]);
							pixels[i*stride_in_bytes] = ((byte) (total/3));
						}
						break;
					case 4:
						for (i = (int) (0); i <= safe_h; ++i)
						{
							total += ((uint) (pixels[i*stride_in_bytes] - buffer[i & (8 - 1)]));
							buffer[(i + kernel_width) & (8 - 1)] = (byte) (pixels[i*stride_in_bytes]);
							pixels[i*stride_in_bytes] = ((byte) (total/4));
						}
						break;
					case 5:
						for (i = (int) (0); i <= safe_h; ++i)
						{
							total += ((uint) (pixels[i*stride_in_bytes] - buffer[i & (8 - 1)]));
							buffer[(i + kernel_width) & (8 - 1)] = (byte) (pixels[i*stride_in_bytes]);
							pixels[i*stride_in_bytes] = ((byte) (total/5));
						}
						break;
					default:
						for (i = (int) (0); i <= safe_h; ++i)
						{
							total += ((uint) (pixels[i*stride_in_bytes] - buffer[i & (8 - 1)]));
							buffer[(i + kernel_width) & (8 - 1)] = (byte) (pixels[i*stride_in_bytes]);
							pixels[i*stride_in_bytes] = ((byte) (total/(uint) (kernel_width)));
						}
						break;
				}
				for (; (i) < (h); ++i)
				{
					total -= ((uint) (buffer[i & (8 - 1)]));
					pixels[i*stride_in_bytes] = ((byte) (total/(uint) (kernel_width)));
				}
				pixels += 1;
			}
		}

		public static float nk_tt__oversample_shift(int oversample)
		{
			if (oversample == 0) return (float) (0.0f);
			return (float) ((float) (-(oversample - 1))/(2.0f*(float) (oversample)));
		}

		public static int nk_tt_PackFontRangesGatherRects(nk_tt_pack_context* spc, nk_tt_fontinfo* info,
			nk_tt_pack_range* ranges, int num_ranges, nk_rp_rect* rects)
		{
			int i;
			int j;
			int k;
			k = (int) (0);
			for (i = (int) (0); (i) < (num_ranges); ++i)
			{
				float fh = (float) (ranges[i].font_size);
				float scale =
					(float)
						(((fh) > (0))
							? nk_tt_ScaleForPixelHeight(info, (float) (fh))
							: nk_tt_ScaleForMappingEmToPixels(info, (float) (-fh)));
				ranges[i].h_oversample = ((byte) (spc->h_oversample));
				ranges[i].v_oversample = ((byte) (spc->v_oversample));
				for (j = (int) (0); (j) < (ranges[i].num_chars); ++j)
				{
					int x0;
					int y0;
					int x1;
					int y1;
					int codepoint =
						(int)
							((ranges[i].first_unicode_codepoint_in_range) != 0
								? ranges[i].first_unicode_codepoint_in_range + j
								: ranges[i].array_of_unicode_codepoints[j]);
					int glyph = (int) (nk_tt_FindGlyphIndex(info, (int) (codepoint)));
					nk_tt_GetGlyphBitmapBoxSubpixel(info, (int) (glyph), (float) (scale*(float) (spc->h_oversample)),
						(float) (scale*(float) (spc->v_oversample)), (float) (0), (float) (0), &x0, &y0, &x1, &y1);
					rects[k].w = ((ushort) (x1 - x0 + spc->padding + (int) (spc->h_oversample) - 1));
					rects[k].h = ((ushort) (y1 - y0 + spc->padding + (int) (spc->v_oversample) - 1));
					++k;
				}
			}
			return (int) (k);
		}

		public static int nk_tt_PackFontRangesRenderIntoRects(nk_tt_pack_context* spc, nk_tt_fontinfo* info,
			nk_tt_pack_range* ranges, int num_ranges, nk_rp_rect* rects)
		{
			int i;
			int j;
			int k;
			int return_value = (int) (1);
			int old_h_over = (int) (spc->h_oversample);
			int old_v_over = (int) (spc->v_oversample);
			k = (int) (0);
			for (i = (int) (0); (i) < (num_ranges); ++i)
			{
				float fh = (float) (ranges[i].font_size);
				float recip_h;
				float recip_v;
				float sub_x;
				float sub_y;
				float scale =
					(float)
						((fh) > (0) ? nk_tt_ScaleForPixelHeight(info, (float) (fh)) : nk_tt_ScaleForMappingEmToPixels(info, (float) (-fh)));
				spc->h_oversample = (uint) (ranges[i].h_oversample);
				spc->v_oversample = (uint) (ranges[i].v_oversample);
				recip_h = (float) (1.0f/(float) (spc->h_oversample));
				recip_v = (float) (1.0f/(float) (spc->v_oversample));
				sub_x = (float) (nk_tt__oversample_shift((int) (spc->h_oversample)));
				sub_y = (float) (nk_tt__oversample_shift((int) (spc->v_oversample)));
				for (j = (int) (0); (j) < (ranges[i].num_chars); ++j)
				{
					nk_rp_rect* r = &rects[k];
					if ((r->was_packed) != 0)
					{
						nk_tt_packedchar* bc = &ranges[i].chardata_for_range[j];
						int advance;
						int lsb;
						int x0;
						int y0;
						int x1;
						int y1;
						int codepoint =
							(int)
								((ranges[i].first_unicode_codepoint_in_range) != 0
									? ranges[i].first_unicode_codepoint_in_range + j
									: ranges[i].array_of_unicode_codepoints[j]);

						int glyph = (int) (nk_tt_FindGlyphIndex(info, (int) (codepoint)));
						ushort pad = (ushort) (spc->padding);
						r->x = ((ushort) ((int) (r->x) + (int) (pad)));
						r->y = ((ushort) ((int) (r->y) + (int) (pad)));
						r->w = ((ushort) ((int) (r->w) - (int) (pad)));
						r->h = ((ushort) ((int) (r->h) - (int) (pad)));
						nk_tt_GetGlyphHMetrics(info, (int) (glyph), &advance, &lsb);
						nk_tt_GetGlyphBitmapBox(info, (int) (glyph), (float) (scale*(float) (spc->h_oversample)),
							(float) (scale*(float) (spc->v_oversample)), &x0, &y0, &x1, &y1);
						nk_tt_MakeGlyphBitmapSubpixel(info, spc->pixels + r->x + r->y*spc->stride_in_bytes,
							(int) (r->w - spc->h_oversample + 1), (int) (r->h - spc->v_oversample + 1), (int) (spc->stride_in_bytes),
							(float) (scale*(float) (spc->h_oversample)), (float) (scale*(float) (spc->v_oversample)), (float) (0),
							(float) (0), (int) (glyph));
						if ((spc->h_oversample) > (1))
							nk_tt__h_prefilter(spc->pixels + r->x + r->y*spc->stride_in_bytes, (int) (r->w), (int) (r->h),
								(int) (spc->stride_in_bytes), (int) (spc->h_oversample));
						if ((spc->v_oversample) > (1))
							nk_tt__v_prefilter(spc->pixels + r->x + r->y*spc->stride_in_bytes, (int) (r->w), (int) (r->h),
								(int) (spc->stride_in_bytes), (int) (spc->v_oversample));
						bc->x0 = (ushort) (r->x);
						bc->y0 = (ushort) (r->y);
						bc->x1 = ((ushort) (r->x + r->w));
						bc->y1 = ((ushort) (r->y + r->h));
						bc->xadvance = (float) (scale*(float) (advance));
						bc->xoff = (float) ((float) (x0)*recip_h + sub_x);
						bc->yoff = (float) ((float) (y0)*recip_v + sub_y);
						bc->xoff2 = (float) (((float) (x0) + r->w)*recip_h + sub_x);
						bc->yoff2 = (float) (((float) (y0) + r->h)*recip_v + sub_y);
					}
					else
					{
						return_value = (int) (0);
					}
					++k;
				}
			}
			spc->h_oversample = ((uint) (old_h_over));
			spc->v_oversample = ((uint) (old_v_over));
			return (int) (return_value);
		}

		public static void nk_tt_GetPackedQuad(nk_tt_packedchar* chardata, int pw, int ph, int char_index, float* xpos,
			float* ypos, nk_tt_aligned_quad* q, int align_to_integer)
		{
			float ipw = (float) (1.0f/(float) (pw));
			float iph = (float) (1.0f/(float) (ph));
			nk_tt_packedchar* b = (chardata + char_index);
			if ((align_to_integer) != 0)
			{
				int tx = (int) (nk_ifloorf((float) ((*xpos + b->xoff) + 0.5f)));
				int ty = (int) (nk_ifloorf((float) ((*ypos + b->yoff) + 0.5f)));
				float x = (float) (tx);
				float y = (float) (ty);
				q->x0 = (float) (x);
				q->y0 = (float) (y);
				q->x1 = (float) (x + b->xoff2 - b->xoff);
				q->y1 = (float) (y + b->yoff2 - b->yoff);
			}
			else
			{
				q->x0 = (float) (*xpos + b->xoff);
				q->y0 = (float) (*ypos + b->yoff);
				q->x1 = (float) (*xpos + b->xoff2);
				q->y1 = (float) (*ypos + b->yoff2);
			}

			q->s0 = (float) (b->x0*ipw);
			q->t0 = (float) (b->y0*iph);
			q->s1 = (float) (b->x1*ipw);
			q->t1 = (float) (b->y1*iph);
			*xpos += (float) (b->xadvance);
		}

		public static int nk_range_count(uint* range)
		{
			uint* iter = range;
			if (range == null) return (int) (0);
			while (*(iter++) != 0)
			{
			}
			return (int) (((iter) == (range)) ? 0 : (int) ((iter - range)/2));
		}

		public static int nk_range_glyph_count(uint* range, int count)
		{
			int i = (int) (0);
			int total_glyphs = (int) (0);
			for (i = (int) (0); (i) < (count); ++i)
			{
				int diff;
				uint f = (uint) (range[(i*2) + 0]);
				uint t = (uint) (range[(i*2) + 1]);
				diff = ((int) ((t - f) + 1));
				total_glyphs += (int) (diff);
			}
			return (int) (total_glyphs);
		}

		private static PinnedArray<uint> ranges = new PinnedArray<uint>(new uint[] {0x0020, 0x00FF, 0});

		public static uint* nk_font_default_glyph_ranges()
		{
			return (uint*) ranges;
		}

		public static uint* nk_font_chinese_glyph_ranges()
		{
			return (uint*)ranges;
		}

		public static uint* nk_font_cyrillic_glyph_ranges()
		{
			return (uint*)ranges;
		}

		public static uint* nk_font_korean_glyph_ranges()
		{
			uint* ranges = stackalloc uint[7];
			ranges[0] = (uint) (0x0020);
			ranges[1] = (uint) (0x00FF);
			ranges[2] = (uint) (0x3131);
			ranges[3] = (uint) (0x3163);
			ranges[4] = (uint) (0xAC00);
			ranges[5] = (uint) (0xD79D);
			ranges[6] = (uint) (0);

			return ranges;
		}

		public static void nk_font_baker_memory(ulong* temp, ref int glyph_count, nk_font_config config_list, int count)
		{
			int range_count = (int) (0);
			int total_range_count = (int) (0);
			nk_font_config iter;
			nk_font_config i;
			if (config_list == null)
			{
				*temp = (ulong) (0);
				glyph_count = (int) (0);
				return;
			}

			glyph_count = (int) (0);
			for (iter = config_list; iter != null; iter = iter.next)
			{
				i = iter;
				do
				{
					if (i.range == null) iter.range = nk_font_default_glyph_ranges();
					range_count = (int) (nk_range_count(i.range));
					total_range_count += (int) (range_count);
					glyph_count += (int) (nk_range_glyph_count(i.range, (int) (range_count)));
				} while ((i = i.n) != iter);
			}
			*temp = (ulong) ((ulong) (glyph_count)*(ulong) sizeof (nk_rp_rect));
			*temp += (ulong) ((ulong) (total_range_count)*(ulong) sizeof (nk_tt_pack_range));
			*temp += (ulong) ((ulong) (glyph_count)*(ulong) sizeof (nk_tt_packedchar));
			*temp += (ulong) ((ulong) (count)*(ulong) sizeof (nk_font_bake_data));
			*temp += (ulong) (sizeof (nk_font_baker));
			*temp += (ulong) (nk_rect_align + nk_range_align + nk_char_align);
			*temp += (ulong) (nk_build_align + nk_baker_align);
		}

		public static nk_font_baker* nk_font_baker_(void* memory, int glyph_count, int count)
		{
			nk_font_baker* baker;
			if (memory == null) return null;
			baker =
				(nk_font_baker*)
					((void*) ((long) (((ulong) ((long) ((byte*) (memory) + (nk_baker_align - 1)))) & ~(nk_baker_align - 1))));
			baker->build =
				(nk_font_bake_data*)
					((void*) ((long) (((ulong) ((long) ((byte*) (baker + 1) + (nk_build_align - 1)))) & ~(nk_build_align - 1))));
			baker->packed_chars =
				(nk_tt_packedchar*)
					((void*)
						((long) (((ulong) ((long) ((byte*) (baker->build + count) + (nk_char_align - 1)))) & ~(nk_char_align - 1))));
			baker->rects =
				(nk_rp_rect*)
					((void*)
						((long)
							(((ulong) ((long) ((byte*) (baker->packed_chars + glyph_count) + (nk_rect_align - 1)))) & ~(nk_rect_align - 1))));
			baker->ranges =
				(nk_tt_pack_range*)
					((void*)
						((long) (((ulong) ((long) ((byte*) (baker->rects + glyph_count) + (nk_range_align - 1)))) & ~(nk_range_align - 1))));

			return baker;
		}

		public static int nk_font_bake_pack(nk_font_baker* baker, ulong* image_memory, ref int width, ref int height,
			ref nk_recti custom, nk_font_config config_list, int count)
		{
			ulong max_height = (ulong) (1024*32);
			nk_font_config config_iter;
			nk_font_config it;
			int total_glyph_count = (int) (0);
			int total_range_count = (int) (0);
			int range_count = (int) (0);
			int i = (int) (0);
			if (((((image_memory == null) || (width == null)) || (height == null)) || (config_list == null)) || (count == 0))
				return (int) (nk_false);
			for (config_iter = config_list; config_iter != null; config_iter = config_iter.next)
			{
				it = config_iter;
				do
				{
					range_count = (int) (nk_range_count(it.range));
					total_range_count += (int) (range_count);
					total_glyph_count += (int) (nk_range_glyph_count(it.range, (int) (range_count)));
				} while ((it = it.n) != config_iter);
			}
			for (config_iter = config_list; config_iter != null; config_iter = config_iter.next)
			{
				it = config_iter;
				do
				{
					if (nk_tt_InitFont(&baker->build[i++].info, (byte*) (it.ttf_blob), (int) (0)) == 0) return (int) (nk_false);
				} while ((it = it.n) != config_iter);
			}
			height = (int) (0);
			width = (int) (((total_glyph_count) > (1000)) ? 1024 : 512);
			nk_tt_PackBegin(&baker->spc, null, (int) (width), (int) (max_height), (int) (0), (int) (1));
			{
				int input_i = (int) (0);
				int range_n = (int) (0);
				int rect_n = (int) (0);
				int char_n = (int) (0);
				{
					nk_rp_rect custom_space = new nk_rp_rect();
					nk_zero(&custom_space, (ulong) (sizeof (nk_rp_rect)));
					custom_space.w = ((ushort) ((custom.w*2) + 1));
					custom_space.h = ((ushort) (custom.h + 1));
					nk_tt_PackSetOversampling(&baker->spc, (uint) (1), (uint) (1));
					nk_rp_pack_rects((nk_rp_context*) (baker->spc.pack_info), &custom_space, (int) (1));
					height = (int) ((height) < (custom_space.y + custom_space.h) ? (custom_space.y + custom_space.h) : (height));
					custom.x = ((short) (custom_space.x));
					custom.y = ((short) (custom_space.y));
					custom.w = ((short) (custom_space.w));
					custom.h = ((short) (custom_space.h));
				}
				for (input_i = (int) (0) , config_iter = config_list;
					((input_i) < (count)) && ((config_iter) != null);
					config_iter = config_iter.next)
				{
					it = config_iter;
					do
					{
						int n = (int) (0);
						int glyph_count;
						uint* in_range;
						nk_font_config cfg = it;
						nk_font_bake_data* tmp = &baker->build[input_i++];
						glyph_count = (int) (0);
						range_count = (int) (0);
						for (in_range = cfg.range; ((in_range[0]) != 0) && ((in_range[1]) != 0); in_range += 2)
						{
							glyph_count += (int) ((int) (in_range[1] - in_range[0]) + 1);
							range_count++;
						}
						tmp->ranges = baker->ranges + range_n;
						tmp->range_count = ((uint) (range_count));
						range_n += (int) (range_count);
						for (i = (int) (0); (i) < (range_count); ++i)
						{
							in_range = &cfg.range[i*2];
							tmp->ranges[i].font_size = (float) (cfg.size);
							tmp->ranges[i].first_unicode_codepoint_in_range = ((int) (in_range[0]));
							tmp->ranges[i].num_chars = (int) ((int) (in_range[1] - in_range[0]) + 1);
							tmp->ranges[i].chardata_for_range = baker->packed_chars + char_n;
							char_n += (int) (tmp->ranges[i].num_chars);
						}
						tmp->rects = baker->rects + rect_n;
						rect_n += (int) (glyph_count);
						nk_tt_PackSetOversampling(&baker->spc, (uint) (cfg.oversample_h), (uint) (cfg.oversample_v));
						n =
							(int)
								(nk_tt_PackFontRangesGatherRects(&baker->spc, &tmp->info, tmp->ranges, (int) (tmp->range_count), tmp->rects));
						nk_rp_pack_rects((nk_rp_context*) (baker->spc.pack_info), tmp->rects, (int) (n));
						for (i = (int) (0); (i) < (n); ++i)
						{
							if ((tmp->rects[i].was_packed) != 0)
								height = (int) ((height) < (tmp->rects[i].y + tmp->rects[i].h) ? (tmp->rects[i].y + tmp->rects[i].h) : (height));
						}
					} while ((it = it.n) != config_iter);
				}
			}

			height = ((int) (nk_round_up_pow2((uint) (height))));
			*image_memory = (ulong) ((ulong) (width)*(ulong) (height));
			return (int) (nk_true);
		}

		public static void nk_font_bake(nk_font_baker* baker, void* image_memory, int width, int height, nk_font_glyph* glyphs,
			int glyphs_count, nk_font_config config_list, int font_count)
		{
			int input_i = (int) (0);
			uint glyph_n = (uint) (0);
			nk_font_config config_iter;
			nk_font_config it;
			if (((((((image_memory == null) || (width == 0)) || (height == 0)) || (config_list == null)) || (font_count == 0)) ||
			     (glyphs == null)) || (glyphs_count == 0)) return;
			nk_zero(image_memory, (ulong) ((ulong) (width)*(ulong) (height)));
			baker->spc.pixels = (byte*) (image_memory);
			baker->spc.height = (int) (height);
			for (input_i = (int) (0) , config_iter = config_list;
				((input_i) < (font_count)) && ((config_iter) != null);
				config_iter = config_iter.next)
			{
				it = config_iter;
				do
				{
					nk_font_config cfg = it;
					nk_font_bake_data* tmp = &baker->build[input_i++];
					nk_tt_PackSetOversampling(&baker->spc, (uint) (cfg.oversample_h), (uint) (cfg.oversample_v));
					nk_tt_PackFontRangesRenderIntoRects(&baker->spc, &tmp->info, tmp->ranges, (int) (tmp->range_count), tmp->rects);
				} while ((it = it.n) != config_iter);
			}
			nk_tt_PackEnd(&baker->spc);
			for (input_i = (int) (0) , config_iter = config_list;
				((input_i) < (font_count)) && ((config_iter) != null);
				config_iter = config_iter.next)
			{
				it = config_iter;
				do
				{
					ulong i = (ulong) (0);
					int char_idx = (int) (0);
					uint glyph_count = (uint) (0);
					nk_font_config cfg = it;
					nk_font_bake_data* tmp = &baker->build[input_i++];
					nk_baked_font dst_font = cfg.font;
					float font_scale = (float) (nk_tt_ScaleForPixelHeight(&tmp->info, (float) (cfg.size)));
					int unscaled_ascent;
					int unscaled_descent;
					int unscaled_line_gap;
					nk_tt_GetFontVMetrics(&tmp->info, &unscaled_ascent, &unscaled_descent, &unscaled_line_gap);
					if (cfg.merge_mode == 0)
					{
						dst_font.ranges = cfg.range;
						dst_font.height = (float) (cfg.size);
						dst_font.ascent = (float) ((float) (unscaled_ascent)*font_scale);
						dst_font.descent = (float) ((float) (unscaled_descent)*font_scale);
						dst_font.glyph_offset = (uint) (glyph_n);
					}
					for (i = (ulong) (0); (i) < (tmp->range_count); ++i)
					{
						nk_tt_pack_range* range = &tmp->ranges[i];
						for (char_idx = (int) (0); (char_idx) < (range->num_chars); char_idx++)
						{
							char codepoint = (char) 0;
							float dummy_x = (float) (0);
							float dummy_y = (float) (0);
							nk_tt_aligned_quad q = new nk_tt_aligned_quad();
							nk_font_glyph* glyph;
							nk_tt_packedchar* pc = &range->chardata_for_range[char_idx];
							if ((((pc->x0 == 0) && (pc->x1 == 0)) && (pc->y0 == 0)) && (pc->y1 == 0)) continue;
							codepoint = ((char) (range->first_unicode_codepoint_in_range + char_idx));
							nk_tt_GetPackedQuad(range->chardata_for_range, (int) (width), (int) (height), (int) (char_idx), &dummy_x,
								&dummy_y, &q, (int) (0));
							glyph = &glyphs[dst_font.glyph_offset + dst_font.glyph_count + glyph_count];
							glyph->codepoint = codepoint;
							glyph->x0 = (float) (q.x0);
							glyph->y0 = (float) (q.y0);
							glyph->x1 = (float) (q.x1);
							glyph->y1 = (float) (q.y1);
							glyph->y0 += (float) (dst_font.ascent + 0.5f);
							glyph->y1 += (float) (dst_font.ascent + 0.5f);
							glyph->w = (float) (glyph->x1 - glyph->x0 + 0.5f);
							glyph->h = (float) (glyph->y1 - glyph->y0);
							if ((cfg.coord_type) == (NK_COORD_PIXEL))
							{
								glyph->u0 = (float) (q.s0*(float) (width));
								glyph->v0 = (float) (q.t0*(float) (height));
								glyph->u1 = (float) (q.s1*(float) (width));
								glyph->v1 = (float) (q.t1*(float) (height));
							}
							else
							{
								glyph->u0 = (float) (q.s0);
								glyph->v0 = (float) (q.t0);
								glyph->u1 = (float) (q.s1);
								glyph->v1 = (float) (q.t1);
							}
							glyph->xadvance = (float) (pc->xadvance + cfg.spacing.x);
							if ((cfg.pixel_snap) != 0) glyph->xadvance = ((float) ((int) (glyph->xadvance + 0.5f)));
							glyph_count++;
						}
					}
					dst_font.glyph_count += (uint) (glyph_count);
					glyph_n += (uint) (glyph_count);
				} while ((it = it.n) != config_iter);
			}
		}

		public static void nk_font_bake_custom_data(void* img_memory, int img_width, int img_height, nk_recti img_dst,
			char* texture_data_mask, int tex_width, int tex_height, char white, char black)
		{
			byte* pixels;
			int y = (int) (0);
			int x = (int) (0);
			int n = (int) (0);
			if ((((img_memory == null) || (img_width == 0)) || (img_height == 0)) || (texture_data_mask == null)) return;
			pixels = (byte*) (img_memory);
			for (y = (int) (0) , n = (int) (0); (y) < (tex_height); ++y)
			{
				for (x = (int) (0); (x) < (tex_width); ++x , ++n)
				{
					int off0 = (int) ((img_dst.x + x) + (img_dst.y + y)*img_width);
					int off1 = (int) (off0 + 1 + tex_width);
					pixels[off0] = (byte) (((texture_data_mask[n]) == (white)) ? 0xFF : 0x00);
					pixels[off1] = (byte) (((texture_data_mask[n]) == (black)) ? 0xFF : 0x00);
				}
			}
		}

		public static void nk_font_bake_convert(void* out_memory, int img_width, int img_height, void* in_memory)
		{
			int n = (int) (0);
			uint* dst;
			byte* src;
			if ((((out_memory == null) || (in_memory == null)) || (img_height == 0)) || (img_width == 0)) return;
			dst = (uint*) (out_memory);
			src = (byte*) (in_memory);
			for (n = (int) (img_width*img_height); (n) > (0); n--)
			{
				*dst++ = (uint) (((uint) (*src++) << 24) | 0x00FFFFFF);
			}
		}

		public static float nk_font_text_width(nk_font font, float height, char* text, int len)
		{
			char unicode;
			int text_len = (int) (0);
			float text_width = (float) (0);
			int glyph_len = (int) (0);
			float scale = (float) (0);

			if (((font == null) || (text == null)) || (len == 0)) return (float) (0);
			scale = (float) (height/font.info.height);
			glyph_len = (int) (text_len = (int) (nk_utf_decode(text, &unicode, (int) (len))));
			if (glyph_len == 0) return (float) (0);
			while ((text_len <= len) && ((glyph_len) != 0))
			{
				nk_font_glyph* g;
				if ((unicode) == (0xFFFD)) break;
				g = nk_font_find_glyph(font, unicode);
				text_width += (float) (g->xadvance*scale);
				glyph_len = (int) (nk_utf_decode(text + text_len, &unicode, (int) (len - text_len)));
				text_len += (int) (glyph_len);
			}
			return (float) (text_width);
		}

		public static void nk_font_query_font_glyph(nk_font font, float height, nk_user_font_glyph* glyph, char codepoint,
			char next_codepoint)
		{
			float scale;
			nk_font_glyph* g;


			if ((font == null) || (glyph == null)) return;
			scale = (float) (height/font.info.height);
			g = nk_font_find_glyph(font, codepoint);
			glyph->width = (float) ((g->x1 - g->x0)*scale);
			glyph->height = (float) ((g->y1 - g->y0)*scale);
			glyph->offset = (nk_vec2) (nk_vec2_((float) (g->x0*scale), (float) (g->y0*scale)));
			glyph->xadvance = (float) (g->xadvance*scale);
			glyph->uv_x[0] = g->u0;
			glyph->uv_y[0] = g->v0;
			glyph->uv_x[1] = g->u1;
			glyph->uv_y[1] = g->v1;
		}

		public static nk_font_glyph* nk_font_find_glyph(nk_font font, char unicode)
		{
			int i = (int) (0);
			int count;
			int total_glyphs = (int) (0);
			nk_font_glyph* glyph = null;
			nk_font_config iter = null;
			if ((font == null) || (font.glyphs == null)) return null;
			glyph = font.fallback;
			iter = font.config;
			do
			{
				count = (int) (nk_range_count(iter.range));
				for (i = (int) (0); (i) < (count); ++i)
				{
					uint f = (uint) (iter.range[(i*2) + 0]);
					uint t = (uint) (iter.range[(i*2) + 1]);
					int diff = (int) ((t - f) + 1);
					if (((unicode) >= (f)) && (unicode <= t)) return &font.glyphs[((uint) (total_glyphs) + (unicode - f))];
					total_glyphs += (int) (diff);
				}
			} while ((iter = iter.n) != font.config);
			return glyph;
		}

		public static void nk_font_init(nk_font font, float pixel_height, char fallback_codepoint, nk_font_glyph* glyphs,
			nk_baked_font baked_font, nk_handle atlas)
		{
			nk_baked_font baked = new nk_baked_font();
			if (((font == null) || (glyphs == null)) || (baked_font == null)) return;
			baked = (nk_baked_font) (baked_font);
			font.fallback = null;
			font.info = (nk_baked_font) (baked);
			font.scale = (float) (pixel_height/font.info.height);
			font.glyphs = &glyphs[baked_font.glyph_offset];
			font.texture = (nk_handle) (atlas);
			font.fallback_codepoint = fallback_codepoint;
			font.fallback = nk_font_find_glyph(font, fallback_codepoint);
			font.handle.height = (float) (font.info.height*font.scale);
			font.handle.width = font.text_width;

			font.handle.query = font.query_font_glyph;
			font.handle.texture = (nk_handle) (font.texture);
		}

		public static uint nk_decompress_length(byte* input)
		{
			return (uint) ((input[8] << 24) + (input[9] << 16) + (input[10] << 8) + input[11]);
		}

		public static void nk__match(byte* data, uint length)
		{
			if ((nk__dout + length) > (nk__barrier))
			{
				nk__dout += length;
				return;
			}

			if ((data) < (nk__barrier4))
			{
				nk__dout = nk__barrier + 1;
				return;
			}

			while ((length--) != 0)
			{
				*nk__dout++ = (byte) (*data++);
			}
		}

		public static void nk__lit(byte* data, uint length)
		{
			if ((nk__dout + length) > (nk__barrier))
			{
				nk__dout += length;
				return;
			}

			if ((data) < (nk__barrier2))
			{
				nk__dout = nk__barrier + 1;
				return;
			}

			nk_memcopy(nk__dout, data, (ulong) (length));
			nk__dout += length;
		}

		public static byte* nk_decompress_token(byte* i)
		{
			if ((*i) >= (0x20))
			{
				if ((*i) >= (0x80))
				{
					nk__match(nk__dout - i[1] - 1, (uint) ((uint) (i[0]) - 0x80 + 1));
					i += 2;
				}
				else if ((*i) >= (0x40))
				{
					nk__match(nk__dout - (((i[0] << 8) + i[(0) + 1]) - 0x4000 + 1), (uint) ((uint) (i[2]) + 1));
					i += 3;
				}
				else
				{
					nk__lit(i + 1, (uint) ((uint) (i[0]) - 0x20 + 1));
					i += 1 + (i[0] - 0x20 + 1);
				}
			}
			else
			{
				if ((*i) >= (0x18))
				{
					nk__match(nk__dout - (uint) (((i[0] << 16) + ((i[(0) + 1] << 8) + i[((0) + 1) + 1])) - 0x180000 + 1),
						(uint) ((uint) (i[3]) + 1));
					i += 4;
				}
				else if ((*i) >= (0x10))
				{
					nk__match(nk__dout - (uint) (((i[0] << 16) + ((i[(0) + 1] << 8) + i[((0) + 1) + 1])) - 0x100000 + 1),
						(uint) ((uint) ((i[3] << 8) + i[(3) + 1]) + 1));
					i += 5;
				}
				else if ((*i) >= (0x08))
				{
					nk__lit(i + 2, (uint) ((uint) ((i[0] << 8) + i[(0) + 1]) - 0x0800 + 1));
					i += 2 + (((i[0] << 8) + i[(0) + 1]) - 0x0800 + 1);
				}
				else if ((*i) == (0x07))
				{
					nk__lit(i + 3, (uint) ((uint) ((i[1] << 8) + i[(1) + 1]) + 1));
					i += 3 + (((i[1] << 8) + i[(1) + 1]) + 1);
				}
				else if ((*i) == (0x06))
				{
					nk__match(nk__dout - (uint) (((i[1] << 16) + ((i[(1) + 1] << 8) + i[((1) + 1) + 1])) + 1), (uint) (i[4] + 1u));
					i += 5;
				}
				else if ((*i) == (0x04))
				{
					nk__match(nk__dout - (uint) (((i[1] << 16) + ((i[(1) + 1] << 8) + i[((1) + 1) + 1])) + 1),
						(uint) ((uint) ((i[4] << 8) + i[(4) + 1]) + 1u));
					i += 6;
				}
			}

			return i;
		}

		public static uint nk_adler32(uint adler32, byte* buffer, uint buflen)
		{
			int ADLER_MOD = (int) (65521);
			int s1 = (int) (adler32 & 0xffff);
			int s2 = (int) (adler32 >> 16);
			int blocklen;
			int i;
			blocklen = (int) (buflen%5552);
			while ((buflen) != 0)
			{
				for (i = (int) (0); (i + 7) < (blocklen); i += (int) (8))
				{
					s1 += (int) (buffer[0]);
					s2 += (int) (s1);
					s1 += (int) (buffer[1]);
					s2 += (int) (s1);
					s1 += (int) (buffer[2]);
					s2 += (int) (s1);
					s1 += (int) (buffer[3]);
					s2 += (int) (s1);
					s1 += (int) (buffer[4]);
					s2 += (int) (s1);
					s1 += (int) (buffer[5]);
					s2 += (int) (s1);
					s1 += (int) (buffer[6]);
					s2 += (int) (s1);
					s1 += (int) (buffer[7]);
					s2 += (int) (s1);
					buffer += 8;
				}
				for (; (i) < (blocklen); ++i)
				{
					s1 += (int) (*buffer++);
					s2 += (int) (s1);
				}
				s1 %= (int) (ADLER_MOD);
				s2 %= (int) (ADLER_MOD);
				buflen -= ((uint) (blocklen));
				blocklen = (int) (5552);
			}
			return (uint) ((uint) (s2 << 16) + (uint) (s1));
		}

		public static uint nk_decompress(byte* output, byte* i, uint length)
		{
			uint olen;
			if (((i[0] << 24) + ((i[(0) + 1] << 16) + ((i[((0) + 1) + 1] << 8) + i[(((0) + 1) + 1) + 1]))) != 0x57bC0000)
				return (uint) (0);
			if (((i[4] << 24) + ((i[(4) + 1] << 16) + ((i[((4) + 1) + 1] << 8) + i[(((4) + 1) + 1) + 1]))) != 0)
				return (uint) (0);
			olen = (uint) (nk_decompress_length(i));
			nk__barrier2 = i;
			nk__barrier3 = i + length;
			nk__barrier = output + olen;
			nk__barrier4 = output;
			i += 16;
			nk__dout = output;
			for (;;)
			{
				byte* old_i = i;
				i = nk_decompress_token(i);
				if ((i) == (old_i))
				{
					if (((*i) == (0x05)) && ((i[1]) == (0xfa)))
					{
						if (nk__dout != output + olen) return (uint) (0);
						if (nk_adler32((uint) (1), output, (uint) (olen)) !=
						    (uint) ((i[2] << 24) + ((i[(2) + 1] << 16) + ((i[((2) + 1) + 1] << 8) + i[(((2) + 1) + 1) + 1]))))
							return (uint) (0);
						return (uint) (olen);
					}
					else
					{
						return (uint) (0);
					}
				}
				if ((nk__dout) > (output + olen)) return (uint) (0);
			}
		}

		public static uint nk_decode_85_byte(sbyte c)
		{
			return (uint) (((c) >= ('\\')) ? c - 36 : c - 35);
		}

		public static void nk_decode_85(byte* dst, byte* src)
		{
			while ((*src) != 0)
			{
				uint tmp =
					(uint)
						(nk_decode_85_byte((sbyte) (src[0])) +
						 85*
						 (nk_decode_85_byte((sbyte) (src[1])) +
						  85*
						  (nk_decode_85_byte((sbyte) (src[2])) +
						   85*(nk_decode_85_byte((sbyte) (src[3])) + 85*nk_decode_85_byte((sbyte) (src[4]))))));
				dst[0] = ((byte) ((tmp >> 0) & 0xFF));
				dst[1] = ((byte) ((tmp >> 8) & 0xFF));
				dst[2] = ((byte) ((tmp >> 16) & 0xFF));
				dst[3] = ((byte) ((tmp >> 24) & 0xFF));
				src += 5;
				dst += 4;
			}
		}

		public static nk_font_config nk_font_config_(float pixel_height)
		{
			nk_font_config cfg = new nk_font_config();

			cfg.ttf_blob = null;
			cfg.ttf_size = (ulong) (0);
			cfg.ttf_data_owned_by_atlas = (byte) (0);
			cfg.size = (float) (pixel_height);
			cfg.oversample_h = (byte) (3);
			cfg.oversample_v = (byte) (1);
			cfg.pixel_snap = (byte) (0);
			cfg.coord_type = (int) (NK_COORD_UV);
			cfg.spacing = (nk_vec2) (nk_vec2_((float) (0), (float) (0)));
			cfg.range = nk_font_default_glyph_ranges();
			cfg.merge_mode = (byte) (0);
			cfg.fallback_glyph = '?';
			cfg.font = null;
			cfg.n = null;
			return (nk_font_config) (cfg);
		}

		public static void nk_font_atlas_begin(nk_font_atlas atlas)
		{
			if (((((atlas == null))))) return;
			if ((atlas.glyphs) != null)
			{
				CRuntime.free(atlas.glyphs);
				atlas.glyphs = null;
			}

			if ((atlas.pixel) != null)
			{
				CRuntime.free(atlas.pixel);
				atlas.pixel = null;
			}

		}

		public static nk_font nk_font_atlas_add(nk_font_atlas atlas, nk_font_config config)
		{
			nk_font font = null;
			nk_font_config cfg;
			if (((((((((atlas == null) || (config == null)) || (config.ttf_blob == null)) || (config.ttf_size == 0)) ||
			        (config.size <= 0.0f)))))) return null;

			cfg = nk_font_config_clone(config);
			cfg.n = cfg;
			cfg.p = cfg;
			if (config.merge_mode == 0)
			{
				if (atlas.config == null)
				{
					atlas.config = cfg;
					cfg.next = null;
				}
				else
				{
					nk_font_config i = atlas.config;
					while ((i.next) != null)
					{
						i = i.next;
					}
					i.next = cfg;
					cfg.next = null;
				}
				font = new nk_font();
				font.config = cfg;
				if (atlas.fonts == null)
				{
					atlas.fonts = font;
					font.next = null;
				}
				else
				{
					nk_font i = atlas.fonts;
					while ((i.next) != null)
					{
						i = i.next;
					}
					i.next = font;
					font.next = null;
				}
				cfg.font = font.info;
			}
			else
			{
				nk_font f = null;
				nk_font_config c = null;
				f = atlas.fonts;
				c = f.config;
				cfg.font = f.info;
				cfg.n = c;
				cfg.p = c.p;
				c.p.n = cfg;
				c.p = cfg;
			}

			if (config.ttf_data_owned_by_atlas == 0)
			{
				cfg.ttf_blob = CRuntime.malloc((ulong) (cfg.ttf_size));				if (cfg.ttf_blob == null)				{
					atlas.font_num++;
					return null;
				}
				nk_memcopy(cfg.ttf_blob, config.ttf_blob, (ulong)(cfg.ttf_size));
				cfg.ttf_data_owned_by_atlas = (byte) (1);
			}

			atlas.font_num++;
			return font;
		}

		public static nk_font nk_font_atlas_add_from_memory(nk_font_atlas atlas, void* memory, ulong size, float height,
			nk_font_config config)
		{
			nk_font_config cfg = new nk_font_config();
			if (((((((atlas == null))) || (memory == null)) || (size == 0)))) return null;
			cfg = (nk_font_config) ((config != null) ? config : nk_font_config_((float) (height)));
			cfg.ttf_blob = memory;
			cfg.ttf_size = (ulong) (size);
			cfg.size = (float) (height);
			cfg.ttf_data_owned_by_atlas = (byte) (0);
			return nk_font_atlas_add(atlas, cfg);
		}

		public static nk_font nk_font_atlas_add_compressed(nk_font_atlas atlas, void* compressed_data, ulong compressed_size,
			float height, nk_font_config config)
		{
			uint decompressed_size;
			void* decompressed_data;
			nk_font_config cfg = new nk_font_config();
			if ((((((atlas == null) || (compressed_data == null)))))) return null;
			decompressed_size = (uint) (nk_decompress_length((byte*) (compressed_data)));
			decompressed_data = CRuntime.malloc((ulong) (decompressed_size));
			if (decompressed_data == null) return null;
			nk_decompress((byte*) (decompressed_data), (byte*) (compressed_data), (uint) (compressed_size));
			cfg = (nk_font_config) ((config != null) ? config : nk_font_config_((float) (height)));
			cfg.ttf_blob = decompressed_data;
			cfg.ttf_size = (ulong) (decompressed_size);
			cfg.size = (float) (height);
			cfg.ttf_data_owned_by_atlas = (byte) (1);
			return nk_font_atlas_add(atlas, cfg);
		}

		public static nk_font nk_font_atlas_add_compressed_base85(nk_font_atlas atlas, char* data_base85, float height,
			nk_font_config config)
		{
			int compressed_size;
			void* compressed_data;
			if ((((((atlas == null) || (data_base85 == null)))))) return null;
			compressed_size = (int) (((nk_strlen(data_base85) + 4)/5)*4);
			compressed_data = CRuntime.malloc((ulong) (compressed_size));
			if (compressed_data == null) return null;
			nk_decode_85((byte*) (compressed_data), (byte*) (data_base85));
			nk_font font = nk_font_atlas_add_compressed(atlas, compressed_data, (ulong) (compressed_size), (float) (height),
				config);
			CRuntime.free(compressed_data);
			return font;
		}

		public static void* nk_font_atlas_bake(nk_font_atlas atlas, ref int width, ref int height, int fmt)
		{
			int i = (int) (0);
			void* tmp = null;
			ulong tmp_size;
			ulong img_size;
			nk_font font_iter;
			nk_font_baker* baker;
			if (((((((atlas == null) || (width == null)) || (height == null)))))) return null;
			if (atlas.font_num == 0) atlas.default_font = nk_font_atlas_add_default(atlas, (float) (13.0f), null);
			if (atlas.font_num == 0) return null;
			nk_font_baker_memory(&tmp_size, ref atlas.glyph_count, atlas.config, (int) (atlas.font_num));
			tmp = CRuntime.malloc((ulong) (tmp_size));
			if (tmp == null) goto failed;
			baker = nk_font_baker_(tmp, (int) (atlas.glyph_count), (int) (atlas.font_num));
			atlas.glyphs =
				(nk_font_glyph*) (CRuntime.malloc((ulong) ((ulong) sizeof (nk_font_glyph)*(ulong) (atlas.glyph_count))));
			if (atlas.glyphs == null) goto failed;
			atlas.custom.w = (short) ((90*2) + 1);
			atlas.custom.h = (short) (27 + 1);
			if (
				nk_font_bake_pack(baker, &img_size, ref width, ref height, ref atlas.custom, atlas.config, (int) (atlas.font_num)) ==
				0) goto failed;
			atlas.pixel = CRuntime.malloc((ulong) (img_size));
			if (atlas.pixel == null) goto failed;
			nk_font_bake(baker, atlas.pixel, (int) (width), (int) (height), atlas.glyphs, (int) (atlas.glyph_count), atlas.config,
				(int) (atlas.font_num));
			fixed (char* ptr = nk_custom_cursor_data)
			{
				nk_font_bake_custom_data(atlas.pixel, (int) (width), (int) (height), (nk_recti) (atlas.custom), ptr, (int) (90),
					(int) (27), ('.'), ('X'));
			}
			if ((fmt) == (NK_FONT_ATLAS_RGBA32))
			{
				void* img_rgba = CRuntime.malloc((ulong) (width*height*4));
				if (img_rgba == null) goto failed;
				nk_font_bake_convert(img_rgba, (int) (width), (int) (height), atlas.pixel);
				CRuntime.free(atlas.pixel);
				atlas.pixel = img_rgba;
			}

			atlas.tex_width = (int) (width);
			atlas.tex_height = (int) (height);
			for (font_iter = atlas.fonts; font_iter != null; font_iter = font_iter.next)
			{
				nk_font font = font_iter;
				nk_font_config config = font.config;
				nk_font_init(font, (float) (config.size), config.fallback_glyph, atlas.glyphs, config.font,
					(nk_handle) (nk_handle_ptr(null)));
			}
			for (i = (int) (0); (i) < (NK_CURSOR_COUNT); ++i)
			{
				nk_cursor cursor = atlas.cursors[i];
				cursor.img.w = ((ushort) (width));
				cursor.img.h = ((ushort) (height));
				cursor.img.region[0] = ((ushort) (atlas.custom.x + nk_cursor_data[i, 0].x));
				cursor.img.region[1] = ((ushort) (atlas.custom.y + nk_cursor_data[i, 0].y));
				cursor.img.region[2] = ((ushort) (nk_cursor_data[i, 1].x));
				cursor.img.region[3] = ((ushort) (nk_cursor_data[i, 1].y));
				cursor.size = (nk_vec2) (nk_cursor_data[i, 1]);
				cursor.offset = (nk_vec2) (nk_cursor_data[i, 2]);
			}
			CRuntime.free(tmp);
			return atlas.pixel;
			failed:
			;
			if ((tmp) != null) CRuntime.free(tmp);
			if ((atlas.glyphs) != null)
			{
				CRuntime.free(atlas.glyphs);
				atlas.glyphs = null;
			}

			if ((atlas.pixel) != null)
			{
				CRuntime.free(atlas.pixel);
				atlas.pixel = null;
			}

			return null;
		}

		public static void nk_font_atlas_end(nk_font_atlas atlas, nk_handle texture, nk_draw_null_texture* _null_)
		{
			int i = (int) (0);
			nk_font font_iter;
			if (atlas == null)
			{
				if (_null_ == null) return;
				_null_->texture = (nk_handle) (texture);
				_null_->uv = (nk_vec2) (nk_vec2_((float) (0.5f), (float) (0.5f)));
			}

			if ((_null_) != null)
			{
				_null_->texture = (nk_handle) (texture);
				_null_->uv.x = (float) ((atlas.custom.x + 0.5f)/(float) (atlas.tex_width));
				_null_->uv.y = (float) ((atlas.custom.y + 0.5f)/(float) (atlas.tex_height));
			}

			for (font_iter = atlas.fonts; font_iter != null; font_iter = font_iter.next)
			{
				font_iter.texture = (nk_handle) (texture);
				font_iter.handle.texture = (nk_handle) (texture);
			}
			for (i = (int) (0); (i) < (NK_CURSOR_COUNT); ++i)
			{
				atlas.cursors[i].img.handle = (nk_handle) (texture);
			}
			CRuntime.free(atlas.pixel);
			atlas.pixel = null;
			atlas.tex_width = (int) (0);
			atlas.tex_height = (int) (0);
			atlas.custom.x = (short) (0);
			atlas.custom.y = (short) (0);
			atlas.custom.w = (short) (0);
			atlas.custom.h = (short) (0);
		}

		public static void nk_font_atlas_cleanup(nk_font_atlas atlas)
		{
			if (((atlas == null))) return;
			if ((atlas.config) != null)
			{
				nk_font_config iter;
				for (iter = atlas.config; iter != null; iter = iter.next)
				{
					nk_font_config i;
					for (i = iter.n; i != iter; i = i.n)
					{
						CRuntime.free(i.ttf_blob);
						i.ttf_blob = null;
					}
					CRuntime.free(iter.ttf_blob);
					iter.ttf_blob = null;
				}
			}

		}

		public static void nk_font_atlas_clear(nk_font_atlas atlas)
		{
			if (((atlas == null))) return;
			if ((atlas.config) != null)
			{
				nk_font_config iter;
				nk_font_config next;
				for (iter = atlas.config; iter != null; iter = next)
				{
					nk_font_config i;
					nk_font_config n;
					for (i = iter.n; i != iter; i = n)
					{
						n = i.n;
						if ((i.ttf_blob) != null) CRuntime.free(i.ttf_blob);
					}
					next = iter.next;
					if ((i.ttf_blob) != null) CRuntime.free(iter.ttf_blob);
				}
				atlas.config = null;
			}

			if ((atlas.fonts) != null)
			{
				nk_font iter;
				nk_font next;
				for (iter = atlas.fonts; iter != null; iter = next)
				{
					next = iter.next;
				}
				atlas.fonts = null;
			}

			if ((atlas.glyphs) != null) CRuntime.free(atlas.glyphs);

		}

		public static void nk_input_begin(nk_context ctx)
		{
			int i;
			nk_input _in_;
			if (ctx == null) return;
			_in_ = ctx.input;
			for (i = (int) (0); (i) < (NK_BUTTON_MAX); ++i)
			{
				((nk_mouse_button*) _in_.mouse.buttons + i)->clicked = (uint) (0);
			}
			_in_.keyboard.text_len = (int) (0);
			_in_.mouse.scroll_delta = (nk_vec2) (nk_vec2_((float) (0), (float) (0)));
			_in_.mouse.prev.x = (float) (_in_.mouse.pos.x);
			_in_.mouse.prev.y = (float) (_in_.mouse.pos.y);
			_in_.mouse.delta.x = (float) (0);
			_in_.mouse.delta.y = (float) (0);
			for (i = (int) (0); (i) < (NK_KEY_MAX); i++)
			{
				((nk_key*) _in_.keyboard.keys + i)->clicked = (uint) (0);
			}
		}

		public static void nk_input_end(nk_context ctx)
		{
			nk_input _in_;
			if (ctx == null) return;
			_in_ = ctx.input;
			if ((_in_.mouse.grab) != 0) _in_.mouse.grab = (byte) (0);
			if ((_in_.mouse.ungrab) != 0)
			{
				_in_.mouse.grabbed = (byte) (0);
				_in_.mouse.ungrab = (byte) (0);
				_in_.mouse.grab = (byte) (0);
			}

		}

		public static void nk_input_motion(nk_context ctx, int x, int y)
		{
			nk_input _in_;
			if (ctx == null) return;
			_in_ = ctx.input;
			_in_.mouse.pos.x = ((float) (x));
			_in_.mouse.pos.y = ((float) (y));
			_in_.mouse.delta.x = (float) (_in_.mouse.pos.x - _in_.mouse.prev.x);
			_in_.mouse.delta.y = (float) (_in_.mouse.pos.y - _in_.mouse.prev.y);
		}

		public static void nk_input_key(nk_context ctx, int key, int down)
		{
			nk_input _in_;
			if (ctx == null) return;
			_in_ = ctx.input;
			if (((nk_key*) _in_.keyboard.keys + key)->down != down) ((nk_key*) _in_.keyboard.keys + key)->clicked++;
			((nk_key*) _in_.keyboard.keys + key)->down = (int) (down);
		}

		public static void nk_input_button(nk_context ctx, int id, int x, int y, int down)
		{
			nk_mouse_button* btn;
			nk_input _in_;
			if (ctx == null) return;
			_in_ = ctx.input;
			if ((_in_.mouse.buttons[id].down) == (down)) return;
			btn = (nk_mouse_button*) _in_.mouse.buttons + id;
			btn->clicked_pos.x = ((float) (x));
			btn->clicked_pos.y = ((float) (y));
			btn->down = (int) (down);
			btn->clicked++;
		}

		public static void nk_input_scroll(nk_context ctx, nk_vec2 val)
		{
			if (ctx == null) return;
			ctx.input.mouse.scroll_delta.x += (float) (val.x);
			ctx.input.mouse.scroll_delta.y += (float) (val.y);
		}

		public static void nk_input_glyph(nk_context ctx, char* glyph)
		{
			int len = (int) (0);
			char unicode;
			nk_input _in_;
			if (ctx == null) return;
			_in_ = ctx.input;
			len = (int) (nk_utf_decode(glyph, &unicode, (int) (4)));
			if (((len) != 0) && ((_in_.keyboard.text_len + len) < (16)))
			{
				nk_utf_encode(unicode, (char*) _in_.keyboard.text + _in_.keyboard.text_len, (int) (16 - _in_.keyboard.text_len));
				_in_.keyboard.text_len += (int) (len);
			}

		}

		public static void nk_input_char(nk_context ctx, char c)
		{
			char* glyph = stackalloc char[4];
			if (ctx == null) return;
			glyph[0] = c;
			nk_input_glyph(ctx, glyph);
		}

		public static void nk_input_unicode(nk_context ctx, char unicode)
		{
			char* rune = stackalloc char[4];
			if (ctx == null) return;
			nk_utf_encode(unicode, rune, (int) (4));
			nk_input_glyph(ctx, rune);
		}

		public static int nk_input_has_mouse_click(nk_input i, int id)
		{
			nk_mouse_button* btn;
			if (i == null) return (int) (nk_false);
			btn = (nk_mouse_button*) i.mouse.buttons + id;
			return (int) ((((btn->clicked) != 0) && ((btn->down) == (nk_false))) ? nk_true : nk_false);
		}

		public static int nk_input_has_mouse_click_in_rect(nk_input i, int id, nk_rect b)
		{
			nk_mouse_button* btn;
			if (i == null) return (int) (nk_false);
			btn = (nk_mouse_button*) i.mouse.buttons + id;
			if (
				!((((b.x) <= (btn->clicked_pos.x)) && ((btn->clicked_pos.x) < (b.x + b.w))) &&
				  (((b.y) <= (btn->clicked_pos.y)) && ((btn->clicked_pos.y) < (b.y + b.h))))) return (int) (nk_false);
			return (int) (nk_true);
		}

		public static int nk_input_has_mouse_click_down_in_rect(nk_input i, int id, nk_rect b, int down)
		{
			nk_mouse_button* btn;
			if (i == null) return (int) (nk_false);
			btn = (nk_mouse_button*) i.mouse.buttons + id;
			return
				(int) (((nk_input_has_mouse_click_in_rect(i, (int) (id), (nk_rect) (b))) != 0) && ((btn->down) == (down)) ? 1 : 0);
		}

		public static int nk_input_is_mouse_click_in_rect(nk_input i, int id, nk_rect b)
		{
			nk_mouse_button* btn;
			if (i == null) return (int) (nk_false);
			btn = (nk_mouse_button*) i.mouse.buttons + id;
			return
				(int)
					((((nk_input_has_mouse_click_down_in_rect(i, (int) (id), (nk_rect) (b), (int) (nk_false))) != 0) &&
					  ((btn->clicked) != 0))
						? nk_true
						: nk_false);
		}

		public static int nk_input_is_mouse_click_down_in_rect(nk_input i, int id, nk_rect b, int down)
		{
			nk_mouse_button* btn;
			if (i == null) return (int) (nk_false);
			btn = (nk_mouse_button*) i.mouse.buttons + id;
			return
				(int)
					((((nk_input_has_mouse_click_down_in_rect(i, (int) (id), (nk_rect) (b), (int) (down))) != 0) &&
					  ((btn->clicked) != 0))
						? nk_true
						: nk_false);
		}

		public static int nk_input_any_mouse_click_in_rect(nk_input _in_, nk_rect b)
		{
			int i;
			int down = (int) (0);
			for (i = (int) (0); (i) < (NK_BUTTON_MAX); ++i)
			{
				down = (int) (((down) != 0) || ((nk_input_is_mouse_click_in_rect(_in_, (int) (i), (nk_rect) (b))) != 0) ? 1 : 0);
			}
			return (int) (down);
		}

		public static int nk_input_is_mouse_hovering_rect(nk_input i, nk_rect rect)
		{
			if (i == null) return (int) (nk_false);
			return (((rect.x) <= (i.mouse.pos.x)) && ((i.mouse.pos.x) < (rect.x + rect.w))) &&
			       (((rect.y) <= (i.mouse.pos.y)) && ((i.mouse.pos.y) < (rect.y + rect.h)))
				? 1
				: 0;
		}

		public static int nk_input_is_mouse_prev_hovering_rect(nk_input i, nk_rect rect)
		{
			if (i == null) return (int) (nk_false);
			return (((rect.x) <= (i.mouse.prev.x)) && ((i.mouse.prev.x) < (rect.x + rect.w))) &&
			       (((rect.y) <= (i.mouse.prev.y)) && ((i.mouse.prev.y) < (rect.y + rect.h)))
				? 1
				: 0;
		}

		public static int nk_input_mouse_clicked(nk_input i, int id, nk_rect rect)
		{
			if (i == null) return (int) (nk_false);
			if (nk_input_is_mouse_hovering_rect(i, (nk_rect) (rect)) == 0) return (int) (nk_false);
			return (int) (nk_input_is_mouse_click_in_rect(i, (int) (id), (nk_rect) (rect)));
		}

		public static int nk_input_is_mouse_down(nk_input i, int id)
		{
			if (i == null) return (int) (nk_false);
			return (int) (i.mouse.buttons[id].down);
		}

		public static int nk_input_is_mouse_pressed(nk_input i, int id)
		{
			nk_mouse_button* b;
			if (i == null) return (int) (nk_false);
			b = (nk_mouse_button*) i.mouse.buttons + id;
			if (((b->down) != 0) && ((b->clicked) != 0)) return (int) (nk_true);
			return (int) (nk_false);
		}

		public static int nk_input_is_mouse_released(nk_input i, int id)
		{
			if (i == null) return (int) (nk_false);
			return ((i.mouse.buttons[id].down == 0) && ((i.mouse.buttons[id].clicked) != 0)) ? 1 : 0;
		}

		public static int nk_input_is_key_pressed(nk_input i, int key)
		{
			nk_key* k;
			if (i == null) return (int) (nk_false);
			k = (nk_key*) i.keyboard.keys + key;
			if ((((k->down) != 0) && ((k->clicked) != 0)) || ((k->down == 0) && ((k->clicked) >= (2)))) return (int) (nk_true);
			return (int) (nk_false);
		}

		public static int nk_input_is_key_released(nk_input i, int key)
		{
			nk_key* k;
			if (i == null) return (int) (nk_false);
			k = (nk_key*) i.keyboard.keys + key;
			if (((k->down == 0) && ((k->clicked) != 0)) || (((k->down) != 0) && ((k->clicked) >= (2)))) return (int) (nk_true);
			return (int) (nk_false);
		}

		public static int nk_input_is_key_down(nk_input i, int key)
		{
			nk_key* k;
			if (i == null) return (int) (nk_false);
			k = (nk_key*) i.keyboard.keys + key;
			if ((k->down) != 0) return (int) (nk_true);
			return (int) (nk_false);
		}

		public static float nk_textedit_get_width(nk_text_edit edit, int line_start, int char_id, nk_user_font font)
		{
			int len = (int) (0);
			char unicode = (char) 0;
			char* str = nk_str_at_const(edit._string_, (int) (line_start + char_id), &unicode, &len);
			return (float) (font.width((nk_handle) (font.userdata), (float) (font.height), str, (int) (len)));
		}

		public static void nk_textedit_layout_row(nk_text_edit_row* r, nk_text_edit edit, int line_start_id, float row_height,
			nk_user_font font)
		{
			int l;
			int glyphs = (int) (0);
			char unicode;
			char* remaining;
			int len = (int) (nk_str_len_char(edit._string_));
			char* end = nk_str_get_const(edit._string_) + len;
			char* text = nk_str_at_const(edit._string_, (int) (line_start_id), &unicode, &l);
			nk_vec2 size =
				(nk_vec2)
					(nk_text_calculate_text_bounds(font, text, (int) (end - text), (float) (row_height), &remaining, null, &glyphs,
						(int) (NK_STOP_ON_NEW_LINE)));
			r->x0 = (float) (0.0f);
			r->x1 = (float) (size.x);
			r->baseline_y_delta = (float) (size.y);
			r->ymin = (float) (0.0f);
			r->ymax = (float) (size.y);
			r->num_chars = (int) (glyphs);
		}

		public static int nk_textedit_locate_coord(nk_text_edit edit, float x, float y, nk_user_font font, float row_height)
		{
			nk_text_edit_row r = new nk_text_edit_row();
			int n = (int) (edit._string_.len);
			float base_y = (float) (0);
			float prev_x;
			int i = (int) (0);
			int k;
			r.x0 = (float) (r.x1 = (float) (0));
			r.ymin = (float) (r.ymax = (float) (0));
			r.num_chars = (int) (0);
			while ((i) < (n))
			{
				nk_textedit_layout_row(&r, edit, (int) (i), (float) (row_height), font);
				if (r.num_chars <= 0) return (int) (n);
				if (((i) == (0)) && ((y) < (base_y + r.ymin))) return (int) (0);
				if ((y) < (base_y + r.ymax)) break;
				i += (int) (r.num_chars);
				base_y += (float) (r.baseline_y_delta);
			}
			if ((i) >= (n)) return (int) (n);
			if ((x) < (r.x0)) return (int) (i);
			if ((x) < (r.x1))
			{
				k = (int) (i);
				prev_x = (float) (r.x0);
				for (i = (int) (0); (i) < (r.num_chars); ++i)
				{
					float w = (float) (nk_textedit_get_width(edit, (int) (k), (int) (i), font));
					if ((x) < (prev_x + w))
					{
						if ((x) < (prev_x + w/2)) return (int) (k + i);
						else return (int) (k + i + 1);
					}
					prev_x += (float) (w);
				}
			}

			if ((nk_str_rune_at(edit._string_, (int) (i + r.num_chars - 1))) == ('\n')) return (int) (i + r.num_chars - 1);
			else return (int) (i + r.num_chars);
		}

		public static void nk_textedit_click(nk_text_edit state, float x, float y, nk_user_font font, float row_height)
		{
			state.cursor = (int) (nk_textedit_locate_coord(state, (float) (x), (float) (y), font, (float) (row_height)));
			state.select_start = (int) (state.cursor);
			state.select_end = (int) (state.cursor);
			state.has_preferred_x = (byte) (0);
		}

		public static void nk_textedit_drag(nk_text_edit state, float x, float y, nk_user_font font, float row_height)
		{
			int p = (int) (nk_textedit_locate_coord(state, (float) (x), (float) (y), font, (float) (row_height)));
			if ((state.select_start) == (state.select_end)) state.select_start = (int) (state.cursor);
			state.cursor = (int) (state.select_end = (int) (p));
		}

		public static void nk_textedit_find_charpos(nk_text_find* find, nk_text_edit state, int n, int single_line,
			nk_user_font font, float row_height)
		{
			nk_text_edit_row r = new nk_text_edit_row();
			int prev_start = (int) (0);
			int z = (int) (state._string_.len);
			int i = (int) (0);
			int first;
			nk_zero(&r, (ulong) (sizeof (nk_text_edit_row)));
			if ((n) == (z))
			{
				nk_textedit_layout_row(&r, state, (int) (0), (float) (row_height), font);
				if ((single_line) != 0)
				{
					find->first_char = (int) (0);
					find->length = (int) (z);
				}
				else
				{
					while ((i) < (z))
					{
						prev_start = (int) (i);
						i += (int) (r.num_chars);
						nk_textedit_layout_row(&r, state, (int) (i), (float) (row_height), font);
					}
					find->first_char = (int) (i);
					find->length = (int) (r.num_chars);
				}
				find->x = (float) (r.x1);
				find->y = (float) (r.ymin);
				find->height = (float) (r.ymax - r.ymin);
				find->prev_first = (int) (prev_start);
				return;
			}

			find->y = (float) (0);
			for (;;)
			{
				nk_textedit_layout_row(&r, state, (int) (i), (float) (row_height), font);
				if ((n) < (i + r.num_chars)) break;
				prev_start = (int) (i);
				i += (int) (r.num_chars);
				find->y += (float) (r.baseline_y_delta);
			}
			find->first_char = (int) (first = (int) (i));
			find->length = (int) (r.num_chars);
			find->height = (float) (r.ymax - r.ymin);
			find->prev_first = (int) (prev_start);
			find->x = (float) (r.x0);
			for (i = (int) (0); (first + i) < (n); ++i)
			{
				find->x += (float) (nk_textedit_get_width(state, (int) (first), (int) (i), font));
			}
		}

		public static void nk_textedit_clamp(nk_text_edit state)
		{
			int n = (int) (state._string_.len);
			if (((state).select_start != (state).select_end))
			{
				if ((state.select_start) > (n)) state.select_start = (int) (n);
				if ((state.select_end) > (n)) state.select_end = (int) (n);
				if ((state.select_start) == (state.select_end)) state.cursor = (int) (state.select_start);
			}

			if ((state.cursor) > (n)) state.cursor = (int) (n);
		}

		public static void nk_textedit_delete(nk_text_edit state, int where, int len)
		{
			nk_textedit_makeundo_delete(state, (int) (where), (int) (len));
			nk_str_delete_runes(state._string_, (int) (where), (int) (len));
			state.has_preferred_x = (byte) (0);
		}

		public static void nk_textedit_delete_selection(nk_text_edit state)
		{
			nk_textedit_clamp(state);
			if (((state).select_start != (state).select_end))
			{
				if ((state.select_start) < (state.select_end))
				{
					nk_textedit_delete(state, (int) (state.select_start), (int) (state.select_end - state.select_start));
					state.select_end = (int) (state.cursor = (int) (state.select_start));
				}
				else
				{
					nk_textedit_delete(state, (int) (state.select_end), (int) (state.select_start - state.select_end));
					state.select_start = (int) (state.cursor = (int) (state.select_end));
				}
				state.has_preferred_x = (byte) (0);
			}

		}

		public static void nk_textedit_sortselection(nk_text_edit state)
		{
			if ((state.select_end) < (state.select_start))
			{
				int temp = (int) (state.select_end);
				state.select_end = (int) (state.select_start);
				state.select_start = (int) (temp);
			}

		}

		public static void nk_textedit_move_to_first(nk_text_edit state)
		{
			if (((state).select_start != (state).select_end))
			{
				nk_textedit_sortselection(state);
				state.cursor = (int) (state.select_start);
				state.select_end = (int) (state.select_start);
				state.has_preferred_x = (byte) (0);
			}

		}

		public static void nk_textedit_move_to_last(nk_text_edit state)
		{
			if (((state).select_start != (state).select_end))
			{
				nk_textedit_sortselection(state);
				nk_textedit_clamp(state);
				state.cursor = (int) (state.select_end);
				state.select_start = (int) (state.select_end);
				state.has_preferred_x = (byte) (0);
			}

		}

		public static int nk_is_word_boundary(nk_text_edit state, int idx)
		{
			int len;
			char c;
			if (idx <= 0) return (int) (1);
			if (nk_str_at_rune(state._string_, (int) (idx), &c, &len) == null) return (int) (1);
			return
				(int)
					((((((((((((c) == (' ')) || ((c) == ('	'))) || ((c) == (0x3000))) || ((c) == (','))) || ((c) == (';'))) ||
					      ((c) == ('('))) || ((c) == (')')) || ((c) == ('{'))) || ((c) == ('}'))) || ((c) == ('['))) || ((c) == (']'))) ||
					 ((c) == ('|'))
						? 1
						: 0);
		}

		public static int nk_textedit_move_to_word_previous(nk_text_edit state)
		{
			int c = (int) (state.cursor - 1);
			while (((c) >= (0)) && (nk_is_word_boundary(state, (int) (c)) == 0))
			{
				--c;
			}
			if ((c) < (0)) c = (int) (0);
			return (int) (c);
		}

		public static int nk_textedit_move_to_word_next(nk_text_edit state)
		{
			int len = (int) (state._string_.len);
			int c = (int) (state.cursor + 1);
			while (((c) < (len)) && (nk_is_word_boundary(state, (int) (c)) == 0))
			{
				++c;
			}
			if ((c) > (len)) c = (int) (len);
			return (int) (c);
		}

		public static void nk_textedit_prep_selection_at_cursor(nk_text_edit state)
		{
			if (!((state).select_start != (state).select_end))
				state.select_start = (int) (state.select_end = (int) (state.cursor));
			else state.cursor = (int) (state.select_end);
		}

		public static int nk_textedit_cut(nk_text_edit state)
		{
			if ((state.mode) == (NK_TEXT_EDIT_MODE_VIEW)) return (int) (0);
			if (((state).select_start != (state).select_end))
			{
				nk_textedit_delete_selection(state);
				state.has_preferred_x = (byte) (0);
				return (int) (1);
			}

			return (int) (0);
		}

		public static int nk_textedit_paste(nk_text_edit state, char* ctext, int len)
		{
			int glyphs;
			char* text = ctext;
			if ((state.mode) == (NK_TEXT_EDIT_MODE_VIEW)) return (int) (0);
			nk_textedit_clamp(state);
			nk_textedit_delete_selection(state);
			glyphs = (int) (nk_utf_len(ctext, (int) (len)));
			if ((nk_str_insert_text_char(state._string_, (int) (state.cursor), text, (int) (len))) != 0)
			{
				nk_textedit_makeundo_insert(state, (int) (state.cursor), (int) (glyphs));
				state.cursor += (int) (len);
				state.has_preferred_x = (byte) (0);
				return (int) (1);
			}

			if ((state.undo.undo_point) != 0) --state.undo.undo_point;
			return (int) (0);
		}

		public static void nk_textedit_text(nk_text_edit state, char* text, int total_len)
		{
			char unicode;
			int glyph_len;
			int text_len = (int) (0);
			if (((text == null) || (total_len == 0)) || ((state.mode) == (NK_TEXT_EDIT_MODE_VIEW))) return;
			glyph_len = (int) (nk_utf_decode(text, &unicode, (int) (total_len)));
			while (((text_len) < (total_len)) && ((glyph_len) != 0))
			{
				if ((unicode) == (127)) goto next;
				if (((unicode) == ('\n')) && ((state.single_line) != 0)) goto next;
				if (((state.filter) != null) && (state.filter(state, unicode) == 0)) goto next;
				if ((!((state).select_start != (state).select_end)) && ((state.cursor) < (state._string_.len)))
				{
					if ((state.mode) == (NK_TEXT_EDIT_MODE_REPLACE))
					{
						nk_textedit_makeundo_replace(state, (int) (state.cursor), (int) (1), (int) (1));
						nk_str_delete_runes(state._string_, (int) (state.cursor), (int) (1));
					}
					if ((nk_str_insert_text_utf8(state._string_, (int) (state.cursor), text + text_len, (int) (1))) != 0)
					{
						++state.cursor;
						state.has_preferred_x = (byte) (0);
					}
				}
				else
				{
					nk_textedit_delete_selection(state);
					if ((nk_str_insert_text_utf8(state._string_, (int) (state.cursor), text + text_len, (int) (1))) != 0)
					{
						nk_textedit_makeundo_insert(state, (int) (state.cursor), (int) (1));
						++state.cursor;
						state.has_preferred_x = (byte) (0);
					}
				}
				next:
				;
				text_len += (int) (glyph_len);
				glyph_len = (int) (nk_utf_decode(text + text_len, &unicode, (int) (total_len - text_len)));
			}
		}

		public static void nk_textedit_key(nk_text_edit state, int key, int shift_mod, nk_user_font font, float row_height)
		{
			retry:
			;
			switch (key)
			{
				case NK_KEY_NONE:
				case NK_KEY_CTRL:
				case NK_KEY_ENTER:
				case NK_KEY_SHIFT:
				case NK_KEY_TAB:
				case NK_KEY_COPY:
				case NK_KEY_CUT:
				case NK_KEY_PASTE:
				case NK_KEY_MAX:
				default:
					break;
				case NK_KEY_TEXT_UNDO:
					nk_textedit_undo(state);
					state.has_preferred_x = (byte) (0);
					break;
				case NK_KEY_TEXT_REDO:
					nk_textedit_redo(state);
					state.has_preferred_x = (byte) (0);
					break;
				case NK_KEY_TEXT_SELECT_ALL:
					nk_textedit_select_all(state);
					state.has_preferred_x = (byte) (0);
					break;
				case NK_KEY_TEXT_INSERT_MODE:
					if ((state.mode) == (NK_TEXT_EDIT_MODE_VIEW)) state.mode = (byte) (NK_TEXT_EDIT_MODE_INSERT);
					break;
				case NK_KEY_TEXT_REPLACE_MODE:
					if ((state.mode) == (NK_TEXT_EDIT_MODE_VIEW)) state.mode = (byte) (NK_TEXT_EDIT_MODE_REPLACE);
					break;
				case NK_KEY_TEXT_RESET_MODE:
					if (((state.mode) == (NK_TEXT_EDIT_MODE_INSERT)) || ((state.mode) == (NK_TEXT_EDIT_MODE_REPLACE)))
						state.mode = (byte) (NK_TEXT_EDIT_MODE_VIEW);
					break;
				case NK_KEY_LEFT:
					if ((shift_mod) != 0)
					{
						nk_textedit_clamp(state);
						nk_textedit_prep_selection_at_cursor(state);
						if ((state.select_end) > (0)) --state.select_end;
						state.cursor = (int) (state.select_end);
						state.has_preferred_x = (byte) (0);
					}
					else
					{
						if (((state).select_start != (state).select_end)) nk_textedit_move_to_first(state);
						else if ((state.cursor) > (0)) --state.cursor;
						state.has_preferred_x = (byte) (0);
					}
					break;
				case NK_KEY_RIGHT:
					if ((shift_mod) != 0)
					{
						nk_textedit_prep_selection_at_cursor(state);
						++state.select_end;
						nk_textedit_clamp(state);
						state.cursor = (int) (state.select_end);
						state.has_preferred_x = (byte) (0);
					}
					else
					{
						if (((state).select_start != (state).select_end)) nk_textedit_move_to_last(state);
						else ++state.cursor;
						nk_textedit_clamp(state);
						state.has_preferred_x = (byte) (0);
					}
					break;
				case NK_KEY_TEXT_WORD_LEFT:
					if ((shift_mod) != 0)
					{
						if (!((state).select_start != (state).select_end)) nk_textedit_prep_selection_at_cursor(state);
						state.cursor = (int) (nk_textedit_move_to_word_previous(state));
						state.select_end = (int) (state.cursor);
						nk_textedit_clamp(state);
					}
					else
					{
						if (((state).select_start != (state).select_end)) nk_textedit_move_to_first(state);
						else
						{
							state.cursor = (int) (nk_textedit_move_to_word_previous(state));
							nk_textedit_clamp(state);
						}
					}
					break;
				case NK_KEY_TEXT_WORD_RIGHT:
					if ((shift_mod) != 0)
					{
						if (!((state).select_start != (state).select_end)) nk_textedit_prep_selection_at_cursor(state);
						state.cursor = (int) (nk_textedit_move_to_word_next(state));
						state.select_end = (int) (state.cursor);
						nk_textedit_clamp(state);
					}
					else
					{
						if (((state).select_start != (state).select_end)) nk_textedit_move_to_last(state);
						else
						{
							state.cursor = (int) (nk_textedit_move_to_word_next(state));
							nk_textedit_clamp(state);
						}
					}
					break;
				case NK_KEY_DOWN:
				{
					nk_text_find find = new nk_text_find();
					nk_text_edit_row row = new nk_text_edit_row();
					int i;
					int sel = (int) (shift_mod);
					if ((state.single_line) != 0)
					{
						key = (int) (NK_KEY_RIGHT);
						goto retry;
					}
					if ((sel) != 0) nk_textedit_prep_selection_at_cursor(state);
					else if (((state).select_start != (state).select_end)) nk_textedit_move_to_last(state);
					nk_textedit_clamp(state);
					nk_textedit_find_charpos(&find, state, (int) (state.cursor), (int) (state.single_line), font, (float) (row_height));
					if ((find.length) != 0)
					{
						float x;
						float goal_x = (float) ((state.has_preferred_x) != 0 ? state.preferred_x : find.x);
						int start = (int) (find.first_char + find.length);
						state.cursor = (int) (start);
						nk_textedit_layout_row(&row, state, (int) (state.cursor), (float) (row_height), font);
						x = (float) (row.x0);
						for (i = (int) (0); ((i) < (row.num_chars)) && ((x) < (row.x1)); ++i)
						{
							float dx = (float) (nk_textedit_get_width(state, (int) (start), (int) (i), font));
							x += (float) (dx);
							if ((x) > (goal_x)) break;
							++state.cursor;
						}
						nk_textedit_clamp(state);
						state.has_preferred_x = (byte) (1);
						state.preferred_x = (float) (goal_x);
						if ((sel) != 0) state.select_end = (int) (state.cursor);
					}
				}
					break;
				case NK_KEY_UP:
				{
					nk_text_find find = new nk_text_find();
					nk_text_edit_row row = new nk_text_edit_row();
					int i;
					int sel = (int) (shift_mod);
					if ((state.single_line) != 0)
					{
						key = (int) (NK_KEY_LEFT);
						goto retry;
					}
					if ((sel) != 0) nk_textedit_prep_selection_at_cursor(state);
					else if (((state).select_start != (state).select_end)) nk_textedit_move_to_first(state);
					nk_textedit_clamp(state);
					nk_textedit_find_charpos(&find, state, (int) (state.cursor), (int) (state.single_line), font, (float) (row_height));
					if (find.prev_first != find.first_char)
					{
						float x;
						float goal_x = (float) ((state.has_preferred_x) != 0 ? state.preferred_x : find.x);
						state.cursor = (int) (find.prev_first);
						nk_textedit_layout_row(&row, state, (int) (state.cursor), (float) (row_height), font);
						x = (float) (row.x0);
						for (i = (int) (0); ((i) < (row.num_chars)) && ((x) < (row.x1)); ++i)
						{
							float dx = (float) (nk_textedit_get_width(state, (int) (find.prev_first), (int) (i), font));
							x += (float) (dx);
							if ((x) > (goal_x)) break;
							++state.cursor;
						}
						nk_textedit_clamp(state);
						state.has_preferred_x = (byte) (1);
						state.preferred_x = (float) (goal_x);
						if ((sel) != 0) state.select_end = (int) (state.cursor);
					}
				}
					break;
				case NK_KEY_DEL:
					if ((state.mode) == (NK_TEXT_EDIT_MODE_VIEW)) break;
					if (((state).select_start != (state).select_end)) nk_textedit_delete_selection(state);
					else
					{
						int n = (int) (state._string_.len);
						if ((state.cursor) < (n)) nk_textedit_delete(state, (int) (state.cursor), (int) (1));
					}
					state.has_preferred_x = (byte) (0);
					break;
				case NK_KEY_BACKSPACE:
					if ((state.mode) == (NK_TEXT_EDIT_MODE_VIEW)) break;
					if (((state).select_start != (state).select_end)) nk_textedit_delete_selection(state);
					else
					{
						nk_textedit_clamp(state);
						if ((state.cursor) > (0))
						{
							nk_textedit_delete(state, (int) (state.cursor - 1), (int) (1));
							--state.cursor;
						}
					}
					state.has_preferred_x = (byte) (0);
					break;
				case NK_KEY_TEXT_START:
					if ((shift_mod) != 0)
					{
						nk_textedit_prep_selection_at_cursor(state);
						state.cursor = (int) (state.select_end = (int) (0));
						state.has_preferred_x = (byte) (0);
					}
					else
					{
						state.cursor = (int) (state.select_start = (int) (state.select_end = (int) (0)));
						state.has_preferred_x = (byte) (0);
					}
					break;
				case NK_KEY_TEXT_END:
					if ((shift_mod) != 0)
					{
						nk_textedit_prep_selection_at_cursor(state);
						state.cursor = (int) (state.select_end = (int) (state._string_.len));
						state.has_preferred_x = (byte) (0);
					}
					else
					{
						state.cursor = (int) (state._string_.len);
						state.select_start = (int) (state.select_end = (int) (0));
						state.has_preferred_x = (byte) (0);
					}
					break;
				case NK_KEY_TEXT_LINE_START:
				{
					if ((shift_mod) != 0)
					{
						nk_text_find find = new nk_text_find();
						nk_textedit_clamp(state);
						nk_textedit_prep_selection_at_cursor(state);
						if (((state._string_.len) != 0) && ((state.cursor) == (state._string_.len))) --state.cursor;
						nk_textedit_find_charpos(&find, state, (int) (state.cursor), (int) (state.single_line), font, (float) (row_height));
						state.cursor = (int) (state.select_end = (int) (find.first_char));
						state.has_preferred_x = (byte) (0);
					}
					else
					{
						nk_text_find find = new nk_text_find();
						if (((state._string_.len) != 0) && ((state.cursor) == (state._string_.len))) --state.cursor;
						nk_textedit_clamp(state);
						nk_textedit_move_to_first(state);
						nk_textedit_find_charpos(&find, state, (int) (state.cursor), (int) (state.single_line), font, (float) (row_height));
						state.cursor = (int) (find.first_char);
						state.has_preferred_x = (byte) (0);
					}
				}
					break;
				case NK_KEY_TEXT_LINE_END:
				{
					if ((shift_mod) != 0)
					{
						nk_text_find find = new nk_text_find();
						nk_textedit_clamp(state);
						nk_textedit_prep_selection_at_cursor(state);
						nk_textedit_find_charpos(&find, state, (int) (state.cursor), (int) (state.single_line), font, (float) (row_height));
						state.has_preferred_x = (byte) (0);
						state.cursor = (int) (find.first_char + find.length);
						if (((find.length) > (0)) && ((nk_str_rune_at(state._string_, (int) (state.cursor - 1))) == ('\n')))
							--state.cursor;
						state.select_end = (int) (state.cursor);
					}
					else
					{
						nk_text_find find = new nk_text_find();
						nk_textedit_clamp(state);
						nk_textedit_move_to_first(state);
						nk_textedit_find_charpos(&find, state, (int) (state.cursor), (int) (state.single_line), font, (float) (row_height));
						state.has_preferred_x = (byte) (0);
						state.cursor = (int) (find.first_char + find.length);
						if (((find.length) > (0)) && ((nk_str_rune_at(state._string_, (int) (state.cursor - 1))) == ('\n')))
							--state.cursor;
					}
				}
					break;
			}

		}

		public static void nk_textedit_flush_redo(nk_text_undo_state state)
		{
			state.redo_point = (short) (99);
			state.redo_char_point = (short) (999);
		}

		public static void nk_textedit_discard_undo(nk_text_undo_state state)
		{
			if ((state.undo_point) > (0))
			{
				if ((state.undo_rec[0].char_storage) >= (0))
				{
					int n = (int) (state.undo_rec[0].insert_length);
					int i;
					state.undo_char_point = ((short) (state.undo_char_point - n));
					nk_memcopy(state.undo_char, (char*) (char*) state.undo_char + n,
						(ulong) ((ulong) (state.undo_char_point)*sizeof (uint)));
					for (i = (int) (0); (i) < (state.undo_point); ++i)
					{
						if ((((nk_text_undo_record*) state.undo_rec + i)->char_storage) >= (0))
							((nk_text_undo_record*) state.undo_rec + i)->char_storage =
								((short) (((nk_text_undo_record*) state.undo_rec + i)->char_storage - n));
					}
				}
				--state.undo_point;
				nk_memcopy(state.undo_rec, (nk_text_undo_record*) state.undo_rec + 1,
					(ulong) ((ulong) (state.undo_point)*(ulong) sizeof (nk_text_undo_record)));
			}

		}

		public static void nk_textedit_discard_redo(nk_text_undo_state state)
		{
			ulong num;
			int k = (int) (99 - 1);
			if (state.redo_point <= k)
			{
				if ((state.undo_rec[k].char_storage) >= (0))
				{
					int n = (int) (state.undo_rec[k].insert_length);
					int i;
					state.redo_char_point = ((short) (state.redo_char_point + n));
					num = ((ulong) (999 - state.redo_char_point));
					nk_memcopy((char*) state.undo_char + state.redo_char_point, (char*) state.undo_char + state.redo_char_point - n,
						(ulong) (num*sizeof (char)));
					for (i = (int) (state.redo_point); (i) < (k); ++i)
					{
						if ((((nk_text_undo_record*) state.undo_rec + i)->char_storage) >= (0))
						{
							((nk_text_undo_record*) state.undo_rec + i)->char_storage =
								((short) (((nk_text_undo_record*) state.undo_rec + i)->char_storage + n));
						}
					}
				}
				++state.redo_point;
				num = ((ulong) (99 - state.redo_point));
				if ((num) != 0)
					nk_memcopy((nk_text_undo_record*) state.undo_rec + state.redo_point - 1,
						(nk_text_undo_record*) state.undo_rec + state.redo_point, (ulong) (num*(ulong) sizeof (nk_text_undo_record)));
			}

		}

		public static nk_text_undo_record* nk_textedit_create_undo_record(nk_text_undo_state state, int numchars)
		{
			nk_textedit_flush_redo(state);
			if ((state.undo_point) == (99)) nk_textedit_discard_undo(state);
			if ((numchars) > (999))
			{
				state.undo_point = (short) (0);
				state.undo_char_point = (short) (0);
				return null;
			}

			while ((state.undo_char_point + numchars) > (999))
			{
				nk_textedit_discard_undo(state);
			}
			return (nk_text_undo_record*) state.undo_rec + (state.undo_point++);
		}

		public static char* nk_textedit_createundo(nk_text_undo_state state, int pos, int insert_len, int delete_len)
		{
			nk_text_undo_record* r = nk_textedit_create_undo_record(state, (int) (insert_len));
			if ((r) == (null)) return null;
			r->where = (int) (pos);
			r->insert_length = ((short) (insert_len));
			r->delete_length = ((short) (delete_len));
			if ((insert_len) == (0))
			{
				r->char_storage = (short) (-1);
				return null;
			}
			else
			{
				r->char_storage = (short) (state.undo_char_point);
				state.undo_char_point = ((short) (state.undo_char_point + insert_len));
				return (char*) state.undo_char + r->char_storage;
			}

		}

		public static void nk_textedit_undo(nk_text_edit state)
		{
			nk_text_undo_state s = state.undo;
			nk_text_undo_record u = new nk_text_undo_record();
			nk_text_undo_record* r;
			if ((s.undo_point) == (0)) return;
			u = (nk_text_undo_record) (s.undo_rec[s.undo_point - 1]);
			r = (nk_text_undo_record*) s.undo_rec + s.redo_point - 1;
			r->char_storage = (short) (-1);
			r->insert_length = (short) (u.delete_length);
			r->delete_length = (short) (u.insert_length);
			r->where = (int) (u.where);
			if ((u.delete_length) != 0)
			{
				if ((s.undo_char_point + u.delete_length) >= (999))
				{
					r->insert_length = (short) (0);
				}
				else
				{
					int i;
					while ((s.undo_char_point + u.delete_length) > (s.redo_char_point))
					{
						nk_textedit_discard_redo(s);
						if ((s.redo_point) == (99)) return;
					}
					r = (nk_text_undo_record*) s.undo_rec + s.redo_point - 1;
					r->char_storage = ((short) (s.redo_char_point - u.delete_length));
					s.redo_char_point = ((short) (s.redo_char_point - u.delete_length));
					for (i = (int) (0); (i) < (u.delete_length); ++i)
					{
						s.undo_char[r->char_storage + i] = (char) (nk_str_rune_at(state._string_, (int) (u.where + i)));
					}
				}
				nk_str_delete_runes(state._string_, (int) (u.where), (int) (u.delete_length));
			}

			if ((u.insert_length) != 0)
			{
				nk_str_insert_text_runes(state._string_, (int) (u.where), (char*) s.undo_char + u.char_storage,
					(int) (u.insert_length));
				s.undo_char_point = ((short) (s.undo_char_point - u.insert_length));
			}

			state.cursor = (int) ((short) (u.where + u.insert_length));
			s.undo_point--;
			s.redo_point--;
		}

		public static void nk_textedit_redo(nk_text_edit state)
		{
			nk_text_undo_state s = state.undo;
			nk_text_undo_record* u;
			nk_text_undo_record r = new nk_text_undo_record();
			if ((s.redo_point) == (99)) return;
			u = (nk_text_undo_record*) s.undo_rec + s.undo_point;
			r = (nk_text_undo_record) (s.undo_rec[s.redo_point]);
			u->delete_length = (short) (r.insert_length);
			u->insert_length = (short) (r.delete_length);
			u->where = (int) (r.where);
			u->char_storage = (short) (-1);
			if ((r.delete_length) != 0)
			{
				if ((s.undo_char_point + u->insert_length) > (s.redo_char_point))
				{
					u->insert_length = (short) (0);
					u->delete_length = (short) (0);
				}
				else
				{
					int i;
					u->char_storage = (short) (s.undo_char_point);
					s.undo_char_point = ((short) (s.undo_char_point + u->insert_length));
					for (i = (int) (0); (i) < (u->insert_length); ++i)
					{
						s.undo_char[u->char_storage + i] = (char) (nk_str_rune_at(state._string_, (int) (u->where + i)));
					}
				}
				nk_str_delete_runes(state._string_, (int) (r.where), (int) (r.delete_length));
			}

			if ((r.insert_length) != 0)
			{
				nk_str_insert_text_runes(state._string_, (int) (r.where), (char*) s.undo_char + r.char_storage,
					(int) (r.insert_length));
			}

			state.cursor = (int) (r.where + r.insert_length);
			s.undo_point++;
			s.redo_point++;
		}

		public static void nk_textedit_makeundo_insert(nk_text_edit state, int where, int length)
		{
			nk_textedit_createundo(state.undo, (int) (where), (int) (0), (int) (length));
		}

		public static void nk_textedit_makeundo_delete(nk_text_edit state, int where, int length)
		{
			int i;
			char* p = nk_textedit_createundo(state.undo, (int) (where), (int) (length), (int) (0));
			if ((p) != null)
			{
				for (i = (int) (0); (i) < (length); ++i)
				{
					p[i] = (char) (nk_str_rune_at(state._string_, (int) (where + i)));
				}
			}

		}

		public static void nk_textedit_makeundo_replace(nk_text_edit state, int where, int old_length, int new_length)
		{
			int i;
			char* p = nk_textedit_createundo(state.undo, (int) (where), (int) (old_length), (int) (new_length));
			if ((p) != null)
			{
				for (i = (int) (0); (i) < (old_length); ++i)
				{
					p[i] = (char) (nk_str_rune_at(state._string_, (int) (where + i)));
				}
			}

		}

		public static void nk_textedit_clear_state(nk_text_edit state, int type, NkPluginFilter filter)
		{
			state.undo.undo_point = (short) (0);
			state.undo.undo_char_point = (short) (0);
			state.undo.redo_point = (short) (99);
			state.undo.redo_char_point = (short) (999);
			state.select_end = (int) (state.select_start = (int) (0));
			state.cursor = (int) (0);
			state.has_preferred_x = (byte) (0);
			state.preferred_x = (float) (0);
			state.cursor_at_end_of_line = (byte) (0);
			state.initialized = (byte) (1);
			state.single_line = ((byte) ((type) == (NK_TEXT_EDIT_SINGLE_LINE) ? 1 : 0));
			state.mode = (byte) (NK_TEXT_EDIT_MODE_VIEW);
			state.filter = filter;
			state.scrollbar = (nk_vec2) (nk_vec2_((float) (0), (float) (0)));
		}

		public static void nk_textedit_init_fixed(nk_text_edit state, void* memory, ulong size)
		{
			if (((state == null) || (memory == null)) || (size == 0)) return;

			nk_textedit_clear_state(state, (int) (NK_TEXT_EDIT_SINGLE_LINE), null);
			nk_str_init_fixed(state._string_, memory, (ulong) (size));
		}

		public static void nk_textedit_init(nk_text_edit state, ulong size)
		{
			if ((state == null)) return;

			nk_textedit_clear_state(state, (int) (NK_TEXT_EDIT_SINGLE_LINE), null);
			nk_str_init(state._string_, (ulong) (size));
		}

		public static void nk_textedit_init_default(nk_text_edit state)
		{
			if (state == null) return;

			nk_textedit_clear_state(state, (int) (NK_TEXT_EDIT_SINGLE_LINE), null);
			nk_str_init_default(state._string_);
		}

		public static void nk_textedit_select_all(nk_text_edit state)
		{
			state.select_start = (int) (0);
			state.select_end = (int) (state._string_.len);
		}

		public static void nk_textedit_free(nk_text_edit state)
		{
			if (state == null) return;
			nk_str_free(state._string_);
		}

		public static void nk_widget_text(nk_command_buffer o, nk_rect b, char* _string_, int len, nk_text* t, uint a,
			nk_user_font f)
		{
			nk_rect label = new nk_rect();
			float text_width;
			if ((o == null) || (t == null)) return;
			b.h = (float) ((b.h) < (2*t->padding.y) ? (2*t->padding.y) : (b.h));
			label.x = (float) (0);
			label.w = (float) (0);
			label.y = (float) (b.y + t->padding.y);
			label.h = (float) ((f.height) < (b.h - 2*t->padding.y) ? (f.height) : (b.h - 2*t->padding.y));
			text_width = (float) (f.width((nk_handle) (f.userdata), (float) (f.height), _string_, (int) (len)));
			text_width += (float) (2.0f*t->padding.x);
			if ((a & NK_TEXT_ALIGN_LEFT) != 0)
			{
				label.x = (float) (b.x + t->padding.x);
				label.w = (float) ((0) < (b.w - 2*t->padding.x) ? (b.w - 2*t->padding.x) : (0));
			}
			else if ((a & NK_TEXT_ALIGN_CENTERED) != 0)
			{
				label.w = (float) ((1) < (2*t->padding.x + text_width) ? (2*t->padding.x + text_width) : (1));
				label.x = (float) (b.x + t->padding.x + ((b.w - 2*t->padding.x) - label.w)/2);
				label.x = (float) ((b.x + t->padding.x) < (label.x) ? (label.x) : (b.x + t->padding.x));
				label.w = (float) ((b.x + b.w) < (label.x + label.w) ? (b.x + b.w) : (label.x + label.w));
				if ((label.w) >= (label.x)) label.w -= (float) (label.x);
			}
			else if ((a & NK_TEXT_ALIGN_RIGHT) != 0)
			{
				label.x =
					(float)
						((b.x + t->padding.x) < ((b.x + b.w) - (2*t->padding.x + text_width))
							? ((b.x + b.w) - (2*t->padding.x + text_width))
							: (b.x + t->padding.x));
				label.w = (float) (text_width + 2*t->padding.x);
			}
			else return;
			if ((a & NK_TEXT_ALIGN_MIDDLE) != 0)
			{
				label.y = (float) (b.y + b.h/2.0f - f.height/2.0f);
				label.h =
					(float) ((b.h/2.0f) < (b.h - (b.h/2.0f + f.height/2.0f)) ? (b.h - (b.h/2.0f + f.height/2.0f)) : (b.h/2.0f));
			}
			else if ((a & NK_TEXT_ALIGN_BOTTOM) != 0)
			{
				label.y = (float) (b.y + b.h - f.height);
				label.h = (float) (f.height);
			}

			nk_draw_text(o, (nk_rect) (label), _string_, (int) (len), f, (nk_color) (t->background), (nk_color) (t->text));
		}

		public static void nk_widget_text_wrap(nk_command_buffer o, nk_rect b, char* _string_, int len, nk_text* t,
			nk_user_font f)
		{
			float width;
			int glyphs = (int) (0);
			int fitting = (int) (0);
			int done = (int) (0);
			nk_rect line = new nk_rect();
			nk_text text = new nk_text();
			uint* seperator = stackalloc uint[1];
			seperator[0] = (uint) (' ');

			if ((o == null) || (t == null)) return;
			text.padding = (nk_vec2) (nk_vec2_((float) (0), (float) (0)));
			text.background = (nk_color) (t->background);
			text.text = (nk_color) (t->text);
			b.w = (float) ((b.w) < (2*t->padding.x) ? (2*t->padding.x) : (b.w));
			b.h = (float) ((b.h) < (2*t->padding.y) ? (2*t->padding.y) : (b.h));
			b.h = (float) (b.h - 2*t->padding.y);
			line.x = (float) (b.x + t->padding.x);
			line.y = (float) (b.y + t->padding.y);
			line.w = (float) (b.w - 2*t->padding.x);
			line.h = (float) (2*t->padding.y + f.height);
			fitting = (int) (nk_text_clamp(f, _string_, (int) (len), (float) (line.w), &glyphs, &width, seperator, 1));
			while ((done) < (len))
			{
				if ((fitting == 0) || ((line.y + line.h) >= (b.y + b.h))) break;
				nk_widget_text(o, (nk_rect) (line), &_string_[done], (int) (fitting), &text, (uint) (NK_TEXT_LEFT), f);
				done += (int) (fitting);
				line.y += (float) (f.height + 2*t->padding.y);
				fitting =
					(int) (nk_text_clamp(f, &_string_[done], (int) (len - done), (float) (line.w), &glyphs, &width, seperator, 1));
			}
		}

		public static void nk_draw_symbol(nk_command_buffer _out_, int type, nk_rect content, nk_color background,
			nk_color foreground, float border_width, nk_user_font font)
		{
			switch (type)
			{
				case NK_SYMBOL_X:
				case NK_SYMBOL_UNDERSCORE:
				case NK_SYMBOL_PLUS:
				case NK_SYMBOL_MINUS:
				{
					char X = ((type) == (NK_SYMBOL_X))
						? 'x'
						: ((type) == (NK_SYMBOL_UNDERSCORE)) ? '_' : ((type) == (NK_SYMBOL_PLUS)) ? '+' : '-';
					nk_text text = new nk_text();
					text.padding = (nk_vec2) (nk_vec2_((float) (0), (float) (0)));
					text.background = (nk_color) (background);
					text.text = (nk_color) (foreground);
					nk_widget_text(_out_, (nk_rect) (content), &X, (int) (1), &text, (uint) (NK_TEXT_CENTERED), font);
				}
					break;
				case NK_SYMBOL_CIRCLE_SOLID:
				case NK_SYMBOL_CIRCLE_OUTLINE:
				case NK_SYMBOL_RECT_SOLID:
				case NK_SYMBOL_RECT_OUTLINE:
				{
					if (((type) == (NK_SYMBOL_RECT_SOLID)) || ((type) == (NK_SYMBOL_RECT_OUTLINE)))
					{
						nk_fill_rect(_out_, (nk_rect) (content), (float) (0), (nk_color) (foreground));
						if ((type) == (NK_SYMBOL_RECT_OUTLINE))
							nk_fill_rect(_out_, (nk_rect) (nk_shrink_rect_((nk_rect) (content), (float) (border_width))), (float) (0),
								(nk_color) (background));
					}
					else
					{
						nk_fill_circle(_out_, (nk_rect) (content), (nk_color) (foreground));
						if ((type) == (NK_SYMBOL_CIRCLE_OUTLINE))
							nk_fill_circle(_out_, (nk_rect) (nk_shrink_rect_((nk_rect) (content), (float) (1))), (nk_color) (background));
					}
				}
					break;
				case NK_SYMBOL_TRIANGLE_UP:
				case NK_SYMBOL_TRIANGLE_DOWN:
				case NK_SYMBOL_TRIANGLE_LEFT:
				case NK_SYMBOL_TRIANGLE_RIGHT:
				{
					int heading;
					nk_vec2* points = stackalloc nk_vec2[3];
					heading =
						(int)
							(((type) == (NK_SYMBOL_TRIANGLE_RIGHT))
								? NK_RIGHT
								: ((type) == (NK_SYMBOL_TRIANGLE_LEFT)) ? NK_LEFT : ((type) == (NK_SYMBOL_TRIANGLE_UP)) ? NK_UP : NK_DOWN);
					nk_triangle_from_direction(points, (nk_rect) (content), (float) (0), (float) (0), (int) (heading));
					nk_fill_triangle(_out_, (float) (points[0].x), (float) (points[0].y), (float) (points[1].x), (float) (points[1].y),
						(float) (points[2].x), (float) (points[2].y), (nk_color) (foreground));
				}
					break;
				default:
				case NK_SYMBOL_NONE:
				case NK_SYMBOL_MAX:
					break;
			}

		}

		public static int nk_button_behavior(ref uint state, nk_rect r, nk_input i, int behavior)
		{
			int ret = (int) (0);
			if (((state) & NK_WIDGET_STATE_MODIFIED) != 0)
				(state) = (uint) (NK_WIDGET_STATE_INACTIVE | NK_WIDGET_STATE_MODIFIED);
			else (state) = (uint) (NK_WIDGET_STATE_INACTIVE);
			if (i == null) return (int) (0);
			if ((nk_input_is_mouse_hovering_rect(i, (nk_rect) (r))) != 0)
			{
				state = (uint) (NK_WIDGET_STATE_HOVERED);
				if ((nk_input_is_mouse_down(i, (int) (NK_BUTTON_LEFT))) != 0) state = (uint) (NK_WIDGET_STATE_ACTIVE);
				if ((nk_input_has_mouse_click_in_rect(i, (int) (NK_BUTTON_LEFT), (nk_rect) (r))) != 0)
				{
					ret =
						(int)
							((behavior != NK_BUTTON_DEFAULT)
								? nk_input_is_mouse_down(i, (int) (NK_BUTTON_LEFT))
								: nk_input_is_mouse_pressed(i, (int) (NK_BUTTON_LEFT)));
				}
			}

			if (((state & NK_WIDGET_STATE_HOVER) != 0) && (nk_input_is_mouse_prev_hovering_rect(i, (nk_rect) (r)) == 0))
				state |= (uint) (NK_WIDGET_STATE_ENTERED);
			else if ((nk_input_is_mouse_prev_hovering_rect(i, (nk_rect) (r))) != 0) state |= (uint) (NK_WIDGET_STATE_LEFT);
			return (int) (ret);
		}

		public static nk_style_item nk_draw_button(nk_command_buffer _out_, nk_rect* bounds, uint state, nk_style_button style)
		{
			nk_style_item background;
			if ((state & NK_WIDGET_STATE_HOVER) != 0) background = style.hover;
			else if ((state & NK_WIDGET_STATE_ACTIVED) != 0) background = style.active;
			else background = style.normal;
			if ((background.type) == (NK_STYLE_ITEM_IMAGE))
			{
				nk_draw_image(_out_, (nk_rect) (*bounds), background.data.image, (nk_color) (nk_white));
			}
			else
			{
				nk_fill_rect(_out_, (nk_rect) (*bounds), (float) (style.rounding), (nk_color) (background.data.color));
				nk_stroke_rect(_out_, (nk_rect) (*bounds), (float) (style.rounding), (float) (style.border),
					(nk_color) (style.border_color));
			}

			return background;
		}

		public static int nk_do_button(ref uint state, nk_command_buffer _out_, nk_rect r, nk_style_button style,
			nk_input _in_, int behavior, nk_rect* content)
		{
			nk_rect bounds = new nk_rect();
			if ((_out_ == null) || (style == null)) return (int) (nk_false);
			content->x = (float) (r.x + style.padding.x + style.border + style.rounding);
			content->y = (float) (r.y + style.padding.y + style.border + style.rounding);
			content->w = (float) (r.w - (2*style.padding.x + style.border + style.rounding*2));
			content->h = (float) (r.h - (2*style.padding.y + style.border + style.rounding*2));
			bounds.x = (float) (r.x - style.touch_padding.x);
			bounds.y = (float) (r.y - style.touch_padding.y);
			bounds.w = (float) (r.w + 2*style.touch_padding.x);
			bounds.h = (float) (r.h + 2*style.touch_padding.y);
			return (int) (nk_button_behavior(ref state, (nk_rect) (bounds), _in_, (int) (behavior)));
		}

		public static void nk_draw_button_text(nk_command_buffer _out_, nk_rect* bounds, nk_rect* content, uint state,
			nk_style_button style, char* txt, int len, uint text_alignment, nk_user_font font)
		{
			nk_text text = new nk_text();
			nk_style_item background;
			background = nk_draw_button(_out_, bounds, (uint) (state), style);
			if ((background.type) == (NK_STYLE_ITEM_COLOR)) text.background = (nk_color) (background.data.color);
			else text.background = (nk_color) (style.text_background);
			if ((state & NK_WIDGET_STATE_HOVER) != 0) text.text = (nk_color) (style.text_hover);
			else if ((state & NK_WIDGET_STATE_ACTIVED) != 0) text.text = (nk_color) (style.text_active);
			else text.text = (nk_color) (style.text_normal);
			text.padding = (nk_vec2) (nk_vec2_((float) (0), (float) (0)));
			nk_widget_text(_out_, (nk_rect) (*content), txt, (int) (len), &text, (uint) (text_alignment), font);
		}

		public static int nk_do_button_text(ref uint state, nk_command_buffer _out_, nk_rect bounds, char* _string_, int len,
			uint align, int behavior, nk_style_button style, nk_input _in_, nk_user_font font)
		{
			nk_rect content = new nk_rect();
			int ret = (int) (nk_false);
			if ((((_out_ == null) || (style == null)) || (font == null)) || (_string_ == null)) return (int) (nk_false);
			ret = (int) (nk_do_button(ref state, _out_, (nk_rect) (bounds), style, _in_, (int) (behavior), &content));
			if ((style.draw_begin) != null) style.draw_begin(_out_, (nk_handle) (style.userdata));
			nk_draw_button_text(_out_, &bounds, &content, (uint) (state), style, _string_, (int) (len), (uint) (align), font);
			if ((style.draw_end) != null) style.draw_end(_out_, (nk_handle) (style.userdata));
			return (int) (ret);
		}

		public static void nk_draw_button_symbol(nk_command_buffer _out_, nk_rect* bounds, nk_rect* content, uint state,
			nk_style_button style, int type, nk_user_font font)
		{
			nk_color sym = new nk_color();
			nk_color bg = new nk_color();
			nk_style_item background;
			background = nk_draw_button(_out_, bounds, (uint) (state), style);
			if ((background.type) == (NK_STYLE_ITEM_COLOR)) bg = (nk_color) (background.data.color);
			else bg = (nk_color) (style.text_background);
			if ((state & NK_WIDGET_STATE_HOVER) != 0) sym = (nk_color) (style.text_hover);
			else if ((state & NK_WIDGET_STATE_ACTIVED) != 0) sym = (nk_color) (style.text_active);
			else sym = (nk_color) (style.text_normal);
			nk_draw_symbol(_out_, (int) (type), (nk_rect) (*content), (nk_color) (bg), (nk_color) (sym), (float) (1), font);
		}

		public static int nk_do_button_symbol(ref uint state, nk_command_buffer _out_, nk_rect bounds, int symbol,
			int behavior, nk_style_button style, nk_input _in_, nk_user_font font)
		{
			int ret;
			nk_rect content = new nk_rect();
			if ((((_out_ == null) || (style == null)) || (font == null)) || (state == null)) return (int) (nk_false);
			ret = (int) (nk_do_button(ref state, _out_, (nk_rect) (bounds), style, _in_, (int) (behavior), &content));
			if ((style.draw_begin) != null) style.draw_begin(_out_, (nk_handle) (style.userdata));
			nk_draw_button_symbol(_out_, &bounds, &content, (uint) (state), style, (int) (symbol), font);
			if ((style.draw_end) != null) style.draw_end(_out_, (nk_handle) (style.userdata));
			return (int) (ret);
		}

		public static void nk_draw_button_image(nk_command_buffer _out_, nk_rect* bounds, nk_rect* content, uint state,
			nk_style_button style, nk_image img)
		{
			nk_draw_button(_out_, bounds, (uint) (state), style);
			nk_draw_image(_out_, (nk_rect) (*content), img, (nk_color) (nk_white));
		}

		public static int nk_do_button_image(ref uint state, nk_command_buffer _out_, nk_rect bounds, nk_image img, int b,
			nk_style_button style, nk_input _in_)
		{
			int ret;
			nk_rect content = new nk_rect();
			if (((_out_ == null) || (style == null)) || (state == null)) return (int) (nk_false);
			ret = (int) (nk_do_button(ref state, _out_, (nk_rect) (bounds), style, _in_, (int) (b), &content));
			content.x += (float) (style.image_padding.x);
			content.y += (float) (style.image_padding.y);
			content.w -= (float) (2*style.image_padding.x);
			content.h -= (float) (2*style.image_padding.y);
			if ((style.draw_begin) != null) style.draw_begin(_out_, (nk_handle) (style.userdata));
			nk_draw_button_image(_out_, &bounds, &content, (uint) (state), style, img);
			if ((style.draw_end) != null) style.draw_end(_out_, (nk_handle) (style.userdata));
			return (int) (ret);
		}

		public static void nk_draw_button_text_symbol(nk_command_buffer _out_, nk_rect* bounds, nk_rect* label,
			nk_rect* symbol, uint state, nk_style_button style, char* str, int len, int type, nk_user_font font)
		{
			nk_color sym = new nk_color();
			nk_text text = new nk_text();
			nk_style_item background;
			background = nk_draw_button(_out_, bounds, (uint) (state), style);
			if ((background.type) == (NK_STYLE_ITEM_COLOR)) text.background = (nk_color) (background.data.color);
			else text.background = (nk_color) (style.text_background);
			if ((state & NK_WIDGET_STATE_HOVER) != 0)
			{
				sym = (nk_color) (style.text_hover);
				text.text = (nk_color) (style.text_hover);
			}
			else if ((state & NK_WIDGET_STATE_ACTIVED) != 0)
			{
				sym = (nk_color) (style.text_active);
				text.text = (nk_color) (style.text_active);
			}
			else
			{
				sym = (nk_color) (style.text_normal);
				text.text = (nk_color) (style.text_normal);
			}

			text.padding = (nk_vec2) (nk_vec2_((float) (0), (float) (0)));
			nk_draw_symbol(_out_, (int) (type), (nk_rect) (*symbol), (nk_color) (style.text_background), (nk_color) (sym),
				(float) (0), font);
			nk_widget_text(_out_, (nk_rect) (*label), str, (int) (len), &text, (uint) (NK_TEXT_CENTERED), font);
		}

		public static int nk_do_button_text_symbol(ref uint state, nk_command_buffer _out_, nk_rect bounds, int symbol,
			char* str, int len, uint align, int behavior, nk_style_button style, nk_user_font font, nk_input _in_)
		{
			int ret;
			nk_rect tri = new nk_rect();
			nk_rect content = new nk_rect();
			if (((_out_ == null) || (style == null)) || (font == null)) return (int) (nk_false);
			ret = (int) (nk_do_button(ref state, _out_, (nk_rect) (bounds), style, _in_, (int) (behavior), &content));
			tri.y = (float) (content.y + (content.h/2) - font.height/2);
			tri.w = (float) (font.height);
			tri.h = (float) (font.height);
			if ((align & NK_TEXT_ALIGN_LEFT) != 0)
			{
				tri.x = (float) ((content.x + content.w) - (2*style.padding.x + tri.w));
				tri.x = (float) ((tri.x) < (0) ? (0) : (tri.x));
			}
			else tri.x = (float) (content.x + 2*style.padding.x);
			if ((style.draw_begin) != null) style.draw_begin(_out_, (nk_handle) (style.userdata));
			nk_draw_button_text_symbol(_out_, &bounds, &content, &tri, (uint) (state), style, str, (int) (len), (int) (symbol),
				font);
			if ((style.draw_end) != null) style.draw_end(_out_, (nk_handle) (style.userdata));
			return (int) (ret);
		}

		public static void nk_draw_button_text_image(nk_command_buffer _out_, nk_rect* bounds, nk_rect* label, nk_rect* image,
			uint state, nk_style_button style, char* str, int len, nk_user_font font, nk_image img)
		{
			nk_text text = new nk_text();
			nk_style_item background;
			background = nk_draw_button(_out_, bounds, (uint) (state), style);
			if ((background.type) == (NK_STYLE_ITEM_COLOR)) text.background = (nk_color) (background.data.color);
			else text.background = (nk_color) (style.text_background);
			if ((state & NK_WIDGET_STATE_HOVER) != 0) text.text = (nk_color) (style.text_hover);
			else if ((state & NK_WIDGET_STATE_ACTIVED) != 0) text.text = (nk_color) (style.text_active);
			else text.text = (nk_color) (style.text_normal);
			text.padding = (nk_vec2) (nk_vec2_((float) (0), (float) (0)));
			nk_widget_text(_out_, (nk_rect) (*label), str, (int) (len), &text, (uint) (NK_TEXT_CENTERED), font);
			nk_draw_image(_out_, (nk_rect) (*image), img, (nk_color) (nk_white));
		}

		public static int nk_do_button_text_image(ref uint state, nk_command_buffer _out_, nk_rect bounds, nk_image img,
			char* str, int len, uint align, int behavior, nk_style_button style, nk_user_font font, nk_input _in_)
		{
			int ret;
			nk_rect icon = new nk_rect();
			nk_rect content = new nk_rect();
			if ((((_out_ == null) || (font == null)) || (style == null)) || (str == null)) return (int) (nk_false);
			ret = (int) (nk_do_button(ref state, _out_, (nk_rect) (bounds), style, _in_, (int) (behavior), &content));
			icon.y = (float) (bounds.y + style.padding.y);
			icon.w = (float) (icon.h = (float) (bounds.h - 2*style.padding.y));
			if ((align & NK_TEXT_ALIGN_LEFT) != 0)
			{
				icon.x = (float) ((bounds.x + bounds.w) - (2*style.padding.x + icon.w));
				icon.x = (float) ((icon.x) < (0) ? (0) : (icon.x));
			}
			else icon.x = (float) (bounds.x + 2*style.padding.x);
			icon.x += (float) (style.image_padding.x);
			icon.y += (float) (style.image_padding.y);
			icon.w -= (float) (2*style.image_padding.x);
			icon.h -= (float) (2*style.image_padding.y);
			if ((style.draw_begin) != null) style.draw_begin(_out_, (nk_handle) (style.userdata));
			nk_draw_button_text_image(_out_, &bounds, &content, &icon, (uint) (state), style, str, (int) (len), font, img);
			if ((style.draw_end) != null) style.draw_end(_out_, (nk_handle) (style.userdata));
			return (int) (ret);
		}

		public static int nk_toggle_behavior(nk_input _in_, nk_rect select, ref uint state, int active)
		{
			if (((state) & NK_WIDGET_STATE_MODIFIED) != 0)
				(state) = (uint) (NK_WIDGET_STATE_INACTIVE | NK_WIDGET_STATE_MODIFIED);
			else (state) = (uint) (NK_WIDGET_STATE_INACTIVE);
			if ((nk_button_behavior(ref state, (nk_rect) (select), _in_, (int) (NK_BUTTON_DEFAULT))) != 0)
			{
				state = (uint) (NK_WIDGET_STATE_ACTIVE);
				active = active != 0 ? 0 : 1;
			}

			if (((state & NK_WIDGET_STATE_HOVER) != 0) && (nk_input_is_mouse_prev_hovering_rect(_in_, (nk_rect) (select)) == 0))
				state |= (uint) (NK_WIDGET_STATE_ENTERED);
			else if ((nk_input_is_mouse_prev_hovering_rect(_in_, (nk_rect) (select))) != 0) state |= (uint) (NK_WIDGET_STATE_LEFT);
			return (int) (active);
		}

		public static void nk_draw_checkbox(nk_command_buffer _out_, uint state, nk_style_toggle style, int active,
			nk_rect* label, nk_rect* selector, nk_rect* cursors, char* _string_, int len, nk_user_font font)
		{
			nk_style_item background;
			nk_style_item cursor;
			nk_text text = new nk_text();
			if ((state & NK_WIDGET_STATE_HOVER) != 0)
			{
				background = style.hover;
				cursor = style.cursor_hover;
				text.text = (nk_color) (style.text_hover);
			}
			else if ((state & NK_WIDGET_STATE_ACTIVED) != 0)
			{
				background = style.hover;
				cursor = style.cursor_hover;
				text.text = (nk_color) (style.text_active);
			}
			else
			{
				background = style.normal;
				cursor = style.cursor_normal;
				text.text = (nk_color) (style.text_normal);
			}

			if ((background.type) == (NK_STYLE_ITEM_COLOR))
			{
				nk_fill_rect(_out_, (nk_rect) (*selector), (float) (0), (nk_color) (style.border_color));
				nk_fill_rect(_out_, (nk_rect) (nk_shrink_rect_((nk_rect) (*selector), (float) (style.border))), (float) (0),
					(nk_color) (background.data.color));
			}
			else nk_draw_image(_out_, (nk_rect) (*selector), background.data.image, (nk_color) (nk_white));
			if ((active) != 0)
			{
				if ((cursor.type) == (NK_STYLE_ITEM_IMAGE))
					nk_draw_image(_out_, (nk_rect) (*cursors), cursor.data.image, (nk_color) (nk_white));
				else nk_fill_rect(_out_, (nk_rect) (*cursors), (float) (0), (nk_color) (cursor.data.color));
			}

			text.padding.x = (float) (0);
			text.padding.y = (float) (0);
			text.background = (nk_color) (style.text_background);
			nk_widget_text(_out_, (nk_rect) (*label), _string_, (int) (len), &text, (uint) (NK_TEXT_LEFT), font);
		}

		public static void nk_draw_option(nk_command_buffer _out_, uint state, nk_style_toggle style, int active,
			nk_rect* label, nk_rect* selector, nk_rect* cursors, char* _string_, int len, nk_user_font font)
		{
			nk_style_item background;
			nk_style_item cursor;
			nk_text text = new nk_text();
			if ((state & NK_WIDGET_STATE_HOVER) != 0)
			{
				background = style.hover;
				cursor = style.cursor_hover;
				text.text = (nk_color) (style.text_hover);
			}
			else if ((state & NK_WIDGET_STATE_ACTIVED) != 0)
			{
				background = style.hover;
				cursor = style.cursor_hover;
				text.text = (nk_color) (style.text_active);
			}
			else
			{
				background = style.normal;
				cursor = style.cursor_normal;
				text.text = (nk_color) (style.text_normal);
			}

			if ((background.type) == (NK_STYLE_ITEM_COLOR))
			{
				nk_fill_circle(_out_, (nk_rect) (*selector), (nk_color) (style.border_color));
				nk_fill_circle(_out_, (nk_rect) (nk_shrink_rect_((nk_rect) (*selector), (float) (style.border))),
					(nk_color) (background.data.color));
			}
			else nk_draw_image(_out_, (nk_rect) (*selector), background.data.image, (nk_color) (nk_white));
			if ((active) != 0)
			{
				if ((cursor.type) == (NK_STYLE_ITEM_IMAGE))
					nk_draw_image(_out_, (nk_rect) (*cursors), cursor.data.image, (nk_color) (nk_white));
				else nk_fill_circle(_out_, (nk_rect) (*cursors), (nk_color) (cursor.data.color));
			}

			text.padding.x = (float) (0);
			text.padding.y = (float) (0);
			text.background = (nk_color) (style.text_background);
			nk_widget_text(_out_, (nk_rect) (*label), _string_, (int) (len), &text, (uint) (NK_TEXT_LEFT), font);
		}

		public static int nk_do_toggle(ref uint state, nk_command_buffer _out_, nk_rect r, int* active, char* str, int len,
			int type, nk_style_toggle style, nk_input _in_, nk_user_font font)
		{
			int was_active;
			nk_rect bounds = new nk_rect();
			nk_rect select = new nk_rect();
			nk_rect cursor = new nk_rect();
			nk_rect label = new nk_rect();
			if ((((_out_ == null) || (style == null)) || (font == null)) || (active == null)) return (int) (0);
			r.w = (float) ((r.w) < (font.height + 2*style.padding.x) ? (font.height + 2*style.padding.x) : (r.w));
			r.h = (float) ((r.h) < (font.height + 2*style.padding.y) ? (font.height + 2*style.padding.y) : (r.h));
			bounds.x = (float) (r.x - style.touch_padding.x);
			bounds.y = (float) (r.y - style.touch_padding.y);
			bounds.w = (float) (r.w + 2*style.touch_padding.x);
			bounds.h = (float) (r.h + 2*style.touch_padding.y);
			select.w = (float) (font.height);
			select.h = (float) (select.w);
			select.y = (float) (r.y + r.h/2.0f - select.h/2.0f);
			select.x = (float) (r.x);
			cursor.x = (float) (select.x + style.padding.x + style.border);
			cursor.y = (float) (select.y + style.padding.y + style.border);
			cursor.w = (float) (select.w - (2*style.padding.x + 2*style.border));
			cursor.h = (float) (select.h - (2*style.padding.y + 2*style.border));
			label.x = (float) (select.x + select.w + style.spacing);
			label.y = (float) (select.y);
			label.w = (float) (((r.x + r.w) < (label.x) ? (label.x) : (r.x + r.w)) - label.x);
			label.h = (float) (select.w);
			was_active = (int) (*active);
			*active = (int) (nk_toggle_behavior(_in_, (nk_rect) (bounds), ref state, (int) (*active)));
			if ((style.draw_begin) != null) style.draw_begin(_out_, (nk_handle) (style.userdata));
			if ((type) == (NK_TOGGLE_CHECK))
			{
				nk_draw_checkbox(_out_, (uint) (state), style, (int) (*active), &label, &select, &cursor, str, (int) (len), font);
			}
			else
			{
				nk_draw_option(_out_, (uint) (state), style, (int) (*active), &label, &select, &cursor, str, (int) (len), font);
			}

			if ((style.draw_end) != null) style.draw_end(_out_, (nk_handle) (style.userdata));
			return was_active != *active ? 1 : 0;
		}

		public static void nk_draw_selectable(nk_command_buffer _out_, uint state, nk_style_selectable style, int active,
			nk_rect* bounds, nk_rect* icon, nk_image img, char* _string_, int len, uint align, nk_user_font font)
		{
			nk_style_item background;
			nk_text text = new nk_text();
			text.padding = (nk_vec2) (style.padding);
			if (active == 0)
			{
				if ((state & NK_WIDGET_STATE_ACTIVED) != 0)
				{
					background = style.pressed;
					text.text = (nk_color) (style.text_pressed);
				}
				else if ((state & NK_WIDGET_STATE_HOVER) != 0)
				{
					background = style.hover;
					text.text = (nk_color) (style.text_hover);
				}
				else
				{
					background = style.normal;
					text.text = (nk_color) (style.text_normal);
				}
			}
			else
			{
				if ((state & NK_WIDGET_STATE_ACTIVED) != 0)
				{
					background = style.pressed_active;
					text.text = (nk_color) (style.text_pressed_active);
				}
				else if ((state & NK_WIDGET_STATE_HOVER) != 0)
				{
					background = style.hover_active;
					text.text = (nk_color) (style.text_hover_active);
				}
				else
				{
					background = style.normal_active;
					text.text = (nk_color) (style.text_normal_active);
				}
			}

			if ((background.type) == (NK_STYLE_ITEM_IMAGE))
			{
				nk_draw_image(_out_, (nk_rect) (*bounds), background.data.image, (nk_color) (nk_white));
				text.background = (nk_color) (nk_rgba((int) (0), (int) (0), (int) (0), (int) (0)));
			}
			else
			{
				nk_fill_rect(_out_, (nk_rect) (*bounds), (float) (style.rounding), (nk_color) (background.data.color));
				text.background = (nk_color) (background.data.color);
			}

			if (((img) != null) && ((icon) != null)) nk_draw_image(_out_, (nk_rect) (*icon), img, (nk_color) (nk_white));
			nk_widget_text(_out_, (nk_rect) (*bounds), _string_, (int) (len), &text, (uint) (align), font);
		}

		public static int nk_do_selectable(ref uint state, nk_command_buffer _out_, nk_rect bounds, char* str, int len,
			uint align, ref int value, nk_style_selectable style, nk_input _in_, nk_user_font font)
		{
			int old_value;
			nk_rect touch = new nk_rect();
			if (((((((state == null) || (_out_ == null)) || (str == null)) || (len == 0)) || (value == null)) || (style == null)) ||
			    (font == null)) return (int) (0);
			old_value = (int) (value);
			touch.x = (float) (bounds.x - style.touch_padding.x);
			touch.y = (float) (bounds.y - style.touch_padding.y);
			touch.w = (float) (bounds.w + style.touch_padding.x*2);
			touch.h = (float) (bounds.h + style.touch_padding.y*2);
			if ((nk_button_behavior(ref state, (nk_rect) (touch), _in_, (int) (NK_BUTTON_DEFAULT))) != 0)
				value = value != 0 ? 0 : 1;
			if ((style.draw_begin) != null) style.draw_begin(_out_, (nk_handle) (style.userdata));
			nk_draw_selectable(_out_, (uint) (state), style, (int) (value), &bounds, null, null, str, (int) (len), (uint) (align),
				font);
			if ((style.draw_end) != null) style.draw_end(_out_, (nk_handle) (style.userdata));
			return old_value != value ? 1 : 0;
		}

		public static int nk_do_selectable_image(ref uint state, nk_command_buffer _out_, nk_rect bounds, char* str, int len,
			uint align, ref int value, nk_image img, nk_style_selectable style, nk_input _in_, nk_user_font font)
		{
			int old_value;
			nk_rect touch = new nk_rect();
			nk_rect icon = new nk_rect();
			if (((((((state == null) || (_out_ == null)) || (str == null)) || (len == 0)) || (value == null)) || (style == null)) ||
			    (font == null)) return (int) (0);
			old_value = (int) (value);
			touch.x = (float) (bounds.x - style.touch_padding.x);
			touch.y = (float) (bounds.y - style.touch_padding.y);
			touch.w = (float) (bounds.w + style.touch_padding.x*2);
			touch.h = (float) (bounds.h + style.touch_padding.y*2);
			if ((nk_button_behavior(ref state, (nk_rect) (touch), _in_, (int) (NK_BUTTON_DEFAULT))) != 0)
				value = value != 0 ? 0 : 1;
			icon.y = (float) (bounds.y + style.padding.y);
			icon.w = (float) (icon.h = (float) (bounds.h - 2*style.padding.y));
			if ((align & NK_TEXT_ALIGN_LEFT) != 0)
			{
				icon.x = (float) ((bounds.x + bounds.w) - (2*style.padding.x + icon.w));
				icon.x = (float) ((icon.x) < (0) ? (0) : (icon.x));
			}
			else icon.x = (float) (bounds.x + 2*style.padding.x);
			icon.x += (float) (style.image_padding.x);
			icon.y += (float) (style.image_padding.y);
			icon.w -= (float) (2*style.image_padding.x);
			icon.h -= (float) (2*style.image_padding.y);
			if ((style.draw_begin) != null) style.draw_begin(_out_, (nk_handle) (style.userdata));
			nk_draw_selectable(_out_, (uint) (state), style, (int) (value), &bounds, &icon, img, str, (int) (len), (uint) (align),
				font);
			if ((style.draw_end) != null) style.draw_end(_out_, (nk_handle) (style.userdata));
			return old_value != value ? 1 : 0;
		}

		public static float nk_slider_behavior(ref uint state, nk_rect* logical_cursor, nk_rect* visual_cursor, nk_input _in_,
			nk_rect bounds, float slider_min, float slider_max, float slider_value, float slider_step, float slider_steps)
		{
			int left_mouse_down;
			int left_mouse_click_in_cursor;
			if (((state) & NK_WIDGET_STATE_MODIFIED) != 0)
				(state) = (uint) (NK_WIDGET_STATE_INACTIVE | NK_WIDGET_STATE_MODIFIED);
			else (state) = (uint) (NK_WIDGET_STATE_INACTIVE);
			left_mouse_down =
				(int) (((_in_) != null) && ((((nk_mouse_button*) _in_.mouse.buttons + NK_BUTTON_LEFT)->down) != 0) ? 1 : 0);
			left_mouse_click_in_cursor =
				(int)
					(((_in_) != null) &&
					 ((nk_input_has_mouse_click_down_in_rect(_in_, (int) (NK_BUTTON_LEFT), (nk_rect) (*visual_cursor), (int) (nk_true))) !=
					  0)
						? 1
						: 0);
			if (((left_mouse_down) != 0) && ((left_mouse_click_in_cursor) != 0))
			{
				float ratio = (float) (0);
				float d = (float) (_in_.mouse.pos.x - (visual_cursor->x + visual_cursor->w*0.5f));
				float pxstep = (float) (bounds.w/slider_steps);
				state = (uint) (NK_WIDGET_STATE_ACTIVE);
				if ((((d) < (0)) ? -(d) : (d)) >= (pxstep))
				{
					float steps = (float) ((int) ((((d) < (0)) ? -(d) : (d))/pxstep));
					slider_value += (float) (((d) > (0)) ? (slider_step*steps) : -(slider_step*steps));
					slider_value =
						(float)
							(((slider_value) < (slider_max) ? (slider_value) : (slider_max)) < (slider_min)
								? (slider_min)
								: ((slider_value) < (slider_max) ? (slider_value) : (slider_max)));
					ratio = (float) ((slider_value - slider_min)/slider_step);
					logical_cursor->x = (float) (bounds.x + (logical_cursor->w*ratio));
					((nk_mouse_button*) _in_.mouse.buttons + NK_BUTTON_LEFT)->clicked_pos.x = (float) (logical_cursor->x);
				}
			}

			if ((nk_input_is_mouse_hovering_rect(_in_, (nk_rect) (bounds))) != 0) state = (uint) (NK_WIDGET_STATE_HOVERED);
			if (((state & NK_WIDGET_STATE_HOVER) != 0) && (nk_input_is_mouse_prev_hovering_rect(_in_, (nk_rect) (bounds)) == 0))
				state |= (uint) (NK_WIDGET_STATE_ENTERED);
			else if ((nk_input_is_mouse_prev_hovering_rect(_in_, (nk_rect) (bounds))) != 0) state |= (uint) (NK_WIDGET_STATE_LEFT);
			return (float) (slider_value);
		}

		public static void nk_draw_slider(nk_command_buffer _out_, uint state, nk_style_slider style, nk_rect* bounds,
			nk_rect* visual_cursor, float min, float value, float max)
		{
			nk_rect fill = new nk_rect();
			nk_rect bar = new nk_rect();
			nk_style_item background;
			nk_color bar_color = new nk_color();
			nk_style_item cursor;
			if ((state & NK_WIDGET_STATE_ACTIVED) != 0)
			{
				background = style.active;
				bar_color = (nk_color) (style.bar_active);
				cursor = style.cursor_active;
			}
			else if ((state & NK_WIDGET_STATE_HOVER) != 0)
			{
				background = style.hover;
				bar_color = (nk_color) (style.bar_hover);
				cursor = style.cursor_hover;
			}
			else
			{
				background = style.normal;
				bar_color = (nk_color) (style.bar_normal);
				cursor = style.cursor_normal;
			}

			bar.x = (float) (bounds->x);
			bar.y = (float) ((visual_cursor->y + visual_cursor->h/2) - bounds->h/12);
			bar.w = (float) (bounds->w);
			bar.h = (float) (bounds->h/6);
			fill.w = (float) ((visual_cursor->x + (visual_cursor->w/2.0f)) - bar.x);
			fill.x = (float) (bar.x);
			fill.y = (float) (bar.y);
			fill.h = (float) (bar.h);
			if ((background.type) == (NK_STYLE_ITEM_IMAGE))
			{
				nk_draw_image(_out_, (nk_rect) (*bounds), background.data.image, (nk_color) (nk_white));
			}
			else
			{
				nk_fill_rect(_out_, (nk_rect) (*bounds), (float) (style.rounding), (nk_color) (background.data.color));
				nk_stroke_rect(_out_, (nk_rect) (*bounds), (float) (style.rounding), (float) (style.border),
					(nk_color) (style.border_color));
			}

			nk_fill_rect(_out_, (nk_rect) (bar), (float) (style.rounding), (nk_color) (bar_color));
			nk_fill_rect(_out_, (nk_rect) (fill), (float) (style.rounding), (nk_color) (style.bar_filled));
			if ((cursor.type) == (NK_STYLE_ITEM_IMAGE))
				nk_draw_image(_out_, (nk_rect) (*visual_cursor), cursor.data.image, (nk_color) (nk_white));
			else nk_fill_circle(_out_, (nk_rect) (*visual_cursor), (nk_color) (cursor.data.color));
		}

		public static float nk_do_slider(ref uint state, nk_command_buffer _out_, nk_rect bounds, float min, float val,
			float max, float step, nk_style_slider style, nk_input _in_, nk_user_font font)
		{
			float slider_range;
			float slider_min;
			float slider_max;
			float slider_value;
			float slider_steps;
			float cursor_offset;
			nk_rect visual_cursor = new nk_rect();
			nk_rect logical_cursor = new nk_rect();
			if ((_out_ == null) || (style == null)) return (float) (0);
			bounds.x = (float) (bounds.x + style.padding.x);
			bounds.y = (float) (bounds.y + style.padding.y);
			bounds.h = (float) ((bounds.h) < (2*style.padding.y) ? (2*style.padding.y) : (bounds.h));
			bounds.w =
				(float)
					((bounds.w) < (2*style.padding.x + style.cursor_size.x) ? (2*style.padding.x + style.cursor_size.x) : (bounds.w));
			bounds.w -= (float) (2*style.padding.x);
			bounds.h -= (float) (2*style.padding.y);
			if ((style.show_buttons) != 0)
			{
				uint ws = 0;
				nk_rect button = new nk_rect();
				button.y = (float) (bounds.y);
				button.w = (float) (bounds.h);
				button.h = (float) (bounds.h);
				button.x = (float) (bounds.x);
				if (
					(nk_do_button_symbol(ref ws, _out_, (nk_rect) (button), (int) (style.dec_symbol), (int) (NK_BUTTON_DEFAULT),
						style.dec_button, _in_, font)) != 0) val -= (float) (step);
				button.x = (float) ((bounds.x + bounds.w) - button.w);
				if (
					(nk_do_button_symbol(ref ws, _out_, (nk_rect) (button), (int) (style.inc_symbol), (int) (NK_BUTTON_DEFAULT),
						style.inc_button, _in_, font)) != 0) val += (float) (step);
				bounds.x = (float) (bounds.x + button.w + style.spacing.x);
				bounds.w = (float) (bounds.w - (2*button.w + 2*style.spacing.x));
			}

			bounds.x += (float) (style.cursor_size.x*0.5f);
			bounds.w -= (float) (style.cursor_size.x);
			slider_max = (float) ((min) < (max) ? (max) : (min));
			slider_min = (float) ((min) < (max) ? (min) : (max));
			slider_value =
				(float)
					(((val) < (slider_max) ? (val) : (slider_max)) < (slider_min)
						? (slider_min)
						: ((val) < (slider_max) ? (val) : (slider_max)));
			slider_range = (float) (slider_max - slider_min);
			slider_steps = (float) (slider_range/step);
			cursor_offset = (float) ((slider_value - slider_min)/step);
			logical_cursor.h = (float) (bounds.h);
			logical_cursor.w = (float) (bounds.w/slider_steps);
			logical_cursor.x = (float) (bounds.x + (logical_cursor.w*cursor_offset));
			logical_cursor.y = (float) (bounds.y);
			visual_cursor.h = (float) (style.cursor_size.y);
			visual_cursor.w = (float) (style.cursor_size.x);
			visual_cursor.y = (float) ((bounds.y + bounds.h*0.5f) - visual_cursor.h*0.5f);
			visual_cursor.x = (float) (logical_cursor.x - visual_cursor.w*0.5f);
			slider_value =
				(float)
					(nk_slider_behavior(ref state, &logical_cursor, &visual_cursor, _in_, (nk_rect) (bounds), (float) (slider_min),
						(float) (slider_max), (float) (slider_value), (float) (step), (float) (slider_steps)));
			visual_cursor.x = (float) (logical_cursor.x - visual_cursor.w*0.5f);
			if ((style.draw_begin) != null) style.draw_begin(_out_, (nk_handle) (style.userdata));
			nk_draw_slider(_out_, (uint) (state), style, &bounds, &visual_cursor, (float) (slider_min), (float) (slider_value),
				(float) (slider_max));
			if ((style.draw_end) != null) style.draw_end(_out_, (nk_handle) (style.userdata));
			return (float) (slider_value);
		}

		public static ulong nk_progress_behavior(ref uint state, nk_input _in_, nk_rect r, nk_rect cursor, ulong max,
			ulong value, int modifiable)
		{
			int left_mouse_down = (int) (0);
			int left_mouse_click_in_cursor = (int) (0);
			if (((state) & NK_WIDGET_STATE_MODIFIED) != 0)
				(state) = (uint) (NK_WIDGET_STATE_INACTIVE | NK_WIDGET_STATE_MODIFIED);
			else (state) = (uint) (NK_WIDGET_STATE_INACTIVE);
			if ((_in_ == null) || (modifiable == 0)) return (ulong) (value);
			left_mouse_down =
				(int) (((_in_) != null) && ((((nk_mouse_button*) _in_.mouse.buttons + NK_BUTTON_LEFT)->down) != 0) ? 1 : 0);
			left_mouse_click_in_cursor =
				(int)
					(((_in_) != null) &&
					 ((nk_input_has_mouse_click_down_in_rect(_in_, (int) (NK_BUTTON_LEFT), (nk_rect) (cursor), (int) (nk_true))) != 0)
						? 1
						: 0);
			if ((nk_input_is_mouse_hovering_rect(_in_, (nk_rect) (r))) != 0) state = (uint) (NK_WIDGET_STATE_HOVERED);
			if ((((_in_) != null) && ((left_mouse_down) != 0)) && ((left_mouse_click_in_cursor) != 0))
			{
				if (((left_mouse_down) != 0) && ((left_mouse_click_in_cursor) != 0))
				{
					float ratio = (float) (((0) < (_in_.mouse.pos.x - cursor.x) ? (_in_.mouse.pos.x - cursor.x) : (0))/cursor.w);
					value =
						((ulong)
							((((float) (max)*ratio) < ((float) (max)) ? ((float) (max)*ratio) : ((float) (max))) < (0)
								? (0)
								: (((float) (max)*ratio) < ((float) (max)) ? ((float) (max)*ratio) : ((float) (max)))));
					((nk_mouse_button*) _in_.mouse.buttons + NK_BUTTON_LEFT)->clicked_pos.x = (float) (cursor.x + cursor.w/2.0f);
					state |= (uint) (NK_WIDGET_STATE_ACTIVE);
				}
			}

			if (((state & NK_WIDGET_STATE_HOVER) != 0) && (nk_input_is_mouse_prev_hovering_rect(_in_, (nk_rect) (r)) == 0))
				state |= (uint) (NK_WIDGET_STATE_ENTERED);
			else if ((nk_input_is_mouse_prev_hovering_rect(_in_, (nk_rect) (r))) != 0) state |= (uint) (NK_WIDGET_STATE_LEFT);
			return (ulong) (value);
		}

		public static void nk_draw_progress(nk_command_buffer _out_, uint state, nk_style_progress style, nk_rect* bounds,
			nk_rect* scursor, ulong value, ulong max)
		{
			nk_style_item background;
			nk_style_item cursor;
			if ((state & NK_WIDGET_STATE_ACTIVED) != 0)
			{
				background = style.active;
				cursor = style.cursor_active;
			}
			else if ((state & NK_WIDGET_STATE_HOVER) != 0)
			{
				background = style.hover;
				cursor = style.cursor_hover;
			}
			else
			{
				background = style.normal;
				cursor = style.cursor_normal;
			}

			if ((background.type) == (NK_STYLE_ITEM_COLOR))
			{
				nk_fill_rect(_out_, (nk_rect) (*bounds), (float) (style.rounding), (nk_color) (background.data.color));
				nk_stroke_rect(_out_, (nk_rect) (*bounds), (float) (style.rounding), (float) (style.border),
					(nk_color) (style.border_color));
			}
			else nk_draw_image(_out_, (nk_rect) (*bounds), background.data.image, (nk_color) (nk_white));
			if ((cursor.type) == (NK_STYLE_ITEM_COLOR))
			{
				nk_fill_rect(_out_, (nk_rect) (*scursor), (float) (style.rounding), (nk_color) (cursor.data.color));
				nk_stroke_rect(_out_, (nk_rect) (*scursor), (float) (style.rounding), (float) (style.border),
					(nk_color) (style.border_color));
			}
			else nk_draw_image(_out_, (nk_rect) (*scursor), cursor.data.image, (nk_color) (nk_white));
		}

		public static ulong nk_do_progress(ref uint state, nk_command_buffer _out_, nk_rect bounds, ulong value, ulong max,
			int modifiable, nk_style_progress style, nk_input _in_)
		{
			float prog_scale;
			ulong prog_value;
			nk_rect cursor = new nk_rect();
			if ((_out_ == null) || (style == null)) return (ulong) (0);
			cursor.w =
				(float) ((bounds.w) < (2*style.padding.x + 2*style.border) ? (2*style.padding.x + 2*style.border) : (bounds.w));
			cursor.h =
				(float) ((bounds.h) < (2*style.padding.y + 2*style.border) ? (2*style.padding.y + 2*style.border) : (bounds.h));
			cursor =
				(nk_rect)
					(nk_pad_rect((nk_rect) (bounds),
						(nk_vec2) (nk_vec2_((float) (style.padding.x + style.border), (float) (style.padding.y + style.border)))));
			prog_scale = (float) ((float) (value)/(float) (max));
			prog_value = (ulong) ((value) < (max) ? (value) : (max));
			prog_value =
				(ulong)
					(nk_progress_behavior(ref state, _in_, (nk_rect) (bounds), (nk_rect) (cursor), (ulong) (max), (ulong) (prog_value),
						(int) (modifiable)));
			cursor.w = (float) (cursor.w*prog_scale);
			if ((style.draw_begin) != null) style.draw_begin(_out_, (nk_handle) (style.userdata));
			nk_draw_progress(_out_, (uint) (state), style, &bounds, &cursor, (ulong) (value), (ulong) (max));
			if ((style.draw_end) != null) style.draw_end(_out_, (nk_handle) (style.userdata));
			return (ulong) (prog_value);
		}

		public static float nk_scrollbar_behavior(ref uint state, nk_input _in_, int has_scrolling, nk_rect* scroll,
			nk_rect* cursor, nk_rect* empty0, nk_rect* empty1, float scroll_offset, float target, float scroll_step, int o)
		{
			uint ws = (uint) (0);
			int left_mouse_down;
			int left_mouse_click_in_cursor;
			float scroll_delta;
			if (((state) & NK_WIDGET_STATE_MODIFIED) != 0)
				(state) = (uint) (NK_WIDGET_STATE_INACTIVE | NK_WIDGET_STATE_MODIFIED);
			else (state) = (uint) (NK_WIDGET_STATE_INACTIVE);
			if (_in_ == null) return (float) (scroll_offset);
			left_mouse_down = (int) (((nk_mouse_button*) _in_.mouse.buttons + NK_BUTTON_LEFT)->down);
			left_mouse_click_in_cursor =
				(int) (nk_input_has_mouse_click_down_in_rect(_in_, (int) (NK_BUTTON_LEFT), (nk_rect) (*cursor), (int) (nk_true)));
			if ((nk_input_is_mouse_hovering_rect(_in_, (nk_rect) (*scroll))) != 0) state = (uint) (NK_WIDGET_STATE_HOVERED);
			scroll_delta = (float) (((o) == (NK_VERTICAL)) ? _in_.mouse.scroll_delta.y : _in_.mouse.scroll_delta.x);
			if (((left_mouse_down) != 0) && ((left_mouse_click_in_cursor) != 0))
			{
				float pixel;
				float delta;
				state = (uint) (NK_WIDGET_STATE_ACTIVE);
				if ((o) == (NK_VERTICAL))
				{
					float cursor_y;
					pixel = (float) (_in_.mouse.delta.y);
					delta = (float) ((pixel/scroll->h)*target);
					scroll_offset =
						(float)
							(((scroll_offset + delta) < (target - scroll->h) ? (scroll_offset + delta) : (target - scroll->h)) < (0)
								? (0)
								: ((scroll_offset + delta) < (target - scroll->h) ? (scroll_offset + delta) : (target - scroll->h)));
					cursor_y = (float) (scroll->y + ((scroll_offset/target)*scroll->h));
					((nk_mouse_button*) _in_.mouse.buttons + NK_BUTTON_LEFT)->clicked_pos.y = (float) (cursor_y + cursor->h/2.0f);
				}
				else
				{
					float cursor_x;
					pixel = (float) (_in_.mouse.delta.x);
					delta = (float) ((pixel/scroll->w)*target);
					scroll_offset =
						(float)
							(((scroll_offset + delta) < (target - scroll->w) ? (scroll_offset + delta) : (target - scroll->w)) < (0)
								? (0)
								: ((scroll_offset + delta) < (target - scroll->w) ? (scroll_offset + delta) : (target - scroll->w)));
					cursor_x = (float) (scroll->x + ((scroll_offset/target)*scroll->w));
					((nk_mouse_button*) _in_.mouse.buttons + NK_BUTTON_LEFT)->clicked_pos.x = (float) (cursor_x + cursor->w/2.0f);
				}
			}
			else if (((((nk_input_is_key_pressed(_in_, (int) (NK_KEY_SCROLL_UP))) != 0) && ((o) == (NK_VERTICAL))) &&
			          ((has_scrolling) != 0)) ||
			         ((nk_button_behavior(ref ws, (nk_rect) (*empty0), _in_, (int) (NK_BUTTON_DEFAULT))) != 0))
			{
				if ((o) == (NK_VERTICAL))
					scroll_offset = (float) ((0) < (scroll_offset - scroll->h) ? (scroll_offset - scroll->h) : (0));
				else scroll_offset = (float) ((0) < (scroll_offset - scroll->w) ? (scroll_offset - scroll->w) : (0));
			}
			else if (((((nk_input_is_key_pressed(_in_, (int) (NK_KEY_SCROLL_DOWN))) != 0) && ((o) == (NK_VERTICAL))) &&
			          ((has_scrolling) != 0)) ||
			         ((nk_button_behavior(ref ws, (nk_rect) (*empty1), _in_, (int) (NK_BUTTON_DEFAULT))) != 0))
			{
				if ((o) == (NK_VERTICAL))
					scroll_offset =
						(float)
							((scroll_offset + scroll->h) < (target - scroll->h) ? (scroll_offset + scroll->h) : (target - scroll->h));
				else
					scroll_offset =
						(float)
							((scroll_offset + scroll->w) < (target - scroll->w) ? (scroll_offset + scroll->w) : (target - scroll->w));
			}
			else if ((has_scrolling) != 0)
			{
				if ((((scroll_delta) < (0)) || ((scroll_delta) > (0))))
				{
					scroll_offset = (float) (scroll_offset + scroll_step*(-scroll_delta));
					if ((o) == (NK_VERTICAL))
						scroll_offset =
							(float)
								(((scroll_offset) < (target - scroll->h) ? (scroll_offset) : (target - scroll->h)) < (0)
									? (0)
									: ((scroll_offset) < (target - scroll->h) ? (scroll_offset) : (target - scroll->h)));
					else
						scroll_offset =
							(float)
								(((scroll_offset) < (target - scroll->w) ? (scroll_offset) : (target - scroll->w)) < (0)
									? (0)
									: ((scroll_offset) < (target - scroll->w) ? (scroll_offset) : (target - scroll->w)));
				}
				else if ((nk_input_is_key_pressed(_in_, (int) (NK_KEY_SCROLL_START))) != 0)
				{
					if ((o) == (NK_VERTICAL)) scroll_offset = (float) (0);
				}
				else if ((nk_input_is_key_pressed(_in_, (int) (NK_KEY_SCROLL_END))) != 0)
				{
					if ((o) == (NK_VERTICAL)) scroll_offset = (float) (target - scroll->h);
				}
			}

			if (((state & NK_WIDGET_STATE_HOVER) != 0) && (nk_input_is_mouse_prev_hovering_rect(_in_, (nk_rect) (*scroll)) == 0))
				state |= (uint) (NK_WIDGET_STATE_ENTERED);
			else if ((nk_input_is_mouse_prev_hovering_rect(_in_, (nk_rect) (*scroll))) != 0) state |= (uint) (NK_WIDGET_STATE_LEFT);
			return (float) (scroll_offset);
		}

		public static void nk_draw_scrollbar(nk_command_buffer _out_, uint state, nk_style_scrollbar style, nk_rect* bounds,
			nk_rect* scroll)
		{
			nk_style_item background;
			nk_style_item cursor;
			if ((state & NK_WIDGET_STATE_ACTIVED) != 0)
			{
				background = style.active;
				cursor = style.cursor_active;
			}
			else if ((state & NK_WIDGET_STATE_HOVER) != 0)
			{
				background = style.hover;
				cursor = style.cursor_hover;
			}
			else
			{
				background = style.normal;
				cursor = style.cursor_normal;
			}

			if ((background.type) == (NK_STYLE_ITEM_COLOR))
			{
				nk_fill_rect(_out_, (nk_rect) (*bounds), (float) (style.rounding), (nk_color) (background.data.color));
				nk_stroke_rect(_out_, (nk_rect) (*bounds), (float) (style.rounding), (float) (style.border),
					(nk_color) (style.border_color));
			}
			else
			{
				nk_draw_image(_out_, (nk_rect) (*bounds), background.data.image, (nk_color) (nk_white));
			}

			if ((background.type) == (NK_STYLE_ITEM_COLOR))
			{
				nk_fill_rect(_out_, (nk_rect) (*scroll), (float) (style.rounding_cursor), (nk_color) (cursor.data.color));
				nk_stroke_rect(_out_, (nk_rect) (*scroll), (float) (style.rounding_cursor), (float) (style.border_cursor),
					(nk_color) (style.cursor_border_color));
			}
			else nk_draw_image(_out_, (nk_rect) (*scroll), cursor.data.image, (nk_color) (nk_white));
		}

		public static float nk_do_scrollbarv(ref uint state, nk_command_buffer _out_, nk_rect scroll, int has_scrolling,
			float offset, float target, float step, float button_pixel_inc, nk_style_scrollbar style, nk_input _in_,
			nk_user_font font)
		{
			nk_rect empty_north = new nk_rect();
			nk_rect empty_south = new nk_rect();
			nk_rect cursor = new nk_rect();
			float scroll_step;
			float scroll_offset;
			float scroll_off;
			float scroll_ratio;
			if ((_out_ == null) || (style == null)) return (float) (0);
			scroll.w = (float) ((scroll.w) < (1) ? (1) : (scroll.w));
			scroll.h = (float) ((scroll.h) < (0) ? (0) : (scroll.h));
			if (target <= scroll.h) return (float) (0);
			if ((style.show_buttons) != 0)
			{
				uint ws = 0;
				float scroll_h;
				nk_rect button = new nk_rect();
				button.x = (float) (scroll.x);
				button.w = (float) (scroll.w);
				button.h = (float) (scroll.w);
				scroll_h = (float) ((scroll.h - 2*button.h) < (0) ? (0) : (scroll.h - 2*button.h));
				scroll_step = (float) ((step) < (button_pixel_inc) ? (step) : (button_pixel_inc));
				button.y = (float) (scroll.y);
				if (
					(nk_do_button_symbol(ref ws, _out_, (nk_rect) (button), (int) (style.dec_symbol), (int) (NK_BUTTON_REPEATER),
						style.dec_button, _in_, font)) != 0) offset = (float) (offset - scroll_step);
				button.y = (float) (scroll.y + scroll.h - button.h);
				if (
					(nk_do_button_symbol(ref ws, _out_, (nk_rect) (button), (int) (style.inc_symbol), (int) (NK_BUTTON_REPEATER),
						style.inc_button, _in_, font)) != 0) offset = (float) (offset + scroll_step);
				scroll.y = (float) (scroll.y + button.h);
				scroll.h = (float) (scroll_h);
			}

			scroll_step = (float) ((step) < (scroll.h) ? (step) : (scroll.h));
			scroll_offset =
				(float)
					(((offset) < (target - scroll.h) ? (offset) : (target - scroll.h)) < (0)
						? (0)
						: ((offset) < (target - scroll.h) ? (offset) : (target - scroll.h)));
			scroll_ratio = (float) (scroll.h/target);
			scroll_off = (float) (scroll_offset/target);
			cursor.h =
				(float)
					(((scroll_ratio*scroll.h) - (2*style.border + 2*style.padding.y)) < (0)
						? (0)
						: ((scroll_ratio*scroll.h) - (2*style.border + 2*style.padding.y)));
			cursor.y = (float) (scroll.y + (scroll_off*scroll.h) + style.border + style.padding.y);
			cursor.w = (float) (scroll.w - (2*style.border + 2*style.padding.x));
			cursor.x = (float) (scroll.x + style.border + style.padding.x);
			empty_north.x = (float) (scroll.x);
			empty_north.y = (float) (scroll.y);
			empty_north.w = (float) (scroll.w);
			empty_north.h = (float) ((cursor.y - scroll.y) < (0) ? (0) : (cursor.y - scroll.y));
			empty_south.x = (float) (scroll.x);
			empty_south.y = (float) (cursor.y + cursor.h);
			empty_south.w = (float) (scroll.w);
			empty_south.h =
				(float)
					(((scroll.y + scroll.h) - (cursor.y + cursor.h)) < (0) ? (0) : ((scroll.y + scroll.h) - (cursor.y + cursor.h)));
			scroll_offset =
				(float)
					(nk_scrollbar_behavior(ref state, _in_, (int) (has_scrolling), &scroll, &cursor, &empty_north, &empty_south,
						(float) (scroll_offset), (float) (target), (float) (scroll_step), (int) (NK_VERTICAL)));
			scroll_off = (float) (scroll_offset/target);
			cursor.y = (float) (scroll.y + (scroll_off*scroll.h) + style.border_cursor + style.padding.y);
			if ((style.draw_begin) != null) style.draw_begin(_out_, (nk_handle) (style.userdata));
			nk_draw_scrollbar(_out_, (uint) (state), style, &scroll, &cursor);
			if ((style.draw_end) != null) style.draw_end(_out_, (nk_handle) (style.userdata));
			return (float) (scroll_offset);
		}

		public static float nk_do_scrollbarh(ref uint state, nk_command_buffer _out_, nk_rect scroll, int has_scrolling,
			float offset, float target, float step, float button_pixel_inc, nk_style_scrollbar style, nk_input _in_,
			nk_user_font font)
		{
			nk_rect cursor = new nk_rect();
			nk_rect empty_west = new nk_rect();
			nk_rect empty_east = new nk_rect();
			float scroll_step;
			float scroll_offset;
			float scroll_off;
			float scroll_ratio;
			if ((_out_ == null) || (style == null)) return (float) (0);
			scroll.h = (float) ((scroll.h) < (1) ? (1) : (scroll.h));
			scroll.w = (float) ((scroll.w) < (2*scroll.h) ? (2*scroll.h) : (scroll.w));
			if (target <= scroll.w) return (float) (0);
			if ((style.show_buttons) != 0)
			{
				uint ws = 0;
				float scroll_w;
				nk_rect button = new nk_rect();
				button.y = (float) (scroll.y);
				button.w = (float) (scroll.h);
				button.h = (float) (scroll.h);
				scroll_w = (float) (scroll.w - 2*button.w);
				scroll_step = (float) ((step) < (button_pixel_inc) ? (step) : (button_pixel_inc));
				button.x = (float) (scroll.x);
				if (
					(nk_do_button_symbol(ref ws, _out_, (nk_rect) (button), (int) (style.dec_symbol), (int) (NK_BUTTON_REPEATER),
						style.dec_button, _in_, font)) != 0) offset = (float) (offset - scroll_step);
				button.x = (float) (scroll.x + scroll.w - button.w);
				if (
					(nk_do_button_symbol(ref ws, _out_, (nk_rect) (button), (int) (style.inc_symbol), (int) (NK_BUTTON_REPEATER),
						style.inc_button, _in_, font)) != 0) offset = (float) (offset + scroll_step);
				scroll.x = (float) (scroll.x + button.w);
				scroll.w = (float) (scroll_w);
			}

			scroll_step = (float) ((step) < (scroll.w) ? (step) : (scroll.w));
			scroll_offset =
				(float)
					(((offset) < (target - scroll.w) ? (offset) : (target - scroll.w)) < (0)
						? (0)
						: ((offset) < (target - scroll.w) ? (offset) : (target - scroll.w)));
			scroll_ratio = (float) (scroll.w/target);
			scroll_off = (float) (scroll_offset/target);
			cursor.w = (float) ((scroll_ratio*scroll.w) - (2*style.border + 2*style.padding.x));
			cursor.x = (float) (scroll.x + (scroll_off*scroll.w) + style.border + style.padding.x);
			cursor.h = (float) (scroll.h - (2*style.border + 2*style.padding.y));
			cursor.y = (float) (scroll.y + style.border + style.padding.y);
			empty_west.x = (float) (scroll.x);
			empty_west.y = (float) (scroll.y);
			empty_west.w = (float) (cursor.x - scroll.x);
			empty_west.h = (float) (scroll.h);
			empty_east.x = (float) (cursor.x + cursor.w);
			empty_east.y = (float) (scroll.y);
			empty_east.w = (float) ((scroll.x + scroll.w) - (cursor.x + cursor.w));
			empty_east.h = (float) (scroll.h);
			scroll_offset =
				(float)
					(nk_scrollbar_behavior(ref state, _in_, (int) (has_scrolling), &scroll, &cursor, &empty_west, &empty_east,
						(float) (scroll_offset), (float) (target), (float) (scroll_step), (int) (NK_HORIZONTAL)));
			scroll_off = (float) (scroll_offset/target);
			cursor.x = (float) (scroll.x + (scroll_off*scroll.w));
			if ((style.draw_begin) != null) style.draw_begin(_out_, (nk_handle) (style.userdata));
			nk_draw_scrollbar(_out_, (uint) (state), style, &scroll, &cursor);
			if ((style.draw_end) != null) style.draw_end(_out_, (nk_handle) (style.userdata));
			return (float) (scroll_offset);
		}

		public static int nk_filter_default(nk_text_edit box, char unicode)
		{
			return (int) (nk_true);
		}

		public static int nk_filter_ascii(nk_text_edit box, char unicode)
		{
			if ((unicode) > (128)) return (int) (nk_false);
			else return (int) (nk_true);
		}

		public static int nk_filter_float(nk_text_edit box, char unicode)
		{
			if (((((unicode) < ('0')) || ((unicode) > ('9'))) && (unicode != '.')) && (unicode != '-')) return (int) (nk_false);
			else return (int) (nk_true);
		}

		public static int nk_filter_decimal(nk_text_edit box, char unicode)
		{
			if ((((unicode) < ('0')) || ((unicode) > ('9'))) && (unicode != '-')) return (int) (nk_false);
			else return (int) (nk_true);
		}

		public static int nk_filter_hex(nk_text_edit box, char unicode)
		{
			if (((((unicode) < ('0')) || ((unicode) > ('9'))) && (((unicode) < ('a')) || ((unicode) > ('f')))) &&
			    (((unicode) < ('A')) || ((unicode) > ('F')))) return (int) (nk_false);
			else return (int) (nk_true);
		}

		public static int nk_filter_oct(nk_text_edit box, char unicode)
		{
			if (((unicode) < ('0')) || ((unicode) > ('7'))) return (int) (nk_false);
			else return (int) (nk_true);
		}

		public static int nk_filter_binary(nk_text_edit box, char unicode)
		{
			if ((unicode != '0') && (unicode != '1')) return (int) (nk_false);
			else return (int) (nk_true);
		}

		public static void nk_edit_draw_text(nk_command_buffer _out_, nk_style_edit style, float pos_x, float pos_y,
			float x_offset, char* text, int byte_len, float row_height, nk_user_font font, nk_color background,
			nk_color foreground, int is_selected)
		{
			if ((((text == null) || (byte_len == 0)) || (_out_ == null)) || (style == null)) return;
			{
				int glyph_len = (int) (0);
				char unicode = (char) 0;
				int text_len = (int) (0);
				float line_width = (float) (0);
				float glyph_width;
				char* line = text;
				float line_offset = (float) (0);
				int line_count = (int) (0);
				nk_text txt = new nk_text();
				txt.padding = (nk_vec2) (nk_vec2_((float) (0), (float) (0)));
				txt.background = (nk_color) (background);
				txt.text = (nk_color) (foreground);
				glyph_len = (int) (nk_utf_decode(text + text_len, &unicode, (int) (byte_len - text_len)));
				if (glyph_len == 0) return;
				while (((text_len) < (byte_len)) && ((glyph_len) != 0))
				{
					if ((unicode) == ('\n'))
					{
						nk_rect label = new nk_rect();
						label.y = (float) (pos_y + line_offset);
						label.h = (float) (row_height);
						label.w = (float) (line_width);
						label.x = (float) (pos_x);
						if (line_count == 0) label.x += (float) (x_offset);
						if ((is_selected) != 0) nk_fill_rect(_out_, (nk_rect) (label), (float) (0), (nk_color) (background));
						nk_widget_text(_out_, (nk_rect) (label), line, (int) ((text + text_len) - line), &txt, (uint) (NK_TEXT_CENTERED),
							font);
						text_len++;
						line_count++;
						line_width = (float) (0);
						line = text + text_len;
						line_offset += (float) (row_height);
						glyph_len = (int) (nk_utf_decode(text + text_len, &unicode, (int) (byte_len - text_len)));
						continue;
					}
					if ((unicode) == ('\r'))
					{
						text_len++;
						glyph_len = (int) (nk_utf_decode(text + text_len, &unicode, (int) (byte_len - text_len)));
						continue;
					}
					glyph_width =
						(float) (font.width((nk_handle) (font.userdata), (float) (font.height), text + text_len, (int) (glyph_len)));
					line_width += (float) (glyph_width);
					text_len += (int) (glyph_len);
					glyph_len = (int) (nk_utf_decode(text + text_len, &unicode, (int) (byte_len - text_len)));
					continue;
				}
				if ((line_width) > (0))
				{
					nk_rect label = new nk_rect();
					label.y = (float) (pos_y + line_offset);
					label.h = (float) (row_height);
					label.w = (float) (line_width);
					label.x = (float) (pos_x);
					if (line_count == 0) label.x += (float) (x_offset);
					if ((is_selected) != 0) nk_fill_rect(_out_, (nk_rect) (label), (float) (0), (nk_color) (background));
					nk_widget_text(_out_, (nk_rect) (label), line, (int) ((text + text_len) - line), &txt, (uint) (NK_TEXT_LEFT), font);
				}
			}

		}

		public static uint nk_do_edit(ref uint state, nk_command_buffer _out_, nk_rect bounds, uint flags,
			NkPluginFilter filter, nk_text_edit edit, nk_style_edit style, nk_input _in_, nk_user_font font)
		{
			nk_rect area = new nk_rect();
			uint ret = (uint) (0);
			float row_height;
			sbyte prev_state = (sbyte) (0);
			sbyte is_hovered = (sbyte) (0);
			sbyte select_all = (sbyte) (0);
			sbyte cursor_follow = (sbyte) (0);
			nk_rect old_clip = new nk_rect();
			nk_rect clip = new nk_rect();
			if (((state == null) || (_out_ == null)) || (style == null)) return (uint) (ret);
			area.x = (float) (bounds.x + style.padding.x + style.border);
			area.y = (float) (bounds.y + style.padding.y + style.border);
			area.w = (float) (bounds.w - (2.0f*style.padding.x + 2*style.border));
			area.h = (float) (bounds.h - (2.0f*style.padding.y + 2*style.border));
			if ((flags & NK_EDIT_MULTILINE) != 0)
				area.w = (float) ((0) < (area.w - style.scrollbar_size.x) ? (area.w - style.scrollbar_size.x) : (0));
			row_height = (float) ((flags & NK_EDIT_MULTILINE) != 0 ? font.height + style.row_padding : area.h);
			old_clip = (nk_rect) (_out_.clip);
			nk_unify(ref clip, ref old_clip, (float) (area.x), (float) (area.y), (float) (area.x + area.w),
				(float) (area.y + area.h));
			prev_state = ((sbyte) (edit.active));
			is_hovered = ((sbyte) (nk_input_is_mouse_hovering_rect(_in_, (nk_rect) (bounds))));
			if ((((_in_) != null) && ((((nk_mouse_button*) _in_.mouse.buttons + NK_BUTTON_LEFT)->clicked) != 0)) &&
			    ((((nk_mouse_button*) _in_.mouse.buttons + NK_BUTTON_LEFT)->down) != 0))
			{
				edit.active =
					(byte)
						((((bounds.x) <= (_in_.mouse.pos.x)) && ((_in_.mouse.pos.x) < (bounds.x + bounds.w))) &&
						 (((bounds.y) <= (_in_.mouse.pos.y)) && ((_in_.mouse.pos.y) < (bounds.y + bounds.h)))
							? 1
							: 0);
			}

			if ((prev_state == 0) && ((edit.active) != 0))
			{
				int type = (int) ((flags & NK_EDIT_MULTILINE) != 0 ? NK_TEXT_EDIT_MULTI_LINE : NK_TEXT_EDIT_SINGLE_LINE);
				nk_textedit_clear_state(edit, (int) (type), filter);
				if ((flags & NK_EDIT_AUTO_SELECT) != 0) select_all = (sbyte) (nk_true);
				if ((flags & NK_EDIT_GOTO_END_ON_ACTIVATE) != 0)
				{
					edit.cursor = (int) (edit._string_.len);
					_in_ = null;
				}
			}
			else if (edit.active == 0) edit.mode = (byte) (NK_TEXT_EDIT_MODE_VIEW);
			if ((flags & NK_EDIT_READ_ONLY) != 0) edit.mode = (byte) (NK_TEXT_EDIT_MODE_VIEW);
			else if ((flags & NK_EDIT_ALWAYS_INSERT_MODE) != 0) edit.mode = (byte) (NK_TEXT_EDIT_MODE_INSERT);
			ret = (uint) ((edit.active) != 0 ? NK_EDIT_ACTIVE : NK_EDIT_INACTIVE);
			if (prev_state != edit.active) ret |= (uint) ((edit.active) != 0 ? NK_EDIT_ACTIVATED : NK_EDIT_DEACTIVATED);
			if (((edit.active) != 0) && ((_in_) != null))
			{
				int shift_mod = (int) (_in_.keyboard.keys[NK_KEY_SHIFT].down);
				float mouse_x = (float) ((_in_.mouse.pos.x - area.x) + edit.scrollbar.x);
				float mouse_y = (float) ((_in_.mouse.pos.y - area.y) + edit.scrollbar.y);
				is_hovered = ((sbyte) (nk_input_is_mouse_hovering_rect(_in_, (nk_rect) (area))));
				if ((select_all) != 0)
				{
					nk_textedit_select_all(edit);
				}
				else if ((((is_hovered) != 0) && ((((nk_mouse_button*) _in_.mouse.buttons + NK_BUTTON_LEFT)->down) != 0)) &&
				         ((((nk_mouse_button*) _in_.mouse.buttons + NK_BUTTON_LEFT)->clicked) != 0))
				{
					nk_textedit_click(edit, (float) (mouse_x), (float) (mouse_y), font, (float) (row_height));
				}
				else if ((((is_hovered) != 0) && ((((nk_mouse_button*) _in_.mouse.buttons + NK_BUTTON_LEFT)->down) != 0)) &&
				         ((_in_.mouse.delta.x != 0.0f) || (_in_.mouse.delta.y != 0.0f)))
				{
					nk_textedit_drag(edit, (float) (mouse_x), (float) (mouse_y), font, (float) (row_height));
					cursor_follow = (sbyte) (nk_true);
				}
				else if ((((is_hovered) != 0) && ((_in_.mouse.buttons[NK_BUTTON_RIGHT].clicked) != 0)) &&
				         ((_in_.mouse.buttons[NK_BUTTON_RIGHT].down) != 0))
				{
					nk_textedit_key(edit, (int) (NK_KEY_TEXT_WORD_LEFT), (int) (nk_false), font, (float) (row_height));
					nk_textedit_key(edit, (int) (NK_KEY_TEXT_WORD_RIGHT), (int) (nk_true), font, (float) (row_height));
					cursor_follow = (sbyte) (nk_true);
				}
				{
					int i;
					int old_mode = (int) (edit.mode);
					for (i = (int) (0); (i) < (NK_KEY_MAX); ++i)
					{
						if (((i) == (NK_KEY_ENTER)) || ((i) == (NK_KEY_TAB))) continue;
						if ((nk_input_is_key_pressed(_in_, (int) (i))) != 0)
						{
							nk_textedit_key(edit, (int) (i), (int) (shift_mod), font, (float) (row_height));
							cursor_follow = (sbyte) (nk_true);
						}
					}
					if (old_mode != edit.mode)
					{
						_in_.keyboard.text_len = (int) (0);
					}
				}
				edit.filter = filter;
				if ((_in_.keyboard.text_len) != 0)
				{
					nk_textedit_text(edit, _in_.keyboard.text, (int) (_in_.keyboard.text_len));
					cursor_follow = (sbyte) (nk_true);
					_in_.keyboard.text_len = (int) (0);
				}
				if ((nk_input_is_key_pressed(_in_, (int) (NK_KEY_ENTER))) != 0)
				{
					cursor_follow = (sbyte) (nk_true);
					if (((flags & NK_EDIT_CTRL_ENTER_NEWLINE) != 0) && ((shift_mod) != 0)) nk_textedit_text(edit, "\n", (int) (1));
					else if ((flags & NK_EDIT_SIG_ENTER) != 0) ret |= (uint) (NK_EDIT_COMMITED);
					else nk_textedit_text(edit, "\n", (int) (1));
				}
				{
					int copy = (int) (nk_input_is_key_pressed(_in_, (int) (NK_KEY_COPY)));
					int cut = (int) (nk_input_is_key_pressed(_in_, (int) (NK_KEY_CUT)));
					if ((((copy) != 0) || ((cut) != 0)) && ((flags & NK_EDIT_CLIPBOARD) != 0))
					{
						int glyph_len;
						char unicode;
						char* text;
						int b = (int) (edit.select_start);
						int e = (int) (edit.select_end);
						int begin = (int) ((b) < (e) ? (b) : (e));
						int end = (int) ((b) < (e) ? (e) : (b));
						text = nk_str_at_const(edit._string_, (int) (begin), &unicode, &glyph_len);
						if ((edit.clip.copy) != null) edit.clip.copy((nk_handle) (edit.clip.userdata), text, (int) (end - begin));
						if (((cut) != 0) && ((flags & NK_EDIT_READ_ONLY) == 0))
						{
							nk_textedit_cut(edit);
							cursor_follow = (sbyte) (nk_true);
						}
					}
				}
				{
					int paste = (int) (nk_input_is_key_pressed(_in_, (int) (NK_KEY_PASTE)));
					if ((((paste) != 0) && ((flags & NK_EDIT_CLIPBOARD) != 0)) && ((edit.clip.paste) != null))
					{
						edit.clip.paste((nk_handle) (edit.clip.userdata), edit);
						cursor_follow = (sbyte) (nk_true);
					}
				}
				{
					int tab = (int) (nk_input_is_key_pressed(_in_, (int) (NK_KEY_TAB)));
					if (((tab) != 0) && ((flags & NK_EDIT_ALLOW_TAB) != 0))
					{
						nk_textedit_text(edit, "    ", (int) (4));
						cursor_follow = (sbyte) (nk_true);
					}
				}
			}

			if ((edit.active) != 0) state = (uint) (NK_WIDGET_STATE_ACTIVE);
			else if (((state) & NK_WIDGET_STATE_MODIFIED) != 0)
				(state) = (uint) (NK_WIDGET_STATE_INACTIVE | NK_WIDGET_STATE_MODIFIED);
			else (state) = (uint) (NK_WIDGET_STATE_INACTIVE);
			if ((is_hovered) != 0) state |= (uint) (NK_WIDGET_STATE_HOVERED);
			{
				char* text = nk_str_get_const(edit._string_);
				int len = (int) (nk_str_len_char(edit._string_));
				{
					nk_style_item background;
					if ((state & NK_WIDGET_STATE_ACTIVED) != 0) background = style.active;
					else if ((state & NK_WIDGET_STATE_HOVER) != 0) background = style.hover;
					else background = style.normal;
					if ((background.type) == (NK_STYLE_ITEM_COLOR))
					{
						nk_stroke_rect(_out_, (nk_rect) (bounds), (float) (style.rounding), (float) (style.border),
							(nk_color) (style.border_color));
						nk_fill_rect(_out_, (nk_rect) (bounds), (float) (style.rounding), (nk_color) (background.data.color));
					}
					else nk_draw_image(_out_, (nk_rect) (bounds), background.data.image, (nk_color) (nk_white));
				}
				area.w = (float) ((0) < (area.w - style.cursor_size) ? (area.w - style.cursor_size) : (0));
				if ((edit.active) != 0)
				{
					int total_lines = (int) (1);
					nk_vec2 text_size = (nk_vec2) (nk_vec2_((float) (0), (float) (0)));
					char* cursor_ptr = null;
					char* select_begin_ptr = null;
					char* select_end_ptr = null;
					nk_vec2 cursor_pos = (nk_vec2) (nk_vec2_((float) (0), (float) (0)));
					nk_vec2 selection_offset_start = (nk_vec2) (nk_vec2_((float) (0), (float) (0)));
					nk_vec2 selection_offset_end = (nk_vec2) (nk_vec2_((float) (0), (float) (0)));
					int selection_begin = (int) ((edit.select_start) < (edit.select_end) ? (edit.select_start) : (edit.select_end));
					int selection_end = (int) ((edit.select_start) < (edit.select_end) ? (edit.select_end) : (edit.select_start));
					float line_width = (float) (0.0f);
					if (((text) != null) && ((len) != 0))
					{
						float glyph_width;
						int glyph_len = (int) (0);
						char unicode = (char) 0;
						int text_len = (int) (0);
						int glyphs = (int) (0);
						int row_begin = (int) (0);
						glyph_len = (int) (nk_utf_decode(text, &unicode, (int) (len)));
						glyph_width = (float) (font.width((nk_handle) (font.userdata), (float) (font.height), text, (int) (glyph_len)));
						line_width = (float) (0);
						while (((text_len) < (len)) && ((glyph_len) != 0))
						{
							if ((cursor_ptr == null) && ((glyphs) == (edit.cursor)))
							{
								int glyph_offset;
								nk_vec2 out_offset = new nk_vec2();
								nk_vec2 row_size = new nk_vec2();
								char* remaining;
								cursor_pos.y = (float) ((float) (total_lines - 1)*row_height);
								row_size =
									(nk_vec2)
										(nk_text_calculate_text_bounds(font, text + row_begin, (int) (text_len - row_begin), (float) (row_height),
											&remaining, &out_offset, &glyph_offset, (int) (NK_STOP_ON_NEW_LINE)));
								cursor_pos.x = (float) (row_size.x);
								cursor_ptr = text + text_len;
							}
							if (((select_begin_ptr == null) && (edit.select_start != edit.select_end)) && ((glyphs) == (selection_begin)))
							{
								int glyph_offset;
								nk_vec2 out_offset = new nk_vec2();
								nk_vec2 row_size = new nk_vec2();
								char* remaining;
								selection_offset_start.y = (float) ((float) ((total_lines - 1) < (0) ? (0) : (total_lines - 1))*row_height);
								row_size =
									(nk_vec2)
										(nk_text_calculate_text_bounds(font, text + row_begin, (int) (text_len - row_begin), (float) (row_height),
											&remaining, &out_offset, &glyph_offset, (int) (NK_STOP_ON_NEW_LINE)));
								selection_offset_start.x = (float) (row_size.x);
								select_begin_ptr = text + text_len;
							}
							if (((select_end_ptr == null) && (edit.select_start != edit.select_end)) && ((glyphs) == (selection_end)))
							{
								int glyph_offset;
								nk_vec2 out_offset = new nk_vec2();
								nk_vec2 row_size = new nk_vec2();
								char* remaining;
								selection_offset_end.y = (float) ((float) (total_lines - 1)*row_height);
								row_size =
									(nk_vec2)
										(nk_text_calculate_text_bounds(font, text + row_begin, (int) (text_len - row_begin), (float) (row_height),
											&remaining, &out_offset, &glyph_offset, (int) (NK_STOP_ON_NEW_LINE)));
								selection_offset_end.x = (float) (row_size.x);
								select_end_ptr = text + text_len;
							}
							if ((unicode) == ('\n'))
							{
								text_size.x = (float) ((text_size.x) < (line_width) ? (line_width) : (text_size.x));
								total_lines++;
								line_width = (float) (0);
								text_len++;
								glyphs++;
								row_begin = (int) (text_len);
								glyph_len = (int) (nk_utf_decode(text + text_len, &unicode, (int) (len - text_len)));
								glyph_width =
									(float) (font.width((nk_handle) (font.userdata), (float) (font.height), text + text_len, (int) (glyph_len)));
								continue;
							}
							glyphs++;
							text_len += (int) (glyph_len);
							line_width += (float) (glyph_width);
							glyph_len = (int) (nk_utf_decode(text + text_len, &unicode, (int) (len - text_len)));
							glyph_width =
								(float) (font.width((nk_handle) (font.userdata), (float) (font.height), text + text_len, (int) (glyph_len)));
							continue;
						}
						text_size.y = (float) ((float) (total_lines)*row_height);
						if ((cursor_ptr == null) && ((edit.cursor) == (edit._string_.len)))
						{
							cursor_pos.x = (float) (line_width);
							cursor_pos.y = (float) (text_size.y - row_height);
						}
					}
					{
						if ((cursor_follow) != 0)
						{
							if ((flags & NK_EDIT_NO_HORIZONTAL_SCROLL) == 0)
							{
								float scroll_increment = (float) (area.w*0.25f);
								if ((cursor_pos.x) < (edit.scrollbar.x))
									edit.scrollbar.x =
										((float) ((int) ((0.0f) < (cursor_pos.x - scroll_increment) ? (cursor_pos.x - scroll_increment) : (0.0f))));
								if ((cursor_pos.x) >= (edit.scrollbar.x + area.w))
									edit.scrollbar.x = ((float) ((int) ((0.0f) < (cursor_pos.x) ? (cursor_pos.x) : (0.0f))));
							}
							else edit.scrollbar.x = (float) (0);
							if ((flags & NK_EDIT_MULTILINE) != 0)
							{
								if ((cursor_pos.y) < (edit.scrollbar.y))
									edit.scrollbar.y = (float) ((0.0f) < (cursor_pos.y - row_height) ? (cursor_pos.y - row_height) : (0.0f));
								if ((cursor_pos.y) >= (edit.scrollbar.y + area.h)) edit.scrollbar.y = (float) (edit.scrollbar.y + row_height);
							}
							else edit.scrollbar.y = (float) (0);
						}
						if ((flags & NK_EDIT_MULTILINE) != 0)
						{
							uint ws = 0;
							nk_rect scroll = new nk_rect();
							float scroll_target;
							float scroll_offset;
							float scroll_step;
							float scroll_inc;
							scroll = (nk_rect) (area);
							scroll.x = (float) ((bounds.x + bounds.w - style.border) - style.scrollbar_size.x);
							scroll.w = (float) (style.scrollbar_size.x);
							scroll_offset = (float) (edit.scrollbar.y);
							scroll_step = (float) (scroll.h*0.10f);
							scroll_inc = (float) (scroll.h*0.01f);
							scroll_target = (float) (text_size.y);
							edit.scrollbar.y =
								(float)
									(nk_do_scrollbarv(ref ws, _out_, (nk_rect) (scroll), (int) (0), (float) (scroll_offset),
										(float) (scroll_target), (float) (scroll_step), (float) (scroll_inc), style.scrollbar, _in_, font));
						}
					}
					{
						nk_color background_color = new nk_color();
						nk_color text_color = new nk_color();
						nk_color sel_background_color = new nk_color();
						nk_color sel_text_color = new nk_color();
						nk_color cursor_color = new nk_color();
						nk_color cursor_text_color = new nk_color();
						nk_style_item background;
						nk_push_scissor(_out_, (nk_rect) (clip));
						if ((state & NK_WIDGET_STATE_ACTIVED) != 0)
						{
							background = style.active;
							text_color = (nk_color) (style.text_active);
							sel_text_color = (nk_color) (style.selected_text_hover);
							sel_background_color = (nk_color) (style.selected_hover);
							cursor_color = (nk_color) (style.cursor_hover);
							cursor_text_color = (nk_color) (style.cursor_text_hover);
						}
						else if ((state & NK_WIDGET_STATE_HOVER) != 0)
						{
							background = style.hover;
							text_color = (nk_color) (style.text_hover);
							sel_text_color = (nk_color) (style.selected_text_hover);
							sel_background_color = (nk_color) (style.selected_hover);
							cursor_text_color = (nk_color) (style.cursor_text_hover);
							cursor_color = (nk_color) (style.cursor_hover);
						}
						else
						{
							background = style.normal;
							text_color = (nk_color) (style.text_normal);
							sel_text_color = (nk_color) (style.selected_text_normal);
							sel_background_color = (nk_color) (style.selected_normal);
							cursor_color = (nk_color) (style.cursor_normal);
							cursor_text_color = (nk_color) (style.cursor_text_normal);
						}
						if ((background.type) == (NK_STYLE_ITEM_IMAGE))
							background_color = (nk_color) (nk_rgba((int) (0), (int) (0), (int) (0), (int) (0)));
						else background_color = (nk_color) (background.data.color);
						if ((edit.select_start) == (edit.select_end))
						{
							char* begin = nk_str_get_const(edit._string_);
							int l = (int) (nk_str_len_char(edit._string_));
							nk_edit_draw_text(_out_, style, (float) (area.x - edit.scrollbar.x), (float) (area.y - edit.scrollbar.y),
								(float) (0), begin, (int) (l), (float) (row_height), font, (nk_color) (background_color),
								(nk_color) (text_color), (int) (nk_false));
						}
						else
						{
							if ((edit.select_start != edit.select_end) && ((selection_begin) > (0)))
							{
								char* begin = nk_str_get_const(edit._string_);
								nk_edit_draw_text(_out_, style, (float) (area.x - edit.scrollbar.x), (float) (area.y - edit.scrollbar.y),
									(float) (0), begin, (int) (select_begin_ptr - begin), (float) (row_height), font, (nk_color) (background_color),
									(nk_color) (text_color), (int) (nk_false));
							}
							if (edit.select_start != edit.select_end)
							{
								if (select_end_ptr == null)
								{
									char* begin = nk_str_get_const(edit._string_);
									select_end_ptr = begin + nk_str_len_char(edit._string_);
								}
								nk_edit_draw_text(_out_, style, (float) (area.x - edit.scrollbar.x),
									(float) (area.y + selection_offset_start.y - edit.scrollbar.y), (float) (selection_offset_start.x),
									select_begin_ptr, (int) (select_end_ptr - select_begin_ptr), (float) (row_height), font,
									(nk_color) (sel_background_color), (nk_color) (sel_text_color), (int) (nk_true));
							}
							if (((edit.select_start != edit.select_end) && ((selection_end) < (edit._string_.len))))
							{
								char* begin = select_end_ptr;
								char* end = nk_str_get_const(edit._string_) + nk_str_len_char(edit._string_);
								nk_edit_draw_text(_out_, style, (float) (area.x - edit.scrollbar.x),
									(float) (area.y + selection_offset_end.y - edit.scrollbar.y), (float) (selection_offset_end.x), begin,
									(int) (end - begin), (float) (row_height), font, (nk_color) (background_color), (nk_color) (text_color),
									(int) (nk_true));
							}
						}
						if ((edit.select_start) == (edit.select_end))
						{
							if (((edit.cursor) >= (nk_str_len(edit._string_))) || (((cursor_ptr) != null) && ((*cursor_ptr) == ('\n'))))
							{
								nk_rect cursor = new nk_rect();
								cursor.w = (float) (style.cursor_size);
								cursor.h = (float) (font.height);
								cursor.x = (float) (area.x + cursor_pos.x - edit.scrollbar.x);
								cursor.y = (float) (area.y + cursor_pos.y + row_height/2.0f - cursor.h/2.0f);
								cursor.y -= (float) (edit.scrollbar.y);
								nk_fill_rect(_out_, (nk_rect) (cursor), (float) (0), (nk_color) (cursor_color));
							}
							else
							{
								int glyph_len;
								nk_rect label = new nk_rect();
								nk_text txt = new nk_text();
								char unicode;
								glyph_len = (int) (nk_utf_decode(cursor_ptr, &unicode, (int) (4)));
								label.x = (float) (area.x + cursor_pos.x - edit.scrollbar.x);
								label.y = (float) (area.y + cursor_pos.y - edit.scrollbar.y);
								label.w =
									(float) (font.width((nk_handle) (font.userdata), (float) (font.height), cursor_ptr, (int) (glyph_len)));
								label.h = (float) (row_height);
								txt.padding = (nk_vec2) (nk_vec2_((float) (0), (float) (0)));
								txt.background = (nk_color) (cursor_color);
								txt.text = (nk_color) (cursor_text_color);
								nk_fill_rect(_out_, (nk_rect) (label), (float) (0), (nk_color) (cursor_color));
								nk_widget_text(_out_, (nk_rect) (label), cursor_ptr, (int) (glyph_len), &txt, (uint) (NK_TEXT_LEFT), font);
							}
						}
					}
				}
				else
				{
					int l = (int) (nk_str_len_char(edit._string_));
					char* begin = nk_str_get_const(edit._string_);
					nk_style_item background;
					nk_color background_color = new nk_color();
					nk_color text_color = new nk_color();
					nk_push_scissor(_out_, (nk_rect) (clip));
					if ((state & NK_WIDGET_STATE_ACTIVED) != 0)
					{
						background = style.active;
						text_color = (nk_color) (style.text_active);
					}
					else if ((state & NK_WIDGET_STATE_HOVER) != 0)
					{
						background = style.hover;
						text_color = (nk_color) (style.text_hover);
					}
					else
					{
						background = style.normal;
						text_color = (nk_color) (style.text_normal);
					}
					if ((background.type) == (NK_STYLE_ITEM_IMAGE))
						background_color = (nk_color) (nk_rgba((int) (0), (int) (0), (int) (0), (int) (0)));
					else background_color = (nk_color) (background.data.color);
					nk_edit_draw_text(_out_, style, (float) (area.x - edit.scrollbar.x), (float) (area.y - edit.scrollbar.y),
						(float) (0), begin, (int) (l), (float) (row_height), font, (nk_color) (background_color), (nk_color) (text_color),
						(int) (nk_false));
				}
				nk_push_scissor(_out_, (nk_rect) (old_clip));
			}

			return (uint) (ret);
		}

		public static void nk_drag_behavior(ref uint state, nk_input _in_, nk_rect drag, nk_property_variant* variant,
			float inc_per_pixel)
		{
			int left_mouse_down =
				(int) (((_in_) != null) && ((((nk_mouse_button*) _in_.mouse.buttons + NK_BUTTON_LEFT)->down) != 0) ? 1 : 0);
			int left_mouse_click_in_cursor =
				(int)
					(((_in_) != null) &&
					 ((nk_input_has_mouse_click_down_in_rect(_in_, (int) (NK_BUTTON_LEFT), (nk_rect) (drag), (int) (nk_true))) != 0)
						? 1
						: 0);
			if (((state) & NK_WIDGET_STATE_MODIFIED) != 0)
				(state) = (uint) (NK_WIDGET_STATE_INACTIVE | NK_WIDGET_STATE_MODIFIED);
			else (state) = (uint) (NK_WIDGET_STATE_INACTIVE);
			if ((nk_input_is_mouse_hovering_rect(_in_, (nk_rect) (drag))) != 0) state = (uint) (NK_WIDGET_STATE_HOVERED);
			if (((left_mouse_down) != 0) && ((left_mouse_click_in_cursor) != 0))
			{
				float delta;
				float pixels;
				pixels = (float) (_in_.mouse.delta.x);
				delta = (float) (pixels*inc_per_pixel);
				switch (variant->kind)
				{
					default:
						break;
					case NK_PROPERTY_INT:
						variant->value.i = (int) (variant->value.i + (int) (delta));
						variant->value.i =
							(int)
								(((variant->value.i) < (variant->max_value.i) ? (variant->value.i) : (variant->max_value.i)) <
								 (variant->min_value.i)
									? (variant->min_value.i)
									: ((variant->value.i) < (variant->max_value.i) ? (variant->value.i) : (variant->max_value.i)));
						break;
					case NK_PROPERTY_FLOAT:
						variant->value.f = (float) (variant->value.f + delta);
						variant->value.f =
							(float)
								(((variant->value.f) < (variant->max_value.f) ? (variant->value.f) : (variant->max_value.f)) <
								 (variant->min_value.f)
									? (variant->min_value.f)
									: ((variant->value.f) < (variant->max_value.f) ? (variant->value.f) : (variant->max_value.f)));
						break;
					case NK_PROPERTY_DOUBLE:
						variant->value.d = (double) (variant->value.d + (double) (delta));
						variant->value.d =
							(double)
								(((variant->value.d) < (variant->max_value.d) ? (variant->value.d) : (variant->max_value.d)) <
								 (variant->min_value.d)
									? (variant->min_value.d)
									: ((variant->value.d) < (variant->max_value.d) ? (variant->value.d) : (variant->max_value.d)));
						break;
				}
				state = (uint) (NK_WIDGET_STATE_ACTIVE);
			}

			if (((state & NK_WIDGET_STATE_HOVER) != 0) && (nk_input_is_mouse_prev_hovering_rect(_in_, (nk_rect) (drag)) == 0))
				state |= (uint) (NK_WIDGET_STATE_ENTERED);
			else if ((nk_input_is_mouse_prev_hovering_rect(_in_, (nk_rect) (drag))) != 0) state |= (uint) (NK_WIDGET_STATE_LEFT);
		}

		public static void nk_property_behavior(ref uint ws, nk_input _in_, nk_rect property, nk_rect label, nk_rect edit,
			nk_rect empty, ref int state, nk_property_variant* variant, float inc_per_pixel)
		{
			if (((_in_) != null) && ((state) == (NK_PROPERTY_DEFAULT)))
			{
				if ((nk_button_behavior(ref ws, (nk_rect) (edit), _in_, (int) (NK_BUTTON_DEFAULT))) != 0)
					state = (int) (NK_PROPERTY_EDIT);
				else if ((nk_input_is_mouse_click_down_in_rect(_in_, (int) (NK_BUTTON_LEFT), (nk_rect) (label), (int) (nk_true))) != 0)
					state = (int) (NK_PROPERTY_DRAG);
				else if ((nk_input_is_mouse_click_down_in_rect(_in_, (int) (NK_BUTTON_LEFT), (nk_rect) (empty), (int) (nk_true))) != 0)
					state = (int) (NK_PROPERTY_DRAG);
			}

			if ((state) == (NK_PROPERTY_DRAG))
			{
				nk_drag_behavior(ref ws, _in_, (nk_rect) (property), variant, (float) (inc_per_pixel));
				if ((ws & NK_WIDGET_STATE_ACTIVED) == 0) state = (int) (NK_PROPERTY_DEFAULT);
			}

		}

		public static void nk_draw_property(nk_command_buffer _out_, nk_style_property style, nk_rect* bounds, nk_rect* label,
			uint state, char* name, int len, nk_user_font font)
		{
			nk_text text = new nk_text();
			nk_style_item background;
			if ((state & NK_WIDGET_STATE_ACTIVED) != 0)
			{
				background = style.active;
				text.text = (nk_color) (style.label_active);
			}
			else if ((state & NK_WIDGET_STATE_HOVER) != 0)
			{
				background = style.hover;
				text.text = (nk_color) (style.label_hover);
			}
			else
			{
				background = style.normal;
				text.text = (nk_color) (style.label_normal);
			}

			if ((background.type) == (NK_STYLE_ITEM_IMAGE))
			{
				nk_draw_image(_out_, (nk_rect) (*bounds), background.data.image, (nk_color) (nk_white));
				text.background = (nk_color) (nk_rgba((int) (0), (int) (0), (int) (0), (int) (0)));
			}
			else
			{
				text.background = (nk_color) (background.data.color);
				nk_fill_rect(_out_, (nk_rect) (*bounds), (float) (style.rounding), (nk_color) (background.data.color));
				nk_stroke_rect(_out_, (nk_rect) (*bounds), (float) (style.rounding), (float) (style.border),
					(nk_color) (background.data.color));
			}

			text.padding = (nk_vec2) (nk_vec2_((float) (0), (float) (0)));
			nk_widget_text(_out_, (nk_rect) (*label), name, (int) (len), &text, (uint) (NK_TEXT_CENTERED), font);
		}

		public static void nk_do_property(ref uint ws, nk_command_buffer _out_, nk_rect property, char* name,
			nk_property_variant* variant, float inc_per_pixel, char* buffer, int* len, ref int state, int* cursor,
			int* select_begin, int* select_end, nk_style_property style, int filter, nk_input _in_, nk_user_font font,
			nk_text_edit text_edit, int behavior)
		{
			NkPluginFilter[] filters = new NkPluginFilter[2];
			filters[0] = nk_filter_decimal;
			filters[1] = nk_filter_float;

			int active;
			int old;
			int num_len = 0;
			int name_len;
			char* _string_ = stackalloc char[64];
			float size;
			char* dst = null;
			int* length;
			nk_rect left = new nk_rect();
			nk_rect right = new nk_rect();
			nk_rect label = new nk_rect();
			nk_rect edit = new nk_rect();
			nk_rect empty = new nk_rect();
			left.h = (float) (font.height/2);
			left.w = (float) (left.h);
			left.x = (float) (property.x + style.border + style.padding.x);
			left.y = (float) (property.y + style.border + property.h/2.0f - left.h/2);
			name_len = (int) (nk_strlen(name));
			size = (float) (font.width((nk_handle) (font.userdata), (float) (font.height), name, (int) (name_len)));
			label.x = (float) (left.x + left.w + style.padding.x);
			label.w = (float) (size + 2*style.padding.x);
			label.y = (float) (property.y + style.border + style.padding.y);
			label.h = (float) (property.h - (2*style.border + 2*style.padding.y));
			right.y = (float) (left.y);
			right.w = (float) (left.w);
			right.h = (float) (left.h);
			right.x = (float) (property.x + property.w - (right.w + style.padding.x));
			if ((state) == (NK_PROPERTY_EDIT))
			{
				size = (float) (font.width((nk_handle) (font.userdata), (float) (font.height), buffer, (int) (*len)));
				size += (float) (style.edit.cursor_size);
				length = len;
				dst = buffer;
			}
			else
			{
				switch (variant->kind)
				{
					default:
						break;
					case NK_PROPERTY_INT:
						nk_itoa(_string_, (int) (variant->value.i));
						num_len = (int) (nk_strlen(_string_));
						break;
					case NK_PROPERTY_FLOAT:
						nk_dtoa(_string_, (double) (variant->value.f));
						num_len = (int) (nk_string_float_limit(_string_, (int) (2)));
						break;
					case NK_PROPERTY_DOUBLE:
						nk_dtoa(_string_, (double) (variant->value.d));
						num_len = (int) (nk_string_float_limit(_string_, (int) (2)));
						break;
				}
				size = (float) (font.width((nk_handle) (font.userdata), (float) (font.height), _string_, (int) (num_len)));
				dst = _string_;
				length = &num_len;
			}

			edit.w = (float) (size + 2*style.padding.x);
			edit.w = (float) ((edit.w) < (right.x - (label.x + label.w)) ? (edit.w) : (right.x - (label.x + label.w)));
			edit.x = (float) (right.x - (edit.w + style.padding.x));
			edit.y = (float) (property.y + style.border);
			edit.h = (float) (property.h - (2*style.border));
			empty.w = (float) (edit.x - (label.x + label.w));
			empty.x = (float) (label.x + label.w);
			empty.y = (float) (property.y);
			empty.h = (float) (property.h);
			old = (int) ((state) == (NK_PROPERTY_EDIT) ? 1 : 0);
			nk_property_behavior(ref ws, _in_, (nk_rect) (property), (nk_rect) (label), (nk_rect) (edit), (nk_rect) (empty),
				ref state, variant, (float) (inc_per_pixel));
			if ((style.draw_begin) != null) style.draw_begin(_out_, (nk_handle) (style.userdata));
			nk_draw_property(_out_, style, &property, &label, (uint) (ws), name, (int) (name_len), font);
			if ((style.draw_end) != null) style.draw_end(_out_, (nk_handle) (style.userdata));
			if (
				(nk_do_button_symbol(ref ws, _out_, (nk_rect) (left), (int) (style.sym_left), (int) (behavior), style.dec_button,
					_in_, font)) != 0)
			{
				switch (variant->kind)
				{
					default:
						break;
					case NK_PROPERTY_INT:
						variant->value.i =
							(int)
								(((variant->value.i - variant->step.i) < (variant->max_value.i)
									? (variant->value.i - variant->step.i)
									: (variant->max_value.i)) < (variant->min_value.i)
									? (variant->min_value.i)
									: ((variant->value.i - variant->step.i) < (variant->max_value.i)
										? (variant->value.i - variant->step.i)
										: (variant->max_value.i)));
						break;
					case NK_PROPERTY_FLOAT:
						variant->value.f =
							(float)
								(((variant->value.f - variant->step.f) < (variant->max_value.f)
									? (variant->value.f - variant->step.f)
									: (variant->max_value.f)) < (variant->min_value.f)
									? (variant->min_value.f)
									: ((variant->value.f - variant->step.f) < (variant->max_value.f)
										? (variant->value.f - variant->step.f)
										: (variant->max_value.f)));
						break;
					case NK_PROPERTY_DOUBLE:
						variant->value.d =
							(double)
								(((variant->value.d - variant->step.d) < (variant->max_value.d)
									? (variant->value.d - variant->step.d)
									: (variant->max_value.d)) < (variant->min_value.d)
									? (variant->min_value.d)
									: ((variant->value.d - variant->step.d) < (variant->max_value.d)
										? (variant->value.d - variant->step.d)
										: (variant->max_value.d)));
						break;
				}
			}

			if (
				(nk_do_button_symbol(ref ws, _out_, (nk_rect) (right), (int) (style.sym_right), (int) (behavior), style.inc_button,
					_in_, font)) != 0)
			{
				switch (variant->kind)
				{
					default:
						break;
					case NK_PROPERTY_INT:
						variant->value.i =
							(int)
								(((variant->value.i + variant->step.i) < (variant->max_value.i)
									? (variant->value.i + variant->step.i)
									: (variant->max_value.i)) < (variant->min_value.i)
									? (variant->min_value.i)
									: ((variant->value.i + variant->step.i) < (variant->max_value.i)
										? (variant->value.i + variant->step.i)
										: (variant->max_value.i)));
						break;
					case NK_PROPERTY_FLOAT:
						variant->value.f =
							(float)
								(((variant->value.f + variant->step.f) < (variant->max_value.f)
									? (variant->value.f + variant->step.f)
									: (variant->max_value.f)) < (variant->min_value.f)
									? (variant->min_value.f)
									: ((variant->value.f + variant->step.f) < (variant->max_value.f)
										? (variant->value.f + variant->step.f)
										: (variant->max_value.f)));
						break;
					case NK_PROPERTY_DOUBLE:
						variant->value.d =
							(double)
								(((variant->value.d + variant->step.d) < (variant->max_value.d)
									? (variant->value.d + variant->step.d)
									: (variant->max_value.d)) < (variant->min_value.d)
									? (variant->min_value.d)
									: ((variant->value.d + variant->step.d) < (variant->max_value.d)
										? (variant->value.d + variant->step.d)
										: (variant->max_value.d)));
						break;
				}
			}

			if ((old != NK_PROPERTY_EDIT) && ((state) == (NK_PROPERTY_EDIT)))
			{
				nk_memcopy(buffer, dst, (ulong) (*length));
				*cursor = (int) (nk_utf_len(buffer, (int) (*length)));
				*len = (int) (*length);
				length = len;
				dst = buffer;
				active = (int) (0);
			}
			else active = (int) ((state) == (NK_PROPERTY_EDIT) ? 1 : 0);
			nk_textedit_clear_state(text_edit, (int) (NK_TEXT_EDIT_SINGLE_LINE), filters[filter]);
			text_edit.active = ((byte) (active));
			text_edit._string_.len = (int) (*length);
			text_edit.cursor =
				(int)
					(((*cursor) < (*length) ? (*cursor) : (*length)) < (0) ? (0) : ((*cursor) < (*length) ? (*cursor) : (*length)));
			text_edit.select_start =
				(int)
					(((*select_begin) < (*length) ? (*select_begin) : (*length)) < (0)
						? (0)
						: ((*select_begin) < (*length) ? (*select_begin) : (*length)));
			text_edit.select_end =
				(int)
					(((*select_end) < (*length) ? (*select_end) : (*length)) < (0)
						? (0)
						: ((*select_end) < (*length) ? (*select_end) : (*length)));
			text_edit._string_.buffer.allocated = ((ulong) (*length));
			text_edit._string_.buffer.memory.size = (ulong) (64);
			text_edit._string_.buffer.memory.ptr = dst;
			text_edit._string_.buffer.size = (ulong) (64);
			text_edit.mode = (byte) (NK_TEXT_EDIT_MODE_INSERT);
			nk_do_edit(ref ws, _out_, (nk_rect) (edit), (uint) (NK_EDIT_FIELD | NK_EDIT_AUTO_SELECT), filters[filter], text_edit,
				style.edit, ((state) == (NK_PROPERTY_EDIT)) ? _in_ : null, font);
			*length = (int) (text_edit._string_.len);
			*cursor = (int) (text_edit.cursor);
			*select_begin = (int) (text_edit.select_start);
			*select_end = (int) (text_edit.select_end);
			if (((text_edit.active) != 0) && ((nk_input_is_key_pressed(_in_, (int) (NK_KEY_ENTER))) != 0))
				text_edit.active = (byte) (nk_false);
			if (((active) != 0) && (text_edit.active == 0))
			{
				state = (int) (NK_PROPERTY_DEFAULT);
				buffer[*len] = ('\0');
				switch (variant->kind)
				{
					default:
						break;
					case NK_PROPERTY_INT:
						variant->value.i = (int) (nk_strtoi(buffer, null));
						variant->value.i =
							(int)
								(((variant->value.i) < (variant->max_value.i) ? (variant->value.i) : (variant->max_value.i)) <
								 (variant->min_value.i)
									? (variant->min_value.i)
									: ((variant->value.i) < (variant->max_value.i) ? (variant->value.i) : (variant->max_value.i)));
						break;
					case NK_PROPERTY_FLOAT:
						nk_string_float_limit(buffer, (int) (2));
						variant->value.f = (float) (nk_strtof(buffer, null));
						variant->value.f =
							(float)
								(((variant->value.f) < (variant->max_value.f) ? (variant->value.f) : (variant->max_value.f)) <
								 (variant->min_value.f)
									? (variant->min_value.f)
									: ((variant->value.f) < (variant->max_value.f) ? (variant->value.f) : (variant->max_value.f)));
						break;
					case NK_PROPERTY_DOUBLE:
						nk_string_float_limit(buffer, (int) (2));
						variant->value.d = (double) (nk_strtod(buffer, null));
						variant->value.d =
							(double)
								(((variant->value.d) < (variant->max_value.d) ? (variant->value.d) : (variant->max_value.d)) <
								 (variant->min_value.d)
									? (variant->min_value.d)
									: ((variant->value.d) < (variant->max_value.d) ? (variant->value.d) : (variant->max_value.d)));
						break;
				}
			}

		}

		public static int nk_color_picker_behavior(ref uint state, nk_rect* bounds, nk_rect* matrix, nk_rect* hue_bar,
			nk_rect* alpha_bar, nk_colorf* color, nk_input _in_)
		{
			float* hsva = stackalloc float[4];
			int value_changed = (int) (0);
			int hsv_changed = (int) (0);
			nk_colorf_hsva_fv(hsva, (nk_colorf) (*color));
			if ((nk_button_behavior(ref state, (nk_rect) (*matrix), _in_, (int) (NK_BUTTON_REPEATER))) != 0)
			{
				hsva[1] =
					(float)
						((0) <
						 ((1.0f) < ((_in_.mouse.pos.x - matrix->x)/(matrix->w - 1))
							 ? (1.0f)
							 : ((_in_.mouse.pos.x - matrix->x)/(matrix->w - 1)))
							? ((1.0f) < ((_in_.mouse.pos.x - matrix->x)/(matrix->w - 1))
								? (1.0f)
								: ((_in_.mouse.pos.x - matrix->x)/(matrix->w - 1)))
							: (0));
				hsva[2] =
					(float)
						(1.0f -
						 ((0) <
						  ((1.0f) < ((_in_.mouse.pos.y - matrix->y)/(matrix->h - 1))
							  ? (1.0f)
							  : ((_in_.mouse.pos.y - matrix->y)/(matrix->h - 1)))
							 ? ((1.0f) < ((_in_.mouse.pos.y - matrix->y)/(matrix->h - 1))
								 ? (1.0f)
								 : ((_in_.mouse.pos.y - matrix->y)/(matrix->h - 1)))
							 : (0)));
				value_changed = (int) (hsv_changed = (int) (1));
			}

			if ((nk_button_behavior(ref state, (nk_rect) (*hue_bar), _in_, (int) (NK_BUTTON_REPEATER))) != 0)
			{
				hsva[0] =
					(float)
						((0) <
						 ((1.0f) < ((_in_.mouse.pos.y - hue_bar->y)/(hue_bar->h - 1))
							 ? (1.0f)
							 : ((_in_.mouse.pos.y - hue_bar->y)/(hue_bar->h - 1)))
							? ((1.0f) < ((_in_.mouse.pos.y - hue_bar->y)/(hue_bar->h - 1))
								? (1.0f)
								: ((_in_.mouse.pos.y - hue_bar->y)/(hue_bar->h - 1)))
							: (0));
				value_changed = (int) (hsv_changed = (int) (1));
			}

			if ((alpha_bar) != null)
			{
				if ((nk_button_behavior(ref state, (nk_rect) (*alpha_bar), _in_, (int) (NK_BUTTON_REPEATER))) != 0)
				{
					hsva[3] =
						(float)
							(1.0f -
							 ((0) <
							  ((1.0f) < ((_in_.mouse.pos.y - alpha_bar->y)/(alpha_bar->h - 1))
								  ? (1.0f)
								  : ((_in_.mouse.pos.y - alpha_bar->y)/(alpha_bar->h - 1)))
								 ? ((1.0f) < ((_in_.mouse.pos.y - alpha_bar->y)/(alpha_bar->h - 1))
									 ? (1.0f)
									 : ((_in_.mouse.pos.y - alpha_bar->y)/(alpha_bar->h - 1)))
								 : (0)));
					value_changed = (int) (1);
				}
			}

			if (((state) & NK_WIDGET_STATE_MODIFIED) != 0)
				(state) = (uint) (NK_WIDGET_STATE_INACTIVE | NK_WIDGET_STATE_MODIFIED);
			else (state) = (uint) (NK_WIDGET_STATE_INACTIVE);
			if ((hsv_changed) != 0)
			{
				*color = (nk_colorf) (nk_hsva_colorfv(hsva));
				state = (uint) (NK_WIDGET_STATE_ACTIVE);
			}

			if ((value_changed) != 0)
			{
				color->a = (float) (hsva[3]);
				state = (uint) (NK_WIDGET_STATE_ACTIVE);
			}

			if ((nk_input_is_mouse_hovering_rect(_in_, (nk_rect) (*bounds))) != 0) state = (uint) (NK_WIDGET_STATE_HOVERED);
			if (((state & NK_WIDGET_STATE_HOVER) != 0) && (nk_input_is_mouse_prev_hovering_rect(_in_, (nk_rect) (*bounds)) == 0))
				state |= (uint) (NK_WIDGET_STATE_ENTERED);
			else if ((nk_input_is_mouse_prev_hovering_rect(_in_, (nk_rect) (*bounds))) != 0) state |= (uint) (NK_WIDGET_STATE_LEFT);
			return (int) (value_changed);
		}

		public static void nk_draw_color_picker(nk_command_buffer o, nk_rect* matrix, nk_rect* hue_bar, nk_rect* alpha_bar,
			nk_colorf col)
		{
			nk_color black = (nk_color) (nk_black);
			nk_color white = (nk_color) (nk_white);
			nk_color black_trans = new nk_color();
			float crosshair_size = (float) (7.0f);
			nk_color temp = new nk_color();
			float* hsva = stackalloc float[4];
			float line_y;
			int i;
			nk_colorf_hsva_fv(hsva, (nk_colorf) (col));
			for (i = (int) (0); (i) < (6); ++i)
			{
				nk_fill_rect_multi_color(o,
					(nk_rect)
						(nk_rect_((float) (hue_bar->x), (float) (hue_bar->y + (float) (i)*(hue_bar->h/6.0f) + 0.5f), (float) (hue_bar->w),
							(float) ((hue_bar->h/6.0f) + 0.5f))), (nk_color) (hue_colors[i]), (nk_color) (hue_colors[i]),
					(nk_color) (hue_colors[i + 1]), (nk_color) (hue_colors[i + 1]));
			}
			line_y = ((float) ((int) (hue_bar->y + hsva[0]*matrix->h + 0.5f)));
			nk_stroke_line(o, (float) (hue_bar->x - 1), (float) (line_y), (float) (hue_bar->x + hue_bar->w + 2), (float) (line_y),
				(float) (1), (nk_color) (nk_rgb((int) (255), (int) (255), (int) (255))));
			if ((alpha_bar) != null)
			{
				float alpha = (float) ((0) < ((1.0f) < (col.a) ? (1.0f) : (col.a)) ? ((1.0f) < (col.a) ? (1.0f) : (col.a)) : (0));
				line_y = ((float) ((int) (alpha_bar->y + (1.0f - alpha)*matrix->h + 0.5f)));
				nk_fill_rect_multi_color(o, (nk_rect) (*alpha_bar), (nk_color) (white), (nk_color) (white), (nk_color) (black),
					(nk_color) (black));
				nk_stroke_line(o, (float) (alpha_bar->x - 1), (float) (line_y), (float) (alpha_bar->x + alpha_bar->w + 2),
					(float) (line_y), (float) (1), (nk_color) (nk_rgb((int) (255), (int) (255), (int) (255))));
			}

			temp = (nk_color) (nk_hsv_f((float) (hsva[0]), (float) (1.0f), (float) (1.0f)));
			nk_fill_rect_multi_color(o, (nk_rect) (*matrix), (nk_color) (white), (nk_color) (temp), (nk_color) (temp),
				(nk_color) (white));
			nk_fill_rect_multi_color(o, (nk_rect) (*matrix), (nk_color) (black_trans), (nk_color) (black_trans),
				(nk_color) (black), (nk_color) (black));
			{
				nk_vec2 p = new nk_vec2();
				float S = (float) (hsva[1]);
				float V = (float) (hsva[2]);
				p.x = ((float) ((int) (matrix->x + S*matrix->w)));
				p.y = ((float) ((int) (matrix->y + (1.0f - V)*matrix->h)));
				nk_stroke_line(o, (float) (p.x - crosshair_size), (float) (p.y), (float) (p.x - 2), (float) (p.y), (float) (1.0f),
					(nk_color) (white));
				nk_stroke_line(o, (float) (p.x + crosshair_size + 1), (float) (p.y), (float) (p.x + 3), (float) (p.y),
					(float) (1.0f), (nk_color) (white));
				nk_stroke_line(o, (float) (p.x), (float) (p.y + crosshair_size + 1), (float) (p.x), (float) (p.y + 3),
					(float) (1.0f), (nk_color) (white));
				nk_stroke_line(o, (float) (p.x), (float) (p.y - crosshair_size), (float) (p.x), (float) (p.y - 2), (float) (1.0f),
					(nk_color) (white));
			}

		}

		public static int nk_do_color_picker(ref uint state, nk_command_buffer _out_, nk_colorf* col, int fmt, nk_rect bounds,
			nk_vec2 padding, nk_input _in_, nk_user_font font)
		{
			int ret = (int) (0);
			nk_rect matrix = new nk_rect();
			nk_rect hue_bar = new nk_rect();
			nk_rect alpha_bar = new nk_rect();
			float bar_w;
			if ((((_out_ == null) || (col == null)) || (state == null)) || (font == null)) return (int) (ret);
			bar_w = (float) (font.height);
			bounds.x += (float) (padding.x);
			bounds.y += (float) (padding.x);
			bounds.w -= (float) (2*padding.x);
			bounds.h -= (float) (2*padding.y);
			matrix.x = (float) (bounds.x);
			matrix.y = (float) (bounds.y);
			matrix.h = (float) (bounds.h);
			matrix.w = (float) (bounds.w - (3*padding.x + 2*bar_w));
			hue_bar.w = (float) (bar_w);
			hue_bar.y = (float) (bounds.y);
			hue_bar.h = (float) (matrix.h);
			hue_bar.x = (float) (matrix.x + matrix.w + padding.x);
			alpha_bar.x = (float) (hue_bar.x + hue_bar.w + padding.x);
			alpha_bar.y = (float) (bounds.y);
			alpha_bar.w = (float) (bar_w);
			alpha_bar.h = (float) (matrix.h);
			ret =
				(int)
					(nk_color_picker_behavior(ref state, &bounds, &matrix, &hue_bar, ((fmt) == (NK_RGBA)) ? &alpha_bar : null, col,
						_in_));
			nk_draw_color_picker(_out_, &matrix, &hue_bar, ((fmt) == (NK_RGBA)) ? &alpha_bar : null, (nk_colorf) (*col));
			return (int) (ret);
		}

		public static void nk_style_default(nk_context ctx)
		{
			nk_style_from_table(ctx, null);
		}

		public static nk_style_item nk_style_item_image(nk_image img)
		{
			nk_style_item i = new nk_style_item();
			i.type = (int) (NK_STYLE_ITEM_IMAGE);
			i.data.image = (nk_image) (img);
			return (nk_style_item) (i);
		}

		public static nk_style_item nk_style_item_color(nk_color col)
		{
			nk_style_item i = new nk_style_item();
			i.type = (int) (NK_STYLE_ITEM_COLOR);
			i.data.color = (nk_color) (col);
			return (nk_style_item) (i);
		}

		public static nk_style_item nk_style_item_hide()
		{
			nk_style_item i = new nk_style_item();
			i.type = (int) (NK_STYLE_ITEM_COLOR);
			i.data.color = (nk_color) (nk_rgba((int) (0), (int) (0), (int) (0), (int) (0)));
			return (nk_style_item) (i);
		}

		public static void nk_style_from_table(nk_context ctx, nk_color[] table)
		{
			nk_style style;
			nk_style_text text;
			nk_style_button button;
			nk_style_toggle toggle;
			nk_style_selectable select;
			nk_style_slider slider;
			nk_style_progress prog;
			nk_style_scrollbar scroll;
			nk_style_edit edit;
			nk_style_property property;
			nk_style_combo combo;
			nk_style_chart chart;
			nk_style_tab tab;
			nk_style_window win;
			if (ctx == null) return;
			style = ctx.style;
			table = (table == null) ? nk_default_color_style : table;
			text = style.text;
			text.color = (nk_color) (table[NK_COLOR_TEXT]);
			text.padding = (nk_vec2) (nk_vec2_((float) (0), (float) (0)));
			button = style.button;

			button.normal = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_BUTTON])));
			button.hover = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_BUTTON_HOVER])));
			button.active = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_BUTTON_ACTIVE])));
			button.border_color = (nk_color) (table[NK_COLOR_BORDER]);
			button.text_background = (nk_color) (table[NK_COLOR_BUTTON]);
			button.text_normal = (nk_color) (table[NK_COLOR_TEXT]);
			button.text_hover = (nk_color) (table[NK_COLOR_TEXT]);
			button.text_active = (nk_color) (table[NK_COLOR_TEXT]);
			button.padding = (nk_vec2) (nk_vec2_((float) (2.0f), (float) (2.0f)));
			button.image_padding = (nk_vec2) (nk_vec2_((float) (0.0f), (float) (0.0f)));
			button.touch_padding = (nk_vec2) (nk_vec2_((float) (0.0f), (float) (0.0f)));
			button.userdata = (nk_handle) (nk_handle_ptr(null));
			button.text_alignment = (uint) (NK_TEXT_CENTERED);
			button.border = (float) (1.0f);
			button.rounding = (float) (4.0f);
			button.draw_begin = null;
			button.draw_end = null;
			button = style.contextual_button;

			button.normal = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_WINDOW])));
			button.hover = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_BUTTON_HOVER])));
			button.active = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_BUTTON_ACTIVE])));
			button.border_color = (nk_color) (table[NK_COLOR_WINDOW]);
			button.text_background = (nk_color) (table[NK_COLOR_WINDOW]);
			button.text_normal = (nk_color) (table[NK_COLOR_TEXT]);
			button.text_hover = (nk_color) (table[NK_COLOR_TEXT]);
			button.text_active = (nk_color) (table[NK_COLOR_TEXT]);
			button.padding = (nk_vec2) (nk_vec2_((float) (2.0f), (float) (2.0f)));
			button.touch_padding = (nk_vec2) (nk_vec2_((float) (0.0f), (float) (0.0f)));
			button.userdata = (nk_handle) (nk_handle_ptr(null));
			button.text_alignment = (uint) (NK_TEXT_CENTERED);
			button.border = (float) (0.0f);
			button.rounding = (float) (0.0f);
			button.draw_begin = null;
			button.draw_end = null;
			button = style.menu_button;

			button.normal = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_WINDOW])));
			button.hover = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_WINDOW])));
			button.active = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_WINDOW])));
			button.border_color = (nk_color) (table[NK_COLOR_WINDOW]);
			button.text_background = (nk_color) (table[NK_COLOR_WINDOW]);
			button.text_normal = (nk_color) (table[NK_COLOR_TEXT]);
			button.text_hover = (nk_color) (table[NK_COLOR_TEXT]);
			button.text_active = (nk_color) (table[NK_COLOR_TEXT]);
			button.padding = (nk_vec2) (nk_vec2_((float) (2.0f), (float) (2.0f)));
			button.touch_padding = (nk_vec2) (nk_vec2_((float) (0.0f), (float) (0.0f)));
			button.userdata = (nk_handle) (nk_handle_ptr(null));
			button.text_alignment = (uint) (NK_TEXT_CENTERED);
			button.border = (float) (0.0f);
			button.rounding = (float) (1.0f);
			button.draw_begin = null;
			button.draw_end = null;
			toggle = style.checkbox;

			toggle.normal = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_TOGGLE])));
			toggle.hover = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_TOGGLE_HOVER])));
			toggle.active = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_TOGGLE_HOVER])));
			toggle.cursor_normal = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_TOGGLE_CURSOR])));
			toggle.cursor_hover = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_TOGGLE_CURSOR])));
			toggle.userdata = (nk_handle) (nk_handle_ptr(null));
			toggle.text_background = (nk_color) (table[NK_COLOR_WINDOW]);
			toggle.text_normal = (nk_color) (table[NK_COLOR_TEXT]);
			toggle.text_hover = (nk_color) (table[NK_COLOR_TEXT]);
			toggle.text_active = (nk_color) (table[NK_COLOR_TEXT]);
			toggle.padding = (nk_vec2) (nk_vec2_((float) (2.0f), (float) (2.0f)));
			toggle.touch_padding = (nk_vec2) (nk_vec2_((float) (0), (float) (0)));
			toggle.border_color = (nk_color) (nk_rgba((int) (0), (int) (0), (int) (0), (int) (0)));
			toggle.border = (float) (0.0f);
			toggle.spacing = (float) (4);
			toggle = style.option;

			toggle.normal = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_TOGGLE])));
			toggle.hover = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_TOGGLE_HOVER])));
			toggle.active = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_TOGGLE_HOVER])));
			toggle.cursor_normal = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_TOGGLE_CURSOR])));
			toggle.cursor_hover = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_TOGGLE_CURSOR])));
			toggle.userdata = (nk_handle) (nk_handle_ptr(null));
			toggle.text_background = (nk_color) (table[NK_COLOR_WINDOW]);
			toggle.text_normal = (nk_color) (table[NK_COLOR_TEXT]);
			toggle.text_hover = (nk_color) (table[NK_COLOR_TEXT]);
			toggle.text_active = (nk_color) (table[NK_COLOR_TEXT]);
			toggle.padding = (nk_vec2) (nk_vec2_((float) (3.0f), (float) (3.0f)));
			toggle.touch_padding = (nk_vec2) (nk_vec2_((float) (0), (float) (0)));
			toggle.border_color = (nk_color) (nk_rgba((int) (0), (int) (0), (int) (0), (int) (0)));
			toggle.border = (float) (0.0f);
			toggle.spacing = (float) (4);
			select = style.selectable;

			select.normal = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_SELECT])));
			select.hover = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_SELECT])));
			select.pressed = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_SELECT])));
			select.normal_active = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_SELECT_ACTIVE])));
			select.hover_active = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_SELECT_ACTIVE])));
			select.pressed_active = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_SELECT_ACTIVE])));
			select.text_normal = (nk_color) (table[NK_COLOR_TEXT]);
			select.text_hover = (nk_color) (table[NK_COLOR_TEXT]);
			select.text_pressed = (nk_color) (table[NK_COLOR_TEXT]);
			select.text_normal_active = (nk_color) (table[NK_COLOR_TEXT]);
			select.text_hover_active = (nk_color) (table[NK_COLOR_TEXT]);
			select.text_pressed_active = (nk_color) (table[NK_COLOR_TEXT]);
			select.padding = (nk_vec2) (nk_vec2_((float) (2.0f), (float) (2.0f)));
			select.touch_padding = (nk_vec2) (nk_vec2_((float) (0), (float) (0)));
			select.userdata = (nk_handle) (nk_handle_ptr(null));
			select.rounding = (float) (0.0f);
			select.draw_begin = null;
			select.draw_end = null;
			slider = style.slider;

			slider.normal = (nk_style_item) (nk_style_item_hide());
			slider.hover = (nk_style_item) (nk_style_item_hide());
			slider.active = (nk_style_item) (nk_style_item_hide());
			slider.bar_normal = (nk_color) (table[NK_COLOR_SLIDER]);
			slider.bar_hover = (nk_color) (table[NK_COLOR_SLIDER]);
			slider.bar_active = (nk_color) (table[NK_COLOR_SLIDER]);
			slider.bar_filled = (nk_color) (table[NK_COLOR_SLIDER_CURSOR]);
			slider.cursor_normal = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_SLIDER_CURSOR])));
			slider.cursor_hover = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_SLIDER_CURSOR_HOVER])));
			slider.cursor_active = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_SLIDER_CURSOR_ACTIVE])));
			slider.inc_symbol = (int) (NK_SYMBOL_TRIANGLE_RIGHT);
			slider.dec_symbol = (int) (NK_SYMBOL_TRIANGLE_LEFT);
			slider.cursor_size = (nk_vec2) (nk_vec2_((float) (16), (float) (16)));
			slider.padding = (nk_vec2) (nk_vec2_((float) (2), (float) (2)));
			slider.spacing = (nk_vec2) (nk_vec2_((float) (2), (float) (2)));
			slider.userdata = (nk_handle) (nk_handle_ptr(null));
			slider.show_buttons = (int) (nk_false);
			slider.bar_height = (float) (8);
			slider.rounding = (float) (0);
			slider.draw_begin = null;
			slider.draw_end = null;
			button = style.slider.inc_button;
			button.normal = (nk_style_item) (nk_style_item_color((nk_color) (nk_rgb((int) (40), (int) (40), (int) (40)))));
			button.hover = (nk_style_item) (nk_style_item_color((nk_color) (nk_rgb((int) (42), (int) (42), (int) (42)))));
			button.active = (nk_style_item) (nk_style_item_color((nk_color) (nk_rgb((int) (44), (int) (44), (int) (44)))));
			button.border_color = (nk_color) (nk_rgb((int) (65), (int) (65), (int) (65)));
			button.text_background = (nk_color) (nk_rgb((int) (40), (int) (40), (int) (40)));
			button.text_normal = (nk_color) (nk_rgb((int) (175), (int) (175), (int) (175)));
			button.text_hover = (nk_color) (nk_rgb((int) (175), (int) (175), (int) (175)));
			button.text_active = (nk_color) (nk_rgb((int) (175), (int) (175), (int) (175)));
			button.padding = (nk_vec2) (nk_vec2_((float) (8.0f), (float) (8.0f)));
			button.touch_padding = (nk_vec2) (nk_vec2_((float) (0.0f), (float) (0.0f)));
			button.userdata = (nk_handle) (nk_handle_ptr(null));
			button.text_alignment = (uint) (NK_TEXT_CENTERED);
			button.border = (float) (1.0f);
			button.rounding = (float) (0.0f);
			button.draw_begin = null;
			button.draw_end = null;
			style.slider.dec_button = (nk_style_button) (style.slider.inc_button);
			prog = style.progress;

			prog.normal = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_SLIDER])));
			prog.hover = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_SLIDER])));
			prog.active = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_SLIDER])));
			prog.cursor_normal = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_SLIDER_CURSOR])));
			prog.cursor_hover = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_SLIDER_CURSOR_HOVER])));
			prog.cursor_active = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_SLIDER_CURSOR_ACTIVE])));
			prog.border_color = (nk_color) (nk_rgba((int) (0), (int) (0), (int) (0), (int) (0)));
			prog.cursor_border_color = (nk_color) (nk_rgba((int) (0), (int) (0), (int) (0), (int) (0)));
			prog.userdata = (nk_handle) (nk_handle_ptr(null));
			prog.padding = (nk_vec2) (nk_vec2_((float) (4), (float) (4)));
			prog.rounding = (float) (0);
			prog.border = (float) (0);
			prog.cursor_rounding = (float) (0);
			prog.cursor_border = (float) (0);
			prog.draw_begin = null;
			prog.draw_end = null;
			scroll = style.scrollh;

			scroll.normal = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_SCROLLBAR])));
			scroll.hover = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_SCROLLBAR])));
			scroll.active = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_SCROLLBAR])));
			scroll.cursor_normal = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_SCROLLBAR_CURSOR])));
			scroll.cursor_hover = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_SCROLLBAR_CURSOR_HOVER])));
			scroll.cursor_active = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_SCROLLBAR_CURSOR_ACTIVE])));
			scroll.dec_symbol = (int) (NK_SYMBOL_CIRCLE_SOLID);
			scroll.inc_symbol = (int) (NK_SYMBOL_CIRCLE_SOLID);
			scroll.userdata = (nk_handle) (nk_handle_ptr(null));
			scroll.border_color = (nk_color) (table[NK_COLOR_SCROLLBAR]);
			scroll.cursor_border_color = (nk_color) (table[NK_COLOR_SCROLLBAR]);
			scroll.padding = (nk_vec2) (nk_vec2_((float) (0), (float) (0)));
			scroll.show_buttons = (int) (nk_false);
			scroll.border = (float) (0);
			scroll.rounding = (float) (0);
			scroll.border_cursor = (float) (0);
			scroll.rounding_cursor = (float) (0);
			scroll.draw_begin = null;
			scroll.draw_end = null;
			style.scrollv = (nk_style_scrollbar) (style.scrollh);
			button = style.scrollh.inc_button;
			button.normal = (nk_style_item) (nk_style_item_color((nk_color) (nk_rgb((int) (40), (int) (40), (int) (40)))));
			button.hover = (nk_style_item) (nk_style_item_color((nk_color) (nk_rgb((int) (42), (int) (42), (int) (42)))));
			button.active = (nk_style_item) (nk_style_item_color((nk_color) (nk_rgb((int) (44), (int) (44), (int) (44)))));
			button.border_color = (nk_color) (nk_rgb((int) (65), (int) (65), (int) (65)));
			button.text_background = (nk_color) (nk_rgb((int) (40), (int) (40), (int) (40)));
			button.text_normal = (nk_color) (nk_rgb((int) (175), (int) (175), (int) (175)));
			button.text_hover = (nk_color) (nk_rgb((int) (175), (int) (175), (int) (175)));
			button.text_active = (nk_color) (nk_rgb((int) (175), (int) (175), (int) (175)));
			button.padding = (nk_vec2) (nk_vec2_((float) (4.0f), (float) (4.0f)));
			button.touch_padding = (nk_vec2) (nk_vec2_((float) (0.0f), (float) (0.0f)));
			button.userdata = (nk_handle) (nk_handle_ptr(null));
			button.text_alignment = (uint) (NK_TEXT_CENTERED);
			button.border = (float) (1.0f);
			button.rounding = (float) (0.0f);
			button.draw_begin = null;
			button.draw_end = null;
			style.scrollh.dec_button = (nk_style_button) (style.scrollh.inc_button);
			style.scrollv.inc_button = (nk_style_button) (style.scrollh.inc_button);
			style.scrollv.dec_button = (nk_style_button) (style.scrollh.inc_button);
			edit = style.edit;

			edit.normal = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_EDIT])));
			edit.hover = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_EDIT])));
			edit.active = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_EDIT])));
			edit.cursor_normal = (nk_color) (table[NK_COLOR_TEXT]);
			edit.cursor_hover = (nk_color) (table[NK_COLOR_TEXT]);
			edit.cursor_text_normal = (nk_color) (table[NK_COLOR_EDIT]);
			edit.cursor_text_hover = (nk_color) (table[NK_COLOR_EDIT]);
			edit.border_color = (nk_color) (table[NK_COLOR_BORDER]);
			edit.text_normal = (nk_color) (table[NK_COLOR_TEXT]);
			edit.text_hover = (nk_color) (table[NK_COLOR_TEXT]);
			edit.text_active = (nk_color) (table[NK_COLOR_TEXT]);
			edit.selected_normal = (nk_color) (table[NK_COLOR_TEXT]);
			edit.selected_hover = (nk_color) (table[NK_COLOR_TEXT]);
			edit.selected_text_normal = (nk_color) (table[NK_COLOR_EDIT]);
			edit.selected_text_hover = (nk_color) (table[NK_COLOR_EDIT]);
			edit.scrollbar_size = (nk_vec2) (nk_vec2_((float) (10), (float) (10)));
			edit.scrollbar = (nk_style_scrollbar) (style.scrollv);
			edit.padding = (nk_vec2) (nk_vec2_((float) (4), (float) (4)));
			edit.row_padding = (float) (2);
			edit.cursor_size = (float) (4);
			edit.border = (float) (1);
			edit.rounding = (float) (0);
			property = style.property;

			property.normal = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_PROPERTY])));
			property.hover = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_PROPERTY])));
			property.active = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_PROPERTY])));
			property.border_color = (nk_color) (table[NK_COLOR_BORDER]);
			property.label_normal = (nk_color) (table[NK_COLOR_TEXT]);
			property.label_hover = (nk_color) (table[NK_COLOR_TEXT]);
			property.label_active = (nk_color) (table[NK_COLOR_TEXT]);
			property.sym_left = (int) (NK_SYMBOL_TRIANGLE_LEFT);
			property.sym_right = (int) (NK_SYMBOL_TRIANGLE_RIGHT);
			property.userdata = (nk_handle) (nk_handle_ptr(null));
			property.padding = (nk_vec2) (nk_vec2_((float) (4), (float) (4)));
			property.border = (float) (1);
			property.rounding = (float) (10);
			property.draw_begin = null;
			property.draw_end = null;
			button = style.property.dec_button;

			button.normal = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_PROPERTY])));
			button.hover = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_PROPERTY])));
			button.active = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_PROPERTY])));
			button.border_color = (nk_color) (nk_rgba((int) (0), (int) (0), (int) (0), (int) (0)));
			button.text_background = (nk_color) (table[NK_COLOR_PROPERTY]);
			button.text_normal = (nk_color) (table[NK_COLOR_TEXT]);
			button.text_hover = (nk_color) (table[NK_COLOR_TEXT]);
			button.text_active = (nk_color) (table[NK_COLOR_TEXT]);
			button.padding = (nk_vec2) (nk_vec2_((float) (0.0f), (float) (0.0f)));
			button.touch_padding = (nk_vec2) (nk_vec2_((float) (0.0f), (float) (0.0f)));
			button.userdata = (nk_handle) (nk_handle_ptr(null));
			button.text_alignment = (uint) (NK_TEXT_CENTERED);
			button.border = (float) (0.0f);
			button.rounding = (float) (0.0f);
			button.draw_begin = null;
			button.draw_end = null;
			style.property.inc_button = (nk_style_button) (style.property.dec_button);
			edit = style.property.edit;

			edit.normal = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_PROPERTY])));
			edit.hover = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_PROPERTY])));
			edit.active = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_PROPERTY])));
			edit.border_color = (nk_color) (nk_rgba((int) (0), (int) (0), (int) (0), (int) (0)));
			edit.cursor_normal = (nk_color) (table[NK_COLOR_TEXT]);
			edit.cursor_hover = (nk_color) (table[NK_COLOR_TEXT]);
			edit.cursor_text_normal = (nk_color) (table[NK_COLOR_EDIT]);
			edit.cursor_text_hover = (nk_color) (table[NK_COLOR_EDIT]);
			edit.text_normal = (nk_color) (table[NK_COLOR_TEXT]);
			edit.text_hover = (nk_color) (table[NK_COLOR_TEXT]);
			edit.text_active = (nk_color) (table[NK_COLOR_TEXT]);
			edit.selected_normal = (nk_color) (table[NK_COLOR_TEXT]);
			edit.selected_hover = (nk_color) (table[NK_COLOR_TEXT]);
			edit.selected_text_normal = (nk_color) (table[NK_COLOR_EDIT]);
			edit.selected_text_hover = (nk_color) (table[NK_COLOR_EDIT]);
			edit.padding = (nk_vec2) (nk_vec2_((float) (0), (float) (0)));
			edit.cursor_size = (float) (8);
			edit.border = (float) (0);
			edit.rounding = (float) (0);
			chart = style.chart;

			chart.background = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_CHART])));
			chart.border_color = (nk_color) (table[NK_COLOR_BORDER]);
			chart.selected_color = (nk_color) (table[NK_COLOR_CHART_COLOR_HIGHLIGHT]);
			chart.color = (nk_color) (table[NK_COLOR_CHART_COLOR]);
			chart.padding = (nk_vec2) (nk_vec2_((float) (4), (float) (4)));
			chart.border = (float) (0);
			chart.rounding = (float) (0);
			combo = style.combo;
			combo.normal = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_COMBO])));
			combo.hover = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_COMBO])));
			combo.active = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_COMBO])));
			combo.border_color = (nk_color) (table[NK_COLOR_BORDER]);
			combo.label_normal = (nk_color) (table[NK_COLOR_TEXT]);
			combo.label_hover = (nk_color) (table[NK_COLOR_TEXT]);
			combo.label_active = (nk_color) (table[NK_COLOR_TEXT]);
			combo.sym_normal = (int) (NK_SYMBOL_TRIANGLE_DOWN);
			combo.sym_hover = (int) (NK_SYMBOL_TRIANGLE_DOWN);
			combo.sym_active = (int) (NK_SYMBOL_TRIANGLE_DOWN);
			combo.content_padding = (nk_vec2) (nk_vec2_((float) (4), (float) (4)));
			combo.button_padding = (nk_vec2) (nk_vec2_((float) (0), (float) (4)));
			combo.spacing = (nk_vec2) (nk_vec2_((float) (4), (float) (0)));
			combo.border = (float) (1);
			combo.rounding = (float) (0);
			button = style.combo.button;

			button.normal = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_COMBO])));
			button.hover = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_COMBO])));
			button.active = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_COMBO])));
			button.border_color = (nk_color) (nk_rgba((int) (0), (int) (0), (int) (0), (int) (0)));
			button.text_background = (nk_color) (table[NK_COLOR_COMBO]);
			button.text_normal = (nk_color) (table[NK_COLOR_TEXT]);
			button.text_hover = (nk_color) (table[NK_COLOR_TEXT]);
			button.text_active = (nk_color) (table[NK_COLOR_TEXT]);
			button.padding = (nk_vec2) (nk_vec2_((float) (2.0f), (float) (2.0f)));
			button.touch_padding = (nk_vec2) (nk_vec2_((float) (0.0f), (float) (0.0f)));
			button.userdata = (nk_handle) (nk_handle_ptr(null));
			button.text_alignment = (uint) (NK_TEXT_CENTERED);
			button.border = (float) (0.0f);
			button.rounding = (float) (0.0f);
			button.draw_begin = null;
			button.draw_end = null;
			tab = style.tab;
			tab.background = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_TAB_HEADER])));
			tab.border_color = (nk_color) (table[NK_COLOR_BORDER]);
			tab.text = (nk_color) (table[NK_COLOR_TEXT]);
			tab.sym_minimize = (int) (NK_SYMBOL_TRIANGLE_RIGHT);
			tab.sym_maximize = (int) (NK_SYMBOL_TRIANGLE_DOWN);
			tab.padding = (nk_vec2) (nk_vec2_((float) (4), (float) (4)));
			tab.spacing = (nk_vec2) (nk_vec2_((float) (4), (float) (4)));
			tab.indent = (float) (10.0f);
			tab.border = (float) (1);
			tab.rounding = (float) (0);
			button = style.tab.tab_minimize_button;

			button.normal = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_TAB_HEADER])));
			button.hover = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_TAB_HEADER])));
			button.active = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_TAB_HEADER])));
			button.border_color = (nk_color) (nk_rgba((int) (0), (int) (0), (int) (0), (int) (0)));
			button.text_background = (nk_color) (table[NK_COLOR_TAB_HEADER]);
			button.text_normal = (nk_color) (table[NK_COLOR_TEXT]);
			button.text_hover = (nk_color) (table[NK_COLOR_TEXT]);
			button.text_active = (nk_color) (table[NK_COLOR_TEXT]);
			button.padding = (nk_vec2) (nk_vec2_((float) (2.0f), (float) (2.0f)));
			button.touch_padding = (nk_vec2) (nk_vec2_((float) (0.0f), (float) (0.0f)));
			button.userdata = (nk_handle) (nk_handle_ptr(null));
			button.text_alignment = (uint) (NK_TEXT_CENTERED);
			button.border = (float) (0.0f);
			button.rounding = (float) (0.0f);
			button.draw_begin = null;
			button.draw_end = null;
			style.tab.tab_maximize_button = (nk_style_button) (button);
			button = style.tab.node_minimize_button;

			button.normal = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_WINDOW])));
			button.hover = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_WINDOW])));
			button.active = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_WINDOW])));
			button.border_color = (nk_color) (nk_rgba((int) (0), (int) (0), (int) (0), (int) (0)));
			button.text_background = (nk_color) (table[NK_COLOR_TAB_HEADER]);
			button.text_normal = (nk_color) (table[NK_COLOR_TEXT]);
			button.text_hover = (nk_color) (table[NK_COLOR_TEXT]);
			button.text_active = (nk_color) (table[NK_COLOR_TEXT]);
			button.padding = (nk_vec2) (nk_vec2_((float) (2.0f), (float) (2.0f)));
			button.touch_padding = (nk_vec2) (nk_vec2_((float) (0.0f), (float) (0.0f)));
			button.userdata = (nk_handle) (nk_handle_ptr(null));
			button.text_alignment = (uint) (NK_TEXT_CENTERED);
			button.border = (float) (0.0f);
			button.rounding = (float) (0.0f);
			button.draw_begin = null;
			button.draw_end = null;
			style.tab.node_maximize_button = (nk_style_button) (button);
			win = style.window;
			win.header.align = (int) (NK_HEADER_RIGHT);
			win.header.close_symbol = (int) (NK_SYMBOL_X);
			win.header.minimize_symbol = (int) (NK_SYMBOL_MINUS);
			win.header.maximize_symbol = (int) (NK_SYMBOL_PLUS);
			win.header.normal = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_HEADER])));
			win.header.hover = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_HEADER])));
			win.header.active = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_HEADER])));
			win.header.label_normal = (nk_color) (table[NK_COLOR_TEXT]);
			win.header.label_hover = (nk_color) (table[NK_COLOR_TEXT]);
			win.header.label_active = (nk_color) (table[NK_COLOR_TEXT]);
			win.header.label_padding = (nk_vec2) (nk_vec2_((float) (4), (float) (4)));
			win.header.padding = (nk_vec2) (nk_vec2_((float) (4), (float) (4)));
			win.header.spacing = (nk_vec2) (nk_vec2_((float) (0), (float) (0)));
			button = style.window.header.close_button;

			button.normal = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_HEADER])));
			button.hover = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_HEADER])));
			button.active = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_HEADER])));
			button.border_color = (nk_color) (nk_rgba((int) (0), (int) (0), (int) (0), (int) (0)));
			button.text_background = (nk_color) (table[NK_COLOR_HEADER]);
			button.text_normal = (nk_color) (table[NK_COLOR_TEXT]);
			button.text_hover = (nk_color) (table[NK_COLOR_TEXT]);
			button.text_active = (nk_color) (table[NK_COLOR_TEXT]);
			button.padding = (nk_vec2) (nk_vec2_((float) (0.0f), (float) (0.0f)));
			button.touch_padding = (nk_vec2) (nk_vec2_((float) (0.0f), (float) (0.0f)));
			button.userdata = (nk_handle) (nk_handle_ptr(null));
			button.text_alignment = (uint) (NK_TEXT_CENTERED);
			button.border = (float) (0.0f);
			button.rounding = (float) (0.0f);
			button.draw_begin = null;
			button.draw_end = null;
			button = style.window.header.minimize_button;

			button.normal = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_HEADER])));
			button.hover = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_HEADER])));
			button.active = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_HEADER])));
			button.border_color = (nk_color) (nk_rgba((int) (0), (int) (0), (int) (0), (int) (0)));
			button.text_background = (nk_color) (table[NK_COLOR_HEADER]);
			button.text_normal = (nk_color) (table[NK_COLOR_TEXT]);
			button.text_hover = (nk_color) (table[NK_COLOR_TEXT]);
			button.text_active = (nk_color) (table[NK_COLOR_TEXT]);
			button.padding = (nk_vec2) (nk_vec2_((float) (0.0f), (float) (0.0f)));
			button.touch_padding = (nk_vec2) (nk_vec2_((float) (0.0f), (float) (0.0f)));
			button.userdata = (nk_handle) (nk_handle_ptr(null));
			button.text_alignment = (uint) (NK_TEXT_CENTERED);
			button.border = (float) (0.0f);
			button.rounding = (float) (0.0f);
			button.draw_begin = null;
			button.draw_end = null;
			win.background = (nk_color) (table[NK_COLOR_WINDOW]);
			win.fixed_background = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_WINDOW])));
			win.border_color = (nk_color) (table[NK_COLOR_BORDER]);
			win.popup_border_color = (nk_color) (table[NK_COLOR_BORDER]);
			win.combo_border_color = (nk_color) (table[NK_COLOR_BORDER]);
			win.contextual_border_color = (nk_color) (table[NK_COLOR_BORDER]);
			win.menu_border_color = (nk_color) (table[NK_COLOR_BORDER]);
			win.group_border_color = (nk_color) (table[NK_COLOR_BORDER]);
			win.tooltip_border_color = (nk_color) (table[NK_COLOR_BORDER]);
			win.scaler = (nk_style_item) (nk_style_item_color((nk_color) (table[NK_COLOR_TEXT])));
			win.rounding = (float) (0.0f);
			win.spacing = (nk_vec2) (nk_vec2_((float) (4), (float) (4)));
			win.scrollbar_size = (nk_vec2) (nk_vec2_((float) (10), (float) (10)));
			win.min_size = (nk_vec2) (nk_vec2_((float) (64), (float) (64)));
			win.combo_border = (float) (1.0f);
			win.contextual_border = (float) (1.0f);
			win.menu_border = (float) (1.0f);
			win.group_border = (float) (1.0f);
			win.tooltip_border = (float) (1.0f);
			win.popup_border = (float) (1.0f);
			win.border = (float) (2.0f);
			win.min_row_height_padding = (float) (8);
			win.padding = (nk_vec2) (nk_vec2_((float) (4), (float) (4)));
			win.group_padding = (nk_vec2) (nk_vec2_((float) (4), (float) (4)));
			win.popup_padding = (nk_vec2) (nk_vec2_((float) (4), (float) (4)));
			win.combo_padding = (nk_vec2) (nk_vec2_((float) (4), (float) (4)));
			win.contextual_padding = (nk_vec2) (nk_vec2_((float) (4), (float) (4)));
			win.menu_padding = (nk_vec2) (nk_vec2_((float) (4), (float) (4)));
			win.tooltip_padding = (nk_vec2) (nk_vec2_((float) (4), (float) (4)));
		}

		public static void nk_style_set_font(nk_context ctx, nk_user_font font)
		{
			nk_style style;
			if (ctx == null) return;
			style = ctx.style;
			style.font = font;
			ctx.stacks.fonts.head = (int) (0);
			if ((ctx.current) != null) nk_layout_reset_min_row_height(ctx);
		}

		public static int nk_style_push_font(nk_context ctx, nk_user_font font)
		{
			nk_config_stack_user_font font_stack;
			nk_config_stack_user_font_element element;
			if (ctx == null) return (int) (0);
			font_stack = ctx.stacks.fonts;
			if ((font_stack.head) >= (int) font_stack.elements.Length) return (int) (0);
			element = font_stack.elements[font_stack.head++];
			element.address = ctx.style.font;
			element.old_value = ctx.style.font;
			ctx.style.font = font;
			return (int) (1);
		}

		public static int nk_style_pop_font(nk_context ctx)
		{
			nk_config_stack_user_font font_stack;
			nk_config_stack_user_font_element element;
			if (ctx == null) return (int) (0);
			font_stack = ctx.stacks.fonts;
			if ((font_stack.head) < (1)) return (int) (0);
			element = font_stack.elements[--font_stack.head];
			element.address = element.old_value;
			return (int) (1);
		}

		public static int nk_style_push_style_item(nk_context ctx, nk_style_item address, nk_style_item value)
		{
			nk_config_stack_style_item type_stack;
			nk_config_stack_style_item_element element;
			if (ctx == null) return (int) (0);
			type_stack = ctx.stacks.style_items;
			if ((type_stack.head) >= (int) type_stack.elements.Length) return (int) (0);
			element = (nk_config_stack_style_item_element) (type_stack.elements)[(type_stack.head++)];
			element.address = address;
			element.old_value = (nk_style_item) (address);
			address = (nk_style_item) (value);
			return (int) (1);
		}

		public static int nk_style_push_float(nk_context ctx, float* address, float value)
		{
			nk_config_stack_float type_stack;
			nk_config_stack_float_element* element;
			if (ctx == null) return (int) (0);
			type_stack = ctx.stacks.floats;
			if ((type_stack.head) >= (int) type_stack.elements.Length) return (int) (0);
			element = (nk_config_stack_float_element*) (type_stack.elements) + (type_stack.head++);
			element->address = address;
			element->old_value = (float) (*address);
			*address = (float) (value);
			return (int) (1);
		}

		public static int nk_style_push_vec2(nk_context ctx, nk_vec2* address, nk_vec2 value)
		{
			nk_config_stack_vec2 type_stack;
			nk_config_stack_vec2_element* element;
			if (ctx == null) return (int) (0);
			type_stack = ctx.stacks.vectors;
			if ((type_stack.head) >= (int) type_stack.elements.Length) return (int) (0);
			element = (nk_config_stack_vec2_element*) (type_stack.elements) + (type_stack.head++);
			element->address = address;
			element->old_value = (nk_vec2) (*address);
			*address = (nk_vec2) (value);
			return (int) (1);
		}

		public static int nk_style_push_flags(nk_context ctx, uint* address, uint value)
		{
			nk_config_stack_flags type_stack;
			nk_config_stack_flags_element* element;
			if (ctx == null) return (int) (0);
			type_stack = ctx.stacks.flags;
			if ((type_stack.head) >= (int) type_stack.elements.Length) return (int) (0);
			element = (nk_config_stack_flags_element*) (type_stack.elements) + (type_stack.head++);
			element->address = address;
			element->old_value = (uint) (*address);
			*address = (uint) (value);
			return (int) (1);
		}

		public static int nk_style_push_color(nk_context ctx, nk_color* address, nk_color value)
		{
			nk_config_stack_color type_stack;
			nk_config_stack_color_element* element;
			if (ctx == null) return (int) (0);
			type_stack = ctx.stacks.colors;
			if ((type_stack.head) >= (int) type_stack.elements.Length) return (int) (0);
			element = (nk_config_stack_color_element*) (type_stack.elements) + (type_stack.head++);
			element->address = address;
			element->old_value = (nk_color) (*address);
			*address = (nk_color) (value);
			return (int) (1);
		}

		public static int nk_style_pop_style_item(nk_context ctx)
		{
			nk_config_stack_style_item type_stack;
			nk_config_stack_style_item_element element;
			if (ctx == null) return (int) (0);
			type_stack = ctx.stacks.style_items;
			if ((type_stack.head) < (1)) return (int) (0);
			element = (nk_config_stack_style_item_element) (type_stack.elements)[(--type_stack.head)];
			element.address = (nk_style_item) (element.old_value);
			return (int) (1);
		}

		public static int nk_style_pop_float(nk_context ctx)
		{
			nk_config_stack_float type_stack;
			nk_config_stack_float_element* element;
			if (ctx == null) return (int) (0);
			type_stack = ctx.stacks.floats;
			if ((type_stack.head) < (1)) return (int) (0);
			element = (nk_config_stack_float_element*) (type_stack.elements) + (--type_stack.head);
			*element->address = (float) (element->old_value);
			return (int) (1);
		}

		public static int nk_style_pop_vec2(nk_context ctx)
		{
			nk_config_stack_vec2 type_stack;
			nk_config_stack_vec2_element* element;
			if (ctx == null) return (int) (0);
			type_stack = ctx.stacks.vectors;
			if ((type_stack.head) < (1)) return (int) (0);
			element = (nk_config_stack_vec2_element*) (type_stack.elements) + (--type_stack.head);
			*element->address = (nk_vec2) (element->old_value);
			return (int) (1);
		}

		public static int nk_style_pop_flags(nk_context ctx)
		{
			nk_config_stack_flags type_stack;
			nk_config_stack_flags_element* element;
			if (ctx == null) return (int) (0);
			type_stack = ctx.stacks.flags;
			if ((type_stack.head) < (1)) return (int) (0);
			element = (nk_config_stack_flags_element*) (type_stack.elements) + (--type_stack.head);
			*element->address = (uint) (element->old_value);
			return (int) (1);
		}

		public static int nk_style_pop_color(nk_context ctx)
		{
			nk_config_stack_color type_stack;
			nk_config_stack_color_element* element;
			if (ctx == null) return (int) (0);
			type_stack = ctx.stacks.colors;
			if ((type_stack.head) < (1)) return (int) (0);
			element = (nk_config_stack_color_element*) (type_stack.elements) + (--type_stack.head);
			*element->address = (nk_color) (element->old_value);
			return (int) (1);
		}

		public static int nk_style_set_cursor(nk_context ctx, int c)
		{
			nk_style style;
			if (ctx == null) return (int) (0);
			style = ctx.style;
			if ((style.cursors[c]) != null)
			{
				style.cursor_active = style.cursors[c];
				return (int) (1);
			}

			return (int) (0);
		}

		public static void nk_style_show_cursor(nk_context ctx)
		{
			ctx.style.cursor_visible = (int) (nk_true);
		}

		public static void nk_style_hide_cursor(nk_context ctx)
		{
			ctx.style.cursor_visible = (int) (nk_false);
		}

		public static void nk_style_load_cursor(nk_context ctx, int cursor, nk_cursor c)
		{
			nk_style style;
			if (ctx == null) return;
			style = ctx.style;
			style.cursors[cursor] = c;
		}

		public static void nk_style_load_all_cursors(nk_context ctx, nk_cursor[] cursors)
		{
			int i = (int) (0);
			nk_style style;
			if (ctx == null) return;
			style = ctx.style;
			for (i = (int) (0); (i) < (NK_CURSOR_COUNT); ++i)
			{
				style.cursors[i] = cursors[i];
			}
			style.cursor_visible = (int) (nk_true);
		}

		public static void nk_setup(nk_context ctx, nk_user_font font)
		{
			if (ctx == null) return;

			nk_style_default(ctx);
			ctx.seq = (uint) (1);
			if ((font) != null) ctx.style.font = font;
			nk_draw_list_init(ctx.draw_list);
		}

		public static void nk_set_user_data(nk_context ctx, nk_handle handle)
		{
			if (ctx == null) return;
			ctx.userdata = (nk_handle) (handle);
			if ((ctx.current) != null) ctx.current.buffer.userdata = (nk_handle) (handle);
		}

		public static void nk_clear(nk_context ctx)
		{
			nk_window iter;
			nk_window next;
			if (ctx == null) return;
			nk_buffer_reset(ctx.memory, (int) (NK_BUFFER_FRONT));
			ctx.build = (int) (0);
			ctx.memory.calls = (ulong) (0);
			ctx.last_widget_state = (uint) (0);
			ctx.style.cursor_active = ctx.style.cursors[NK_CURSOR_ARROW];

			nk_draw_list_clear(ctx.draw_list);
			iter = ctx.begin;
			while ((iter) != null)
			{
				if ((((iter.flags & NK_WINDOW_MINIMIZED) != 0) && ((iter.flags & NK_WINDOW_CLOSED) == 0)) &&
				    ((iter.seq) == (ctx.seq)))
				{
					iter = iter.next;
					continue;
				}
				if ((((iter.flags & NK_WINDOW_HIDDEN) != 0) || ((iter.flags & NK_WINDOW_CLOSED) != 0)) && ((iter) == (ctx.active)))
				{
					ctx.active = iter.prev;
					ctx.end = iter.prev;
					if ((ctx.active) != null) ctx.active.flags &= (uint) (~(uint) (NK_WINDOW_ROM));
				}
				if (((iter.popup.win) != null) && (iter.popup.win.seq != ctx.seq))
				{
					nk_free_window(ctx, iter.popup.win);
					iter.popup.win = null;
				}
				{
					nk_table n;
					nk_table it = iter.tables;
					while ((it) != null)
					{
						n = it.next;
						if (it.seq != ctx.seq)
						{
							nk_remove_table(iter, it);
							if ((it) == (iter.tables)) iter.tables = n;
						}
						it = n;
					}
				}
				if ((iter.seq != ctx.seq) || ((iter.flags & NK_WINDOW_CLOSED) != 0))
				{
					next = iter.next;
					nk_remove_window(ctx, iter);
					nk_free_window(ctx, iter);
					iter = next;
				}
				else iter = iter.next;
			}
			ctx.seq++;
		}

		public static void nk_start_buffer(nk_context ctx, nk_command_buffer buffer)
		{
			if ((ctx == null) || (buffer == null)) return;
			buffer.clip = (nk_rect) (nk_null_rect);
		}

		public static void nk_start(nk_context ctx, nk_window win)
		{
			nk_start_buffer(ctx, win.buffer);
		}

		public static void nk_start_popup(nk_context ctx, nk_window win)
		{
			nk_popup_buffer buf;
			if ((ctx == null) || (win == null)) return;
			buf = win.popup.buf;
			buf.last = (ulong) (buf.begin);
			buf.active = (int) (nk_true);
		}

		public static void nk_finish_popup(nk_context ctx, nk_window win)
		{
			nk_popup_buffer buf;
			if ((ctx == null) || (win == null)) return;
			buf = win.popup.buf;
		}

		public static void nk_finish_buffer(nk_context ctx, nk_command_buffer buffer)
		{
			if ((ctx == null) || (buffer == null)) return;
		}

		public static void nk_finish(nk_context ctx, nk_window win)
		{
			nk_popup_buffer buf;
			nk_command* parent_last;
			void* memory;
			if ((ctx == null) || (win == null)) return;
			nk_finish_buffer(ctx, win.buffer);
			if (win.popup.buf.active == 0) return;
			buf = win.popup.buf;
			memory = ctx.memory.memory.ptr;
			parent_last = ((nk_command*) ((void*) ((byte*) (memory) + (buf.parent))));
			parent_last->next = (ulong) (buf.end);
		}

		public static int nk_panel_has_header(uint flags, char* title)
		{
			int active = (int) (0);
			active = (int) (flags & (NK_WINDOW_CLOSABLE | NK_WINDOW_MINIMIZABLE));
			active = (int) (((active) != 0) || ((flags & NK_WINDOW_TITLE) != 0) ? 1 : 0);
			active = (int) ((((active) != 0) && ((flags & NK_WINDOW_HIDDEN) == 0)) && ((title) != null) ? 1 : 0);
			return (int) (active);
		}

		public static nk_vec2 nk_panel_get_padding(nk_style style, int type)
		{
			switch (type)
			{
				default:
				case NK_PANEL_WINDOW:
					return (nk_vec2) (style.window.padding);
				case NK_PANEL_GROUP:
					return (nk_vec2) (style.window.group_padding);
				case NK_PANEL_POPUP:
					return (nk_vec2) (style.window.popup_padding);
				case NK_PANEL_CONTEXTUAL:
					return (nk_vec2) (style.window.contextual_padding);
				case NK_PANEL_COMBO:
					return (nk_vec2) (style.window.combo_padding);
				case NK_PANEL_MENU:
					return (nk_vec2) (style.window.menu_padding);
				case NK_PANEL_TOOLTIP:
					return (nk_vec2) (style.window.menu_padding);
			}

		}

		public static float nk_panel_get_border(nk_style style, uint flags, int type)
		{
			if ((flags & NK_WINDOW_BORDER) != 0)
			{
				switch (type)
				{
					default:
					case NK_PANEL_WINDOW:
						return (float) (style.window.border);
					case NK_PANEL_GROUP:
						return (float) (style.window.group_border);
					case NK_PANEL_POPUP:
						return (float) (style.window.popup_border);
					case NK_PANEL_CONTEXTUAL:
						return (float) (style.window.contextual_border);
					case NK_PANEL_COMBO:
						return (float) (style.window.combo_border);
					case NK_PANEL_MENU:
						return (float) (style.window.menu_border);
					case NK_PANEL_TOOLTIP:
						return (float) (style.window.menu_border);
				}
			}
			else return (float) (0);
		}

		public static nk_color nk_panel_get_border_color(nk_style style, int type)
		{
			switch (type)
			{
				default:
				case NK_PANEL_WINDOW:
					return (nk_color) (style.window.border_color);
				case NK_PANEL_GROUP:
					return (nk_color) (style.window.group_border_color);
				case NK_PANEL_POPUP:
					return (nk_color) (style.window.popup_border_color);
				case NK_PANEL_CONTEXTUAL:
					return (nk_color) (style.window.contextual_border_color);
				case NK_PANEL_COMBO:
					return (nk_color) (style.window.combo_border_color);
				case NK_PANEL_MENU:
					return (nk_color) (style.window.menu_border_color);
				case NK_PANEL_TOOLTIP:
					return (nk_color) (style.window.menu_border_color);
			}

		}

		public static int nk_panel_is_sub(int type)
		{
			return (int) ((type & NK_PANEL_SET_SUB) != 0 ? 1 : 0);
		}

		public static int nk_panel_is_nonblock(int type)
		{
			return (int) ((type & NK_PANEL_SET_NONBLOCK) != 0 ? 1 : 0);
		}

		public static int nk_panel_begin(nk_context ctx, char* title, int panel_type)
		{
			nk_input _in_;
			nk_window win;
			nk_panel layout;
			nk_command_buffer _out_;
			nk_style style;
			nk_user_font font;
			nk_vec2 scrollbar_size = new nk_vec2();
			nk_vec2 panel_padding = new nk_vec2();
			if (((ctx == null) || (ctx.current == null)) || (ctx.current.layout == null)) return (int) (0);

			if (((ctx.current.flags & NK_WINDOW_HIDDEN) != 0) || ((ctx.current.flags & NK_WINDOW_CLOSED) != 0))
			{
				ctx.current.layout.type = (int) (panel_type);
				return (int) (0);
			}

			style = ctx.style;
			font = style.font;
			win = ctx.current;
			layout = win.layout;
			_out_ = win.buffer;
			_in_ = (win.flags & NK_WINDOW_NO_INPUT) != 0 ? null : ctx.input;
			win.buffer.userdata = (nk_handle) (ctx.userdata);
			scrollbar_size = (nk_vec2) (style.window.scrollbar_size);
			panel_padding = (nk_vec2) (nk_panel_get_padding(style, (int) (panel_type)));
			if (((win.flags & NK_WINDOW_MOVABLE) != 0) && ((win.flags & NK_WINDOW_ROM) == 0))
			{
				int left_mouse_down;
				int left_mouse_click_in_cursor;
				nk_rect header = new nk_rect();
				header.x = (float) (win.bounds.x);
				header.y = (float) (win.bounds.y);
				header.w = (float) (win.bounds.w);
				if ((nk_panel_has_header((uint) (win.flags), title)) != 0)
				{
					header.h = (float) (font.height + 2.0f*style.window.header.padding.y);
					header.h += (float) (2.0f*style.window.header.label_padding.y);
				}
				else header.h = (float) (panel_padding.y);
				left_mouse_down = (int) (((nk_mouse_button*) _in_.mouse.buttons + NK_BUTTON_LEFT)->down);
				left_mouse_click_in_cursor =
					(int) (nk_input_has_mouse_click_down_in_rect(_in_, (int) (NK_BUTTON_LEFT), (nk_rect) (header), (int) (nk_true)));
				if (((left_mouse_down) != 0) && ((left_mouse_click_in_cursor) != 0))
				{
					win.bounds.x = (float) (win.bounds.x + _in_.mouse.delta.x);
					win.bounds.y = (float) (win.bounds.y + _in_.mouse.delta.y);
					((nk_mouse_button*) _in_.mouse.buttons + NK_BUTTON_LEFT)->clicked_pos.x += (float) (_in_.mouse.delta.x);
					((nk_mouse_button*) _in_.mouse.buttons + NK_BUTTON_LEFT)->clicked_pos.y += (float) (_in_.mouse.delta.y);
					ctx.style.cursor_active = ctx.style.cursors[NK_CURSOR_MOVE];
				}
			}

			layout.type = (int) (panel_type);
			layout.flags = (uint) (win.flags);
			layout.bounds = (nk_rect) (win.bounds);
			layout.bounds.x += (float) (panel_padding.x);
			layout.bounds.w -= (float) (2*panel_padding.x);
			if ((win.flags & NK_WINDOW_BORDER) != 0)
			{
				layout.border = (float) (nk_panel_get_border(style, (uint) (win.flags), (int) (panel_type)));
				layout.bounds = (nk_rect) (nk_shrink_rect_((nk_rect) (layout.bounds), (float) (layout.border)));
			}
			else layout.border = (float) (0);
			layout.at_y = (float) (layout.bounds.y);
			layout.at_x = (float) (layout.bounds.x);
			layout.max_x = (float) (0);
			layout.header_height = (float) (0);
			layout.footer_height = (float) (0);
			nk_layout_reset_min_row_height(ctx);
			layout.row.index = (int) (0);
			layout.row.columns = (int) (0);
			layout.row.ratio = null;
			layout.row.item_width = (float) (0);
			layout.row.tree_depth = (int) (0);
			layout.row.height = (float) (panel_padding.y);
			layout.has_scrolling = (uint) (nk_true);
			if ((win.flags & NK_WINDOW_NO_SCROLLBAR) == 0) layout.bounds.w -= (float) (scrollbar_size.x);
			if (nk_panel_is_nonblock((int) (panel_type)) == 0)
			{
				layout.footer_height = (float) (0);
				if (((win.flags & NK_WINDOW_NO_SCROLLBAR) == 0) || ((win.flags & NK_WINDOW_SCALABLE) != 0))
					layout.footer_height = (float) (scrollbar_size.y);
				layout.bounds.h -= (float) (layout.footer_height);
			}

			if ((nk_panel_has_header((uint) (win.flags), title)) != 0)
			{
				nk_text text = new nk_text();
				nk_rect header = new nk_rect();
				nk_style_item background = null;
				header.x = (float) (win.bounds.x);
				header.y = (float) (win.bounds.y);
				header.w = (float) (win.bounds.w);
				header.h = (float) (font.height + 2.0f*style.window.header.padding.y);
				header.h += (float) (2.0f*style.window.header.label_padding.y);
				layout.header_height = (float) (header.h);
				layout.bounds.y += (float) (header.h);
				layout.bounds.h -= (float) (header.h);
				layout.at_y += (float) (header.h);
				if ((ctx.active) == (win))
				{
					background = style.window.header.active;
					text.text = (nk_color) (style.window.header.label_active);
				}
				else if ((nk_input_is_mouse_hovering_rect(ctx.input, (nk_rect) (header))) != 0)
				{
					background = style.window.header.hover;
					text.text = (nk_color) (style.window.header.label_hover);
				}
				else
				{
					background = style.window.header.normal;
					text.text = (nk_color) (style.window.header.label_normal);
				}
				header.h += (float) (1.0f);
				if ((background.type) == (NK_STYLE_ITEM_IMAGE))
				{
					text.background = (nk_color) (nk_rgba((int) (0), (int) (0), (int) (0), (int) (0)));
					nk_draw_image(win.buffer, (nk_rect) (header), background.data.image, (nk_color) (nk_white));
				}
				else
				{
					text.background = (nk_color) (background.data.color);
					nk_fill_rect(_out_, (nk_rect) (header), (float) (0), (nk_color) (background.data.color));
				}
				{
					nk_rect button = new nk_rect();
					button.y = (float) (header.y + style.window.header.padding.y);
					button.h = (float) (header.h - 2*style.window.header.padding.y);
					button.w = (float) (button.h);
					if ((win.flags & NK_WINDOW_CLOSABLE) != 0)
					{
						uint ws = (uint) (0);
						if ((style.window.header.align) == (NK_HEADER_RIGHT))
						{
							button.x = (float) ((header.w + header.x) - (button.w + style.window.header.padding.x));
							header.w -= (float) (button.w + style.window.header.spacing.x + style.window.header.padding.x);
						}
						else
						{
							button.x = (float) (header.x + style.window.header.padding.x);
							header.x += (float) (button.w + style.window.header.spacing.x + style.window.header.padding.x);
						}
						if (
							((nk_do_button_symbol(ref ws, win.buffer, (nk_rect) (button), (int) (style.window.header.close_symbol),
								(int) (NK_BUTTON_DEFAULT), style.window.header.close_button, _in_, style.font)) != 0) &&
							((win.flags & NK_WINDOW_ROM) == 0))
						{
							layout.flags |= (uint) (NK_WINDOW_HIDDEN);
							layout.flags &= ((uint) (~(uint) NK_WINDOW_MINIMIZED));
						}
					}
					if ((win.flags & NK_WINDOW_MINIMIZABLE) != 0)
					{
						uint ws = (uint) (0);
						if ((style.window.header.align) == (NK_HEADER_RIGHT))
						{
							button.x = (float) ((header.w + header.x) - button.w);
							if ((win.flags & NK_WINDOW_CLOSABLE) == 0)
							{
								button.x -= (float) (style.window.header.padding.x);
								header.w -= (float) (style.window.header.padding.x);
							}
							header.w -= (float) (button.w + style.window.header.spacing.x);
						}
						else
						{
							button.x = (float) (header.x);
							header.x += (float) (button.w + style.window.header.spacing.x + style.window.header.padding.x);
						}
						if (
							((nk_do_button_symbol(ref ws, win.buffer, (nk_rect) (button),
								(int)
									((layout.flags & NK_WINDOW_MINIMIZED) != 0
										? style.window.header.maximize_symbol
										: style.window.header.minimize_symbol), (int) (NK_BUTTON_DEFAULT), style.window.header.minimize_button, _in_,
								style.font)) != 0) && ((win.flags & NK_WINDOW_ROM) == 0))
							layout.flags =
								(uint)
									((layout.flags & NK_WINDOW_MINIMIZED) != 0
										? layout.flags & (uint) (~(uint) NK_WINDOW_MINIMIZED)
										: layout.flags | NK_WINDOW_MINIMIZED);
					}
				}
				{
					int text_len = (int) (nk_strlen(title));
					nk_rect label = new nk_rect();
					float t = (float) (font.width((nk_handle) (font.userdata), (float) (font.height), title, (int) (text_len)));
					text.padding = (nk_vec2) (nk_vec2_((float) (0), (float) (0)));
					label.x = (float) (header.x + style.window.header.padding.x);
					label.x += (float) (style.window.header.label_padding.x);
					label.y = (float) (header.y + style.window.header.label_padding.y);
					label.h = (float) (font.height + 2*style.window.header.label_padding.y);
					label.w = (float) (t + 2*style.window.header.spacing.x);
					label.w =
						(float)
							(((label.w) < (header.x + header.w - label.x) ? (label.w) : (header.x + header.w - label.x)) < (0)
								? (0)
								: ((label.w) < (header.x + header.w - label.x) ? (label.w) : (header.x + header.w - label.x)));
					nk_widget_text(_out_, (nk_rect) (label), title, (int) (text_len), &text, (uint) (NK_TEXT_LEFT), font);
				}
			}

			if (((layout.flags & NK_WINDOW_MINIMIZED) == 0) && ((layout.flags & NK_WINDOW_DYNAMIC) == 0))
			{
				nk_rect body = new nk_rect();
				body.x = (float) (win.bounds.x);
				body.w = (float) (win.bounds.w);
				body.y = (float) (win.bounds.y + layout.header_height);
				body.h = (float) (win.bounds.h - layout.header_height);
				if ((style.window.fixed_background.type) == (NK_STYLE_ITEM_IMAGE))
					nk_draw_image(_out_, (nk_rect) (body), style.window.fixed_background.data.image, (nk_color) (nk_white));
				else nk_fill_rect(_out_, (nk_rect) (body), (float) (0), (nk_color) (style.window.fixed_background.data.color));
			}

			{
				nk_rect clip = new nk_rect();
				layout.clip = (nk_rect) (layout.bounds);
				nk_unify(ref clip, ref win.buffer.clip, (float) (layout.clip.x), (float) (layout.clip.y),
					(float) (layout.clip.x + layout.clip.w), (float) (layout.clip.y + layout.clip.h));
				nk_push_scissor(_out_, (nk_rect) (clip));
				layout.clip = (nk_rect) (clip);
			}

			return (int) (((layout.flags & NK_WINDOW_HIDDEN) == 0) && ((layout.flags & NK_WINDOW_MINIMIZED) == 0) ? 1 : 0);
		}

		public static void nk_panel_end(nk_context ctx)
		{
			nk_input _in_;
			nk_window window;
			nk_panel layout;
			nk_style style;
			nk_command_buffer _out_;
			nk_vec2 scrollbar_size = new nk_vec2();
			nk_vec2 panel_padding = new nk_vec2();
			if (((ctx == null) || (ctx.current == null)) || (ctx.current.layout == null)) return;
			window = ctx.current;
			layout = window.layout;
			style = ctx.style;
			_out_ = window.buffer;
			_in_ = (((layout.flags & NK_WINDOW_ROM) != 0) || ((layout.flags & NK_WINDOW_NO_INPUT) != 0)) ? null : ctx.input;
			if (nk_panel_is_sub((int) (layout.type)) == 0) nk_push_scissor(_out_, (nk_rect) (nk_null_rect));
			scrollbar_size = (nk_vec2) (style.window.scrollbar_size);
			panel_padding = (nk_vec2) (nk_panel_get_padding(style, (int) (layout.type)));
			layout.at_y += (float) (layout.row.height);
			if (((layout.flags & NK_WINDOW_DYNAMIC) != 0) && ((layout.flags & NK_WINDOW_MINIMIZED) == 0))
			{
				nk_rect empty_space = new nk_rect();
				if ((layout.at_y) < (layout.bounds.y + layout.bounds.h)) layout.bounds.h = (float) (layout.at_y - layout.bounds.y);
				empty_space.x = (float) (window.bounds.x);
				empty_space.y = (float) (layout.bounds.y);
				empty_space.h = (float) (panel_padding.y);
				empty_space.w = (float) (window.bounds.w);
				nk_fill_rect(_out_, (nk_rect) (empty_space), (float) (0), (nk_color) (style.window.background));
				empty_space.x = (float) (window.bounds.x);
				empty_space.y = (float) (layout.bounds.y);
				empty_space.w = (float) (panel_padding.x + layout.border);
				empty_space.h = (float) (layout.bounds.h);
				nk_fill_rect(_out_, (nk_rect) (empty_space), (float) (0), (nk_color) (style.window.background));
				empty_space.x = (float) (layout.bounds.x + layout.bounds.w - layout.border);
				empty_space.y = (float) (layout.bounds.y);
				empty_space.w = (float) (panel_padding.x + layout.border);
				empty_space.h = (float) (layout.bounds.h);
				if (((layout.offset.y) == (0)) && ((layout.flags & NK_WINDOW_NO_SCROLLBAR) == 0))
					empty_space.w += (float) (scrollbar_size.x);
				nk_fill_rect(_out_, (nk_rect) (empty_space), (float) (0), (nk_color) (style.window.background));
				if ((layout.offset.x != 0) && ((layout.flags & NK_WINDOW_NO_SCROLLBAR) == 0))
				{
					empty_space.x = (float) (window.bounds.x);
					empty_space.y = (float) (layout.bounds.y + layout.bounds.h);
					empty_space.w = (float) (window.bounds.w);
					empty_space.h = (float) (scrollbar_size.y);
					nk_fill_rect(_out_, (nk_rect) (empty_space), (float) (0), (nk_color) (style.window.background));
				}
			}

			if ((((layout.flags & NK_WINDOW_NO_SCROLLBAR) == 0) && ((layout.flags & NK_WINDOW_MINIMIZED) == 0)) &&
			    ((window.scrollbar_hiding_timer) < (4.0f)))
			{
				nk_rect scroll = new nk_rect();
				int scroll_has_scrolling;
				float scroll_target;
				float scroll_offset;
				float scroll_step;
				float scroll_inc;
				if ((nk_panel_is_sub((int) (layout.type))) != 0)
				{
					nk_window root_window = window;
					nk_panel root_panel = window.layout;
					while ((root_panel.parent) != null)
					{
						root_panel = root_panel.parent;
					}
					while ((root_window.parent) != null)
					{
						root_window = root_window.parent;
					}
					scroll_has_scrolling = (int) (0);
					if (((root_window) == (ctx.active)) && ((layout.has_scrolling) != 0))
					{
						if (((nk_input_is_mouse_hovering_rect(_in_, (nk_rect) (layout.bounds))) != 0) &&
						    (!(((((root_panel.clip.x) > (layout.bounds.x + layout.bounds.w)) ||
						         ((root_panel.clip.x + root_panel.clip.w) < (layout.bounds.x))) ||
						        ((root_panel.clip.y) > (layout.bounds.y + layout.bounds.h))) ||
						       ((root_panel.clip.y + root_panel.clip.h) < (layout.bounds.y)))))
						{
							root_panel = window.layout;
							while ((root_panel.parent) != null)
							{
								root_panel.has_scrolling = (uint) (nk_false);
								root_panel = root_panel.parent;
							}
							root_panel.has_scrolling = (uint) (nk_false);
							scroll_has_scrolling = (int) (nk_true);
						}
					}
				}
				else if (nk_panel_is_sub((int) (layout.type)) == 0)
				{
					scroll_has_scrolling = (int) (((window) == (ctx.active)) && ((layout.has_scrolling) != 0) ? 1 : 0);
					if ((((_in_) != null) && (((_in_.mouse.scroll_delta.y) > (0)) || ((_in_.mouse.scroll_delta.x) > (0)))) &&
					    ((scroll_has_scrolling) != 0)) window.scrolled = (uint) (nk_true);
					else window.scrolled = (uint) (nk_false);
				}
				else scroll_has_scrolling = (int) (nk_false);
				{
					uint state = (uint) (0);
					scroll.x = (float) (layout.bounds.x + layout.bounds.w + panel_padding.x);
					scroll.y = (float) (layout.bounds.y);
					scroll.w = (float) (scrollbar_size.x);
					scroll.h = (float) (layout.bounds.h);
					scroll_offset = ((float) (layout.offset.y));
					scroll_step = (float) (scroll.h*0.10f);
					scroll_inc = (float) (scroll.h*0.01f);
					scroll_target = ((float) ((int) (layout.at_y - scroll.y)));
					scroll_offset =
						(float)
							(nk_do_scrollbarv(ref state, _out_, (nk_rect) (scroll), (int) (scroll_has_scrolling), (float) (scroll_offset),
								(float) (scroll_target), (float) (scroll_step), (float) (scroll_inc), ctx.style.scrollv, _in_, style.font));
					layout.offset.y = ((uint) (scroll_offset));
					if (((_in_) != null) && ((scroll_has_scrolling) != 0)) _in_.mouse.scroll_delta.y = (float) (0);
				}
				{
					uint state = (uint) (0);
					scroll.x = (float) (layout.bounds.x);
					scroll.y = (float) (layout.bounds.y + layout.bounds.h);
					scroll.w = (float) (layout.bounds.w);
					scroll.h = (float) (scrollbar_size.y);
					scroll_offset = ((float) (layout.offset.x));
					scroll_target = ((float) ((int) (layout.max_x - scroll.x)));
					scroll_step = (float) (layout.max_x*0.05f);
					scroll_inc = (float) (layout.max_x*0.005f);
					scroll_offset =
						(float)
							(nk_do_scrollbarh(ref state, _out_, (nk_rect) (scroll), (int) (scroll_has_scrolling), (float) (scroll_offset),
								(float) (scroll_target), (float) (scroll_step), (float) (scroll_inc), ctx.style.scrollh, _in_, style.font));
					layout.offset.x = ((uint) (scroll_offset));
				}
			}

			if ((window.flags & NK_WINDOW_SCROLL_AUTO_HIDE) != 0)
			{
				int has_input =
					(int)
						(((ctx.input.mouse.delta.x != 0) || (ctx.input.mouse.delta.y != 0)) || (ctx.input.mouse.scroll_delta.y != 0)
							? 1
							: 0);
				int is_window_hovered = (int) (nk_window_is_hovered(ctx));
				int any_item_active = (int) (ctx.last_widget_state & NK_WIDGET_STATE_MODIFIED);
				if (((has_input == 0) && ((is_window_hovered) != 0)) || ((is_window_hovered == 0) && (any_item_active == 0)))
					window.scrollbar_hiding_timer += (float) (ctx.delta_time_seconds);
				else window.scrollbar_hiding_timer = (float) (0);
			}
			else window.scrollbar_hiding_timer = (float) (0);
			if ((layout.flags & NK_WINDOW_BORDER) != 0)
			{
				nk_color border_color = (nk_color) (nk_panel_get_border_color(style, (int) (layout.type)));
				float padding_y =
					(float)
						((layout.flags & NK_WINDOW_MINIMIZED) != 0
							? style.window.border + window.bounds.y + layout.header_height
							: (layout.flags & NK_WINDOW_DYNAMIC) != 0
								? layout.bounds.y + layout.bounds.h + layout.footer_height
								: window.bounds.y + window.bounds.h);
				nk_stroke_line(_out_, (float) (window.bounds.x), (float) (window.bounds.y),
					(float) (window.bounds.x + window.bounds.w), (float) (window.bounds.y), (float) (layout.border),
					(nk_color) (border_color));
				nk_stroke_line(_out_, (float) (window.bounds.x), (float) (padding_y), (float) (window.bounds.x + window.bounds.w),
					(float) (padding_y), (float) (layout.border), (nk_color) (border_color));
				nk_stroke_line(_out_, (float) (window.bounds.x + layout.border*0.5f), (float) (window.bounds.y),
					(float) (window.bounds.x + layout.border*0.5f), (float) (padding_y), (float) (layout.border),
					(nk_color) (border_color));
				nk_stroke_line(_out_, (float) (window.bounds.x + window.bounds.w - layout.border*0.5f), (float) (window.bounds.y),
					(float) (window.bounds.x + window.bounds.w - layout.border*0.5f), (float) (padding_y), (float) (layout.border),
					(nk_color) (border_color));
			}

			if ((((layout.flags & NK_WINDOW_SCALABLE) != 0) && ((_in_) != null)) && ((layout.flags & NK_WINDOW_MINIMIZED) == 0))
			{
				nk_rect scaler = new nk_rect();
				scaler.w = (float) (scrollbar_size.x);
				scaler.h = (float) (scrollbar_size.y);
				scaler.y = (float) (layout.bounds.y + layout.bounds.h);
				if ((layout.flags & NK_WINDOW_SCALE_LEFT) != 0) scaler.x = (float) (layout.bounds.x - panel_padding.x*0.5f);
				else scaler.x = (float) (layout.bounds.x + layout.bounds.w + panel_padding.x);
				if ((layout.flags & NK_WINDOW_NO_SCROLLBAR) != 0) scaler.x -= (float) (scaler.w);
				{
					nk_style_item item = style.window.scaler;
					if ((item.type) == (NK_STYLE_ITEM_IMAGE))
						nk_draw_image(_out_, (nk_rect) (scaler), item.data.image, (nk_color) (nk_white));
					else
					{
						if ((layout.flags & NK_WINDOW_SCALE_LEFT) != 0)
						{
							nk_fill_triangle(_out_, (float) (scaler.x), (float) (scaler.y), (float) (scaler.x), (float) (scaler.y + scaler.h),
								(float) (scaler.x + scaler.w), (float) (scaler.y + scaler.h), (nk_color) (item.data.color));
						}
						else
						{
							nk_fill_triangle(_out_, (float) (scaler.x + scaler.w), (float) (scaler.y), (float) (scaler.x + scaler.w),
								(float) (scaler.y + scaler.h), (float) (scaler.x), (float) (scaler.y + scaler.h), (nk_color) (item.data.color));
						}
					}
				}
				if ((window.flags & NK_WINDOW_ROM) == 0)
				{
					nk_vec2 window_size = (nk_vec2) (style.window.min_size);
					int left_mouse_down = (int) (((nk_mouse_button*) _in_.mouse.buttons + NK_BUTTON_LEFT)->down);
					int left_mouse_click_in_scaler =
						(int) (nk_input_has_mouse_click_down_in_rect(_in_, (int) (NK_BUTTON_LEFT), (nk_rect) (scaler), (int) (nk_true)));
					if (((left_mouse_down) != 0) && ((left_mouse_click_in_scaler) != 0))
					{
						float delta_x = (float) (_in_.mouse.delta.x);
						if ((layout.flags & NK_WINDOW_SCALE_LEFT) != 0)
						{
							delta_x = (float) (-delta_x);
							window.bounds.x += (float) (_in_.mouse.delta.x);
						}
						if ((window.bounds.w + delta_x) >= (window_size.x))
						{
							if (((delta_x) < (0)) || (((delta_x) > (0)) && ((_in_.mouse.pos.x) >= (scaler.x))))
							{
								window.bounds.w = (float) (window.bounds.w + delta_x);
								scaler.x += (float) (_in_.mouse.delta.x);
							}
						}
						if ((layout.flags & NK_WINDOW_DYNAMIC) == 0)
						{
							if ((window_size.y) < (window.bounds.h + _in_.mouse.delta.y))
							{
								if (((_in_.mouse.delta.y) < (0)) || (((_in_.mouse.delta.y) > (0)) && ((_in_.mouse.pos.y) >= (scaler.y))))
								{
									window.bounds.h = (float) (window.bounds.h + _in_.mouse.delta.y);
									scaler.y += (float) (_in_.mouse.delta.y);
								}
							}
						}
						ctx.style.cursor_active = ctx.style.cursors[NK_CURSOR_RESIZE_TOP_RIGHT_DOWN_LEFT];
						((nk_mouse_button*) _in_.mouse.buttons + NK_BUTTON_LEFT)->clicked_pos.x = (float) (scaler.x + scaler.w/2.0f);
						((nk_mouse_button*) _in_.mouse.buttons + NK_BUTTON_LEFT)->clicked_pos.y = (float) (scaler.y + scaler.h/2.0f);
					}
				}
			}

			if (nk_panel_is_sub((int) (layout.type)) == 0)
			{
				if ((layout.flags & NK_WINDOW_HIDDEN) != 0) nk_command_buffer_reset(window.buffer);
				else nk_finish(ctx, window);
			}

			if ((layout.flags & NK_WINDOW_REMOVE_ROM) != 0)
			{
				layout.flags &= (uint) (~(uint) (NK_WINDOW_ROM));
				layout.flags &= (uint) (~(uint) (NK_WINDOW_REMOVE_ROM));
			}

			window.flags = (uint) (layout.flags);
			if ((((window.property.active) != 0) && (window.property.old != window.property.seq)) &&
			    ((window.property.active) == (window.property.prev)))
			{
			}
			else
			{
				window.property.old = (uint) (window.property.seq);
				window.property.prev = (int) (window.property.active);
				window.property.seq = (uint) (0);
			}

			if ((((window.edit.active) != 0) && (window.edit.old != window.edit.seq)) &&
			    ((window.edit.active) == (window.edit.prev)))
			{
			}
			else
			{
				window.edit.old = (uint) (window.edit.seq);
				window.edit.prev = (int) (window.edit.active);
				window.edit.seq = (uint) (0);
			}

			if (((window.popup.active_con) != 0) && (window.popup.con_old != window.popup.con_count))
			{
				window.popup.con_count = (uint) (0);
				window.popup.con_old = (uint) (0);
				window.popup.active_con = (uint) (0);
			}
			else
			{
				window.popup.con_old = (uint) (window.popup.con_count);
				window.popup.con_count = (uint) (0);
			}

			window.popup.combo_count = (uint) (0);
		}

		public static void nk_push_table(nk_window win, nk_table tbl)
		{
			if (win.tables == null)
			{
				win.tables = tbl;
				tbl.next = null;
				tbl.prev = null;
				tbl.size = (uint) (0);
				win.table_count = (uint) (1);
				return;
			}

			win.tables.prev = tbl;
			tbl.next = win.tables;
			tbl.prev = null;
			tbl.size = (uint) (0);
			win.tables = tbl;
			win.table_count++;
		}

		public static void nk_remove_table(nk_window win, nk_table tbl)
		{
			if ((win.tables) == (tbl)) win.tables = tbl.next;
			if ((tbl.next) != null) tbl.next.prev = tbl.prev;
			if ((tbl.prev) != null) tbl.prev.next = tbl.next;
			tbl.next = null;
			tbl.prev = null;
		}

		public static uint* nk_add_value(nk_context ctx, nk_window win, uint name, uint value)
		{
			if ((win == null) || (ctx == null)) return null;
			if ((win.tables == null) || ((win.tables.size) >= (51)))
			{
				nk_table tbl = nk_create_table(ctx);
				if (tbl == null) return null;
				nk_push_table(win, tbl);
			}

			win.tables.seq = (uint) (win.seq);
			win.tables.keys[win.tables.size] = (uint) (name);
			win.tables.values[win.tables.size] = (uint) (value);
			return (uint*) win.tables.values + (win.tables.size++);
		}

		public static uint* nk_find_value(nk_window win, uint name)
		{
			nk_table iter = win.tables;
			while ((iter) != null)
			{
				uint i = (uint) (0);
				uint size = (uint) (iter.size);
				for (i = (uint) (0); (i) < (size); ++i)
				{
					if ((iter.keys[i]) == (name))
					{
						iter.seq = (uint) (win.seq);
						return (uint*) iter.values + i;
					}
				}
				size = (uint) (51);
				iter = iter.next;
			}
			return null;
		}

		public static nk_window nk_find_window(nk_context ctx, uint hash, char* name)
		{
			nk_window iter;
			iter = ctx.begin;
			while ((iter) != null)
			{
				if ((iter.name) == (hash))
				{
					int max_len = (int) (nk_strlen(iter.name_string));
					if (nk_stricmpn(iter.name_string, name, (int) (max_len)) == 0) return iter;
				}
				iter = iter.next;
			}
			return null;
		}

		public static void nk_insert_window(nk_context ctx, nk_window win, int loc)
		{
			nk_window iter;
			if ((win == null) || (ctx == null)) return;
			iter = ctx.begin;
			while ((iter) != null)
			{
				if ((iter) == (win)) return;
				iter = iter.next;
			}
			if (ctx.begin == null)
			{
				win.next = null;
				win.prev = null;
				ctx.begin = win;
				ctx.end = win;
				ctx.count = (uint) (1);
				return;
			}

			if ((loc) == (NK_INSERT_BACK))
			{
				nk_window end;
				end = ctx.end;
				end.flags |= (uint) (NK_WINDOW_ROM);
				end.next = win;
				win.prev = ctx.end;
				win.next = null;
				ctx.end = win;
				ctx.active = ctx.end;
				ctx.end.flags &= (uint) (~(uint) (NK_WINDOW_ROM));
			}
			else
			{
				ctx.begin.prev = win;
				win.next = ctx.begin;
				win.prev = null;
				ctx.begin = win;
				ctx.begin.flags &= (uint) (~(uint) (NK_WINDOW_ROM));
			}

			ctx.count++;
		}

		public static void nk_remove_window(nk_context ctx, nk_window win)
		{
			if (((win) == (ctx.begin)) || ((win) == (ctx.end)))
			{
				if ((win) == (ctx.begin))
				{
					ctx.begin = win.next;
					if ((win.next) != null) win.next.prev = null;
				}
				if ((win) == (ctx.end))
				{
					ctx.end = win.prev;
					if ((win.prev) != null) win.prev.next = null;
				}
			}
			else
			{
				if ((win.next) != null) win.next.prev = win.prev;
				if ((win.prev) != null) win.prev.next = win.next;
			}

			if (((win) == (ctx.active)) || (ctx.active == null))
			{
				ctx.active = ctx.end;
				if ((ctx.end) != null) ctx.end.flags &= (uint) (~(uint) (NK_WINDOW_ROM));
			}

			win.next = null;
			win.prev = null;
			ctx.count--;
		}

		public static int nk_begin(nk_context ctx, char* title, nk_rect bounds, uint flags)
		{
			return (int) (nk_begin_titled(ctx, title, title, (nk_rect) (bounds), (uint) (flags)));
		}

		public static int nk_begin_titled(nk_context ctx, char* name, char* title, nk_rect bounds, uint flags)
		{
			nk_window win;
			nk_style style;
			uint title_hash;
			int title_len;
			int ret = (int) (0);
			if ((((ctx == null) || ((ctx.current) != null)) || (title == null)) || (name == null)) return (int) (0);
			style = ctx.style;
			title_len = (int) (nk_strlen(name));
			title_hash = (uint) (nk_murmur_hash(name, (int) (title_len), (uint) (NK_WINDOW_TITLE)));
			win = nk_find_window(ctx, (uint) (title_hash), name);
			if (win == null)
			{
				ulong name_length = (ulong) (nk_strlen(name));
				win = (nk_window) (nk_create_window(ctx));
				if (win == null) return (int) (0);
				if ((flags & NK_WINDOW_BACKGROUND) != 0) nk_insert_window(ctx, win, (int) (NK_INSERT_FRONT));
				else nk_insert_window(ctx, win, (int) (NK_INSERT_BACK));
				nk_command_buffer_init(win.buffer, (int) (NK_CLIPPING_ON));
				win.flags = (uint) (flags);
				win.bounds = (nk_rect) (bounds);
				win.name = (uint) (title_hash);
				name_length = (ulong) ((name_length) < (64 - 1) ? (name_length) : (64 - 1));
				nk_memcopy(win.name_string, name, (ulong) (name_length));
				win.name_string[name_length] = (char) (0);
				win.popup.win = null;
				if (ctx.active == null) ctx.active = win;
			}
			else
			{
				win.flags &= (uint) (~(uint) (NK_WINDOW_PRIVATE - 1));
				win.flags |= (uint) (flags);
				if ((win.flags & (NK_WINDOW_MOVABLE | NK_WINDOW_SCALABLE)) == 0) win.bounds = (nk_rect) (bounds);
				win.seq = (uint) (ctx.seq);
				if ((ctx.active == null) && ((win.flags & NK_WINDOW_HIDDEN) == 0))
				{
					ctx.active = win;
					ctx.end = win;
				}
			}

			if ((win.flags & NK_WINDOW_HIDDEN) != 0)
			{
				ctx.current = win;
				win.layout = null;
				return (int) (0);
			}
			else nk_start(ctx, win);
			if (((win.flags & NK_WINDOW_HIDDEN) == 0) && ((win.flags & NK_WINDOW_NO_INPUT) == 0))
			{
				int inpanel;
				int ishovered;
				nk_window iter = win;
				float h =
					(float) (ctx.style.font.height + 2.0f*style.window.header.padding.y + (2.0f*style.window.header.label_padding.y));
				nk_rect win_bounds =
					(nk_rect)
						(((win.flags & NK_WINDOW_MINIMIZED) == 0)
							? win.bounds
							: nk_rect_((float) (win.bounds.x), (float) (win.bounds.y), (float) (win.bounds.w), (float) (h)));
				inpanel =
					(int)
						(nk_input_has_mouse_click_down_in_rect(ctx.input, (int) (NK_BUTTON_LEFT), (nk_rect) (win_bounds), (int) (nk_true)));
				inpanel = (int) (((inpanel) != 0) && ((ctx.input.mouse.buttons[NK_BUTTON_LEFT].clicked) != 0) ? 1 : 0);
				ishovered = (int) (nk_input_is_mouse_hovering_rect(ctx.input, (nk_rect) (win_bounds)));
				if (((win != ctx.active) && ((ishovered) != 0)) && (ctx.input.mouse.buttons[NK_BUTTON_LEFT].down == 0))
				{
					iter = win.next;
					while ((iter) != null)
					{
						nk_rect iter_bounds =
							(nk_rect)
								(((iter.flags & NK_WINDOW_MINIMIZED) == 0)
									? iter.bounds
									: nk_rect_((float) (iter.bounds.x), (float) (iter.bounds.y), (float) (iter.bounds.w), (float) (h)));
						if (
							(!(((((iter_bounds.x) > (win_bounds.x + win_bounds.w)) || ((iter_bounds.x + iter_bounds.w) < (win_bounds.x))) ||
							    ((iter_bounds.y) > (win_bounds.y + win_bounds.h))) || ((iter_bounds.y + iter_bounds.h) < (win_bounds.y)))) &&
							((iter.flags & NK_WINDOW_HIDDEN) == 0)) break;
						if (((((iter.popup.win) != null) && ((iter.popup.active) != 0)) && ((iter.flags & NK_WINDOW_HIDDEN) == 0)) &&
						    (!(((((iter.popup.win.bounds.x) > (win.bounds.x + win_bounds.w)) ||
						         ((iter.popup.win.bounds.x + iter.popup.win.bounds.w) < (win.bounds.x))) ||
						        ((iter.popup.win.bounds.y) > (win_bounds.y + win_bounds.h))) ||
						       ((iter.popup.win.bounds.y + iter.popup.win.bounds.h) < (win_bounds.y))))) break;
						iter = iter.next;
					}
				}
				if ((((iter) != null) && ((inpanel) != 0)) && (win != ctx.end))
				{
					iter = win.next;
					while ((iter) != null)
					{
						nk_rect iter_bounds =
							(nk_rect)
								(((iter.flags & NK_WINDOW_MINIMIZED) == 0)
									? iter.bounds
									: nk_rect_((float) (iter.bounds.x), (float) (iter.bounds.y), (float) (iter.bounds.w), (float) (h)));
						if (((((iter_bounds.x) <= (ctx.input.mouse.pos.x)) && ((ctx.input.mouse.pos.x) < (iter_bounds.x + iter_bounds.w))) &&
						     (((iter_bounds.y) <= (ctx.input.mouse.pos.y)) && ((ctx.input.mouse.pos.y) < (iter_bounds.y + iter_bounds.h)))) &&
						    ((iter.flags & NK_WINDOW_HIDDEN) == 0)) break;
						if (((((iter.popup.win) != null) && ((iter.popup.active) != 0)) && ((iter.flags & NK_WINDOW_HIDDEN) == 0)) &&
						    (!(((((iter.popup.win.bounds.x) > (win_bounds.x + win_bounds.w)) ||
						         ((iter.popup.win.bounds.x + iter.popup.win.bounds.w) < (win_bounds.x))) ||
						        ((iter.popup.win.bounds.y) > (win_bounds.y + win_bounds.h))) ||
						       ((iter.popup.win.bounds.y + iter.popup.win.bounds.h) < (win_bounds.y))))) break;
						iter = iter.next;
					}
				}
				if ((((iter) != null) && ((win.flags & NK_WINDOW_ROM) == 0)) && ((win.flags & NK_WINDOW_BACKGROUND) != 0))
				{
					win.flags |= ((uint) (NK_WINDOW_ROM));
					iter.flags &= (uint) (~(uint) (NK_WINDOW_ROM));
					ctx.active = iter;
					if ((iter.flags & NK_WINDOW_BACKGROUND) == 0)
					{
						nk_remove_window(ctx, iter);
						nk_insert_window(ctx, iter, (int) (NK_INSERT_BACK));
					}
				}
				else
				{
					if ((iter == null) && (ctx.end != win))
					{
						if ((win.flags & NK_WINDOW_BACKGROUND) == 0)
						{
							nk_remove_window(ctx, win);
							nk_insert_window(ctx, win, (int) (NK_INSERT_BACK));
						}
						win.flags &= (uint) (~(uint) (NK_WINDOW_ROM));
						ctx.active = win;
					}
					if ((ctx.end != win) && ((win.flags & NK_WINDOW_BACKGROUND) == 0)) win.flags |= (uint) (NK_WINDOW_ROM);
				}
			}

			win.layout = (nk_panel) (nk_create_panel(ctx));
			ctx.current = win;
			ret = (int) (nk_panel_begin(ctx, title, (int) (NK_PANEL_WINDOW)));
			win.layout.offset = win.scrollbar;

			return (int) (ret);
		}

		public static void nk_end(nk_context ctx)
		{
			nk_panel layout;
			if ((ctx == null) || (ctx.current == null)) return;
			layout = ctx.current.layout;
			if ((layout == null) || (((layout.type) == (NK_PANEL_WINDOW)) && ((ctx.current.flags & NK_WINDOW_HIDDEN) != 0)))
			{
				ctx.current = null;
				return;
			}

			nk_panel_end(ctx);

			ctx.current = null;
		}

		public static nk_rect nk_window_get_bounds(nk_context ctx)
		{
			if ((ctx == null) || (ctx.current == null))
				return (nk_rect) (nk_rect_((float) (0), (float) (0), (float) (0), (float) (0)));
			return (nk_rect) (ctx.current.bounds);
		}

		public static nk_vec2 nk_window_get_position(nk_context ctx)
		{
			if ((ctx == null) || (ctx.current == null)) return (nk_vec2) (nk_vec2_((float) (0), (float) (0)));
			return (nk_vec2) (nk_vec2_((float) (ctx.current.bounds.x), (float) (ctx.current.bounds.y)));
		}

		public static nk_vec2 nk_window_get_size(nk_context ctx)
		{
			if ((ctx == null) || (ctx.current == null)) return (nk_vec2) (nk_vec2_((float) (0), (float) (0)));
			return (nk_vec2) (nk_vec2_((float) (ctx.current.bounds.w), (float) (ctx.current.bounds.h)));
		}

		public static float nk_window_get_width(nk_context ctx)
		{
			if ((ctx == null) || (ctx.current == null)) return (float) (0);
			return (float) (ctx.current.bounds.w);
		}

		public static float nk_window_get_height(nk_context ctx)
		{
			if ((ctx == null) || (ctx.current == null)) return (float) (0);
			return (float) (ctx.current.bounds.h);
		}

		public static nk_rect nk_window_get_content_region(nk_context ctx)
		{
			if ((ctx == null) || (ctx.current == null))
				return (nk_rect) (nk_rect_((float) (0), (float) (0), (float) (0), (float) (0)));
			return (nk_rect) (ctx.current.layout.clip);
		}

		public static nk_vec2 nk_window_get_content_region_min(nk_context ctx)
		{
			if ((ctx == null) || (ctx.current == null)) return (nk_vec2) (nk_vec2_((float) (0), (float) (0)));
			return (nk_vec2) (nk_vec2_((float) (ctx.current.layout.clip.x), (float) (ctx.current.layout.clip.y)));
		}

		public static nk_vec2 nk_window_get_content_region_max(nk_context ctx)
		{
			if ((ctx == null) || (ctx.current == null)) return (nk_vec2) (nk_vec2_((float) (0), (float) (0)));
			return
				(nk_vec2)
					(nk_vec2_((float) (ctx.current.layout.clip.x + ctx.current.layout.clip.w),
						(float) (ctx.current.layout.clip.y + ctx.current.layout.clip.h)));
		}

		public static nk_vec2 nk_window_get_content_region_size(nk_context ctx)
		{
			if ((ctx == null) || (ctx.current == null)) return (nk_vec2) (nk_vec2_((float) (0), (float) (0)));
			return (nk_vec2) (nk_vec2_((float) (ctx.current.layout.clip.w), (float) (ctx.current.layout.clip.h)));
		}

		public static nk_command_buffer nk_window_get_canvas(nk_context ctx)
		{
			if ((ctx == null) || (ctx.current == null)) return null;
			return ctx.current.buffer;
		}

		public static nk_panel nk_window_get_panel(nk_context ctx)
		{
			if ((ctx == null) || (ctx.current == null)) return null;
			return ctx.current.layout;
		}

		public static int nk_window_has_focus(nk_context ctx)
		{
			if ((ctx == null) || (ctx.current == null)) return (int) (0);
			return (int) ((ctx.current) == (ctx.active) ? 1 : 0);
		}

		public static int nk_window_is_hovered(nk_context ctx)
		{
			if ((ctx == null) || (ctx.current == null)) return (int) (0);
			if ((ctx.current.flags & NK_WINDOW_HIDDEN) != 0) return (int) (0);
			return (int) (nk_input_is_mouse_hovering_rect(ctx.input, (nk_rect) (ctx.current.bounds)));
		}

		public static int nk_window_is_any_hovered(nk_context ctx)
		{
			nk_window iter;
			if (ctx == null) return (int) (0);
			iter = ctx.begin;
			while ((iter) != null)
			{
				if ((iter.flags & NK_WINDOW_HIDDEN) == 0)
				{
					if ((((iter.popup.active) != 0) && ((iter.popup.win) != null)) &&
					    ((nk_input_is_mouse_hovering_rect(ctx.input, (nk_rect) (iter.popup.win.bounds))) != 0)) return (int) (1);
					if ((iter.flags & NK_WINDOW_MINIMIZED) != 0)
					{
						nk_rect header = (nk_rect) (iter.bounds);
						header.h = (float) (ctx.style.font.height + 2*ctx.style.window.header.padding.y);
						if ((nk_input_is_mouse_hovering_rect(ctx.input, (nk_rect) (header))) != 0) return (int) (1);
					}
					else if ((nk_input_is_mouse_hovering_rect(ctx.input, (nk_rect) (iter.bounds))) != 0)
					{
						return (int) (1);
					}
				}
				iter = iter.next;
			}
			return (int) (0);
		}

		public static int nk_item_is_any_active(nk_context ctx)
		{
			int any_hovered = (int) (nk_window_is_any_hovered(ctx));
			int any_active = (int) (ctx.last_widget_state & NK_WIDGET_STATE_MODIFIED);
			return (int) (((any_hovered) != 0) || ((any_active) != 0) ? 1 : 0);
		}

		public static int nk_window_is_collapsed(nk_context ctx, char* name)
		{
			int title_len;
			uint title_hash;
			nk_window win;
			if (ctx == null) return (int) (0);
			title_len = (int) (nk_strlen(name));
			title_hash = (uint) (nk_murmur_hash(name, (int) (title_len), (uint) (NK_WINDOW_TITLE)));
			win = nk_find_window(ctx, (uint) (title_hash), name);
			if (win == null) return (int) (0);
			return (int) (win.flags & NK_WINDOW_MINIMIZED);
		}

		public static int nk_window_is_closed(nk_context ctx, char* name)
		{
			int title_len;
			uint title_hash;
			nk_window win;
			if (ctx == null) return (int) (1);
			title_len = (int) (nk_strlen(name));
			title_hash = (uint) (nk_murmur_hash(name, (int) (title_len), (uint) (NK_WINDOW_TITLE)));
			win = nk_find_window(ctx, (uint) (title_hash), name);
			if (win == null) return (int) (1);
			return (int) (win.flags & NK_WINDOW_CLOSED);
		}

		public static int nk_window_is_hidden(nk_context ctx, char* name)
		{
			int title_len;
			uint title_hash;
			nk_window win;
			if (ctx == null) return (int) (1);
			title_len = (int) (nk_strlen(name));
			title_hash = (uint) (nk_murmur_hash(name, (int) (title_len), (uint) (NK_WINDOW_TITLE)));
			win = nk_find_window(ctx, (uint) (title_hash), name);
			if (win == null) return (int) (1);
			return (int) (win.flags & NK_WINDOW_HIDDEN);
		}

		public static int nk_window_is_active(nk_context ctx, char* name)
		{
			int title_len;
			uint title_hash;
			nk_window win;
			if (ctx == null) return (int) (0);
			title_len = (int) (nk_strlen(name));
			title_hash = (uint) (nk_murmur_hash(name, (int) (title_len), (uint) (NK_WINDOW_TITLE)));
			win = nk_find_window(ctx, (uint) (title_hash), name);
			if (win == null) return (int) (0);
			return (int) ((win) == (ctx.active) ? 1 : 0);
		}

		public static nk_window nk_window_find(nk_context ctx, char* name)
		{
			int title_len;
			uint title_hash;
			title_len = (int) (nk_strlen(name));
			title_hash = (uint) (nk_murmur_hash(name, (int) (title_len), (uint) (NK_WINDOW_TITLE)));
			return nk_find_window(ctx, (uint) (title_hash), name);
		}

		public static void nk_window_close(nk_context ctx, char* name)
		{
			nk_window win;
			if (ctx == null) return;
			win = nk_window_find(ctx, name);
			if (win == null) return;
			if ((ctx.current) == (win)) return;
			win.flags |= (uint) (NK_WINDOW_HIDDEN);
			win.flags |= (uint) (NK_WINDOW_CLOSED);
		}

		public static void nk_window_set_bounds(nk_context ctx, char* name, nk_rect bounds)
		{
			nk_window win;
			if (ctx == null) return;
			win = nk_window_find(ctx, name);
			if (win == null) return;
			win.bounds = (nk_rect) (bounds);
		}

		public static void nk_window_set_position(nk_context ctx, char* name, nk_vec2 pos)
		{
			nk_window win = nk_window_find(ctx, name);
			if (win == null) return;
			win.bounds.x = (float) (pos.x);
			win.bounds.y = (float) (pos.y);
		}

		public static void nk_window_set_size(nk_context ctx, char* name, nk_vec2 size)
		{
			nk_window win = nk_window_find(ctx, name);
			if (win == null) return;
			win.bounds.w = (float) (size.x);
			win.bounds.h = (float) (size.y);
		}

		public static void nk_window_collapse(nk_context ctx, char* name, int c)
		{
			int title_len;
			uint title_hash;
			nk_window win;
			if (ctx == null) return;
			title_len = (int) (nk_strlen(name));
			title_hash = (uint) (nk_murmur_hash(name, (int) (title_len), (uint) (NK_WINDOW_TITLE)));
			win = nk_find_window(ctx, (uint) (title_hash), name);
			if (win == null) return;
			if ((c) == (NK_MINIMIZED)) win.flags |= (uint) (NK_WINDOW_MINIMIZED);
			else win.flags &= (uint) (~(uint) (NK_WINDOW_MINIMIZED));
		}

		public static void nk_window_collapse_if(nk_context ctx, char* name, int c, int cond)
		{
			if ((ctx == null) || (cond == 0)) return;
			nk_window_collapse(ctx, name, (int) (c));
		}

		public static void nk_window_show(nk_context ctx, char* name, int s)
		{
			int title_len;
			uint title_hash;
			nk_window win;
			if (ctx == null) return;
			title_len = (int) (nk_strlen(name));
			title_hash = (uint) (nk_murmur_hash(name, (int) (title_len), (uint) (NK_WINDOW_TITLE)));
			win = nk_find_window(ctx, (uint) (title_hash), name);
			if (win == null) return;
			if ((s) == (NK_HIDDEN))
			{
				win.flags |= (uint) (NK_WINDOW_HIDDEN);
			}
			else win.flags &= (uint) (~(uint) (NK_WINDOW_HIDDEN));
		}

		public static void nk_window_show_if(nk_context ctx, char* name, int s, int cond)
		{
			if ((ctx == null) || (cond == 0)) return;
			nk_window_show(ctx, name, (int) (s));
		}

		public static void nk_window_set_focus(nk_context ctx, char* name)
		{
			int title_len;
			uint title_hash;
			nk_window win;
			if (ctx == null) return;
			title_len = (int) (nk_strlen(name));
			title_hash = (uint) (nk_murmur_hash(name, (int) (title_len), (uint) (NK_WINDOW_TITLE)));
			win = nk_find_window(ctx, (uint) (title_hash), name);
			if (((win) != null) && (ctx.end != win))
			{
				nk_remove_window(ctx, win);
				nk_insert_window(ctx, win, (int) (NK_INSERT_BACK));
			}

			ctx.active = win;
		}

		public static void nk_menubar_begin(nk_context ctx)
		{
			nk_panel layout;
			if (((ctx == null) || (ctx.current == null)) || (ctx.current.layout == null)) return;
			layout = ctx.current.layout;
			if (((layout.flags & NK_WINDOW_HIDDEN) != 0) || ((layout.flags & NK_WINDOW_MINIMIZED) != 0)) return;
			layout.menu.x = (float) (layout.at_x);
			layout.menu.y = (float) (layout.at_y + layout.row.height);
			layout.menu.w = (float) (layout.bounds.w);
			layout.menu.offset = layout.offset;

			layout.offset.y = (uint) (0);
		}

		public static void nk_menubar_end(nk_context ctx)
		{
			nk_window win;
			nk_panel layout;
			nk_command_buffer _out_;
			if (((ctx == null) || (ctx.current == null)) || (ctx.current.layout == null)) return;
			win = ctx.current;
			_out_ = win.buffer;
			layout = win.layout;
			if (((layout.flags & NK_WINDOW_HIDDEN) != 0) || ((layout.flags & NK_WINDOW_MINIMIZED) != 0)) return;
			layout.menu.h = (float) (layout.at_y - layout.menu.y);
			layout.bounds.y += (float) (layout.menu.h + ctx.style.window.spacing.y + layout.row.height);
			layout.bounds.h -= (float) (layout.menu.h + ctx.style.window.spacing.y + layout.row.height);
			layout.offset.x = (uint) (layout.menu.offset.x);
			layout.offset.y = (uint) (layout.menu.offset.y);
			layout.at_y = (float) (layout.bounds.y - layout.row.height);
			layout.clip.y = (float) (layout.bounds.y);
			layout.clip.h = (float) (layout.bounds.h);
			nk_push_scissor(_out_, (nk_rect) (layout.clip));
		}

		public static void nk_layout_set_min_row_height(nk_context ctx, float height)
		{
			nk_window win;
			nk_panel layout;
			if (((ctx == null) || (ctx.current == null)) || (ctx.current.layout == null)) return;
			win = ctx.current;
			layout = win.layout;
			layout.row.min_height = (float) (height);
		}

		public static void nk_layout_reset_min_row_height(nk_context ctx)
		{
			nk_window win;
			nk_panel layout;
			if (((ctx == null) || (ctx.current == null)) || (ctx.current.layout == null)) return;
			win = ctx.current;
			layout = win.layout;
			layout.row.min_height = (float) (ctx.style.font.height);
			layout.row.min_height += (float) (ctx.style.text.padding.y*2);
			layout.row.min_height += (float) (ctx.style.window.min_row_height_padding*2);
		}

		public static float nk_layout_row_calculate_usable_space(nk_style style, int type, float total_space, int columns)
		{
			float panel_padding;
			float panel_spacing;
			float panel_space;
			nk_vec2 spacing = new nk_vec2();
			nk_vec2 padding = new nk_vec2();
			spacing = (nk_vec2) (style.window.spacing);
			padding = (nk_vec2) (nk_panel_get_padding(style, (int) (type)));
			panel_padding = (float) (2*padding.x);
			panel_spacing = (float) ((float) ((columns - 1) < (0) ? (0) : (columns - 1))*spacing.x);
			panel_space = (float) (total_space - panel_padding - panel_spacing);
			return (float) (panel_space);
		}

		public static void nk_panel_layout(nk_context ctx, nk_window win, float height, int cols)
		{
			nk_panel layout;
			nk_style style;
			nk_command_buffer _out_;
			nk_vec2 item_spacing = new nk_vec2();
			nk_color color = new nk_color();
			if (((ctx == null) || (ctx.current == null)) || (ctx.current.layout == null)) return;
			layout = win.layout;
			style = ctx.style;
			_out_ = win.buffer;
			color = (nk_color) (style.window.background);
			item_spacing = (nk_vec2) (style.window.spacing);
			layout.row.index = (int) (0);
			layout.at_y += (float) (layout.row.height);
			layout.row.columns = (int) (cols);
			if ((height) == (0.0f))
				layout.row.height =
					(float) (((height) < (layout.row.min_height) ? (layout.row.min_height) : (height)) + item_spacing.y);
			else layout.row.height = (float) (height + item_spacing.y);
			layout.row.item_offset = (float) (0);
			if ((layout.flags & NK_WINDOW_DYNAMIC) != 0)
			{
				nk_rect background = new nk_rect();
				background.x = (float) (win.bounds.x);
				background.w = (float) (win.bounds.w);
				background.y = (float) (layout.at_y - 1.0f);
				background.h = (float) (layout.row.height + 1.0f);
				nk_fill_rect(_out_, (nk_rect) (background), (float) (0), (nk_color) (color));
			}

		}

		public static void nk_row_layout_(nk_context ctx, int fmt, float height, int cols, int width)
		{
			nk_window win;
			if (((ctx == null) || (ctx.current == null)) || (ctx.current.layout == null)) return;
			win = ctx.current;
			nk_panel_layout(ctx, win, (float) (height), (int) (cols));
			if ((fmt) == (NK_DYNAMIC)) win.layout.row.type = (int) (NK_LAYOUT_DYNAMIC_FIXED);
			else win.layout.row.type = (int) (NK_LAYOUT_STATIC_FIXED);
			win.layout.row.ratio = null;
			win.layout.row.filled = (float) (0);
			win.layout.row.item_offset = (float) (0);
			win.layout.row.item_width = ((float) (width));
		}

		public static float nk_layout_ratio_from_pixel(nk_context ctx, float pixel_width)
		{
			nk_window win;
			if (((ctx == null) || (ctx.current == null)) || (ctx.current.layout == null)) return (float) (0);
			win = ctx.current;
			return
				(float)
					(((pixel_width/win.bounds.x) < (1.0f) ? (pixel_width/win.bounds.x) : (1.0f)) < (0.0f)
						? (0.0f)
						: ((pixel_width/win.bounds.x) < (1.0f) ? (pixel_width/win.bounds.x) : (1.0f)));
		}

		public static void nk_layout_row_dynamic(nk_context ctx, float height, int cols)
		{
			nk_row_layout_(ctx, (int) (NK_DYNAMIC), (float) (height), (int) (cols), (int) (0));
		}

		public static void nk_layout_row_static(nk_context ctx, float height, int item_width, int cols)
		{
			nk_row_layout_(ctx, (int) (NK_STATIC), (float) (height), (int) (cols), (int) (item_width));
		}

		public static void nk_layout_row_begin(nk_context ctx, int fmt, float row_height, int cols)
		{
			nk_window win;
			nk_panel layout;
			if (((ctx == null) || (ctx.current == null)) || (ctx.current.layout == null)) return;
			win = ctx.current;
			layout = win.layout;
			nk_panel_layout(ctx, win, (float) (row_height), (int) (cols));
			if ((fmt) == (NK_DYNAMIC)) layout.row.type = (int) (NK_LAYOUT_DYNAMIC_ROW);
			else layout.row.type = (int) (NK_LAYOUT_STATIC_ROW);
			layout.row.ratio = null;
			layout.row.filled = (float) (0);
			layout.row.item_width = (float) (0);
			layout.row.item_offset = (float) (0);
			layout.row.columns = (int) (cols);
		}

		public static void nk_layout_row_push(nk_context ctx, float ratio_or_width)
		{
			nk_window win;
			nk_panel layout;
			if (((ctx == null) || (ctx.current == null)) || (ctx.current.layout == null)) return;
			win = ctx.current;
			layout = win.layout;
			if ((layout.row.type != NK_LAYOUT_STATIC_ROW) && (layout.row.type != NK_LAYOUT_DYNAMIC_ROW)) return;
			if ((layout.row.type) == (NK_LAYOUT_DYNAMIC_ROW))
			{
				float ratio = (float) (ratio_or_width);
				if ((ratio + layout.row.filled) > (1.0f)) return;
				if ((ratio) > (0.0f))
					layout.row.item_width =
						(float) ((0) < ((1.0f) < (ratio) ? (1.0f) : (ratio)) ? ((1.0f) < (ratio) ? (1.0f) : (ratio)) : (0));
				else layout.row.item_width = (float) (1.0f - layout.row.filled);
			}
			else layout.row.item_width = (float) (ratio_or_width);
		}

		public static void nk_layout_row_end(nk_context ctx)
		{
			nk_window win;
			nk_panel layout;
			if (((ctx == null) || (ctx.current == null)) || (ctx.current.layout == null)) return;
			win = ctx.current;
			layout = win.layout;
			if ((layout.row.type != NK_LAYOUT_STATIC_ROW) && (layout.row.type != NK_LAYOUT_DYNAMIC_ROW)) return;
			layout.row.item_width = (float) (0);
			layout.row.item_offset = (float) (0);
		}

		public static void nk_layout_row(nk_context ctx, int fmt, float height, int cols, float* ratio)
		{
			int i;
			int n_undef = (int) (0);
			nk_window win;
			nk_panel layout;
			if (((ctx == null) || (ctx.current == null)) || (ctx.current.layout == null)) return;
			win = ctx.current;
			layout = win.layout;
			nk_panel_layout(ctx, win, (float) (height), (int) (cols));
			if ((fmt) == (NK_DYNAMIC))
			{
				float r = (float) (0);
				layout.row.ratio = ratio;
				for (i = (int) (0); (i) < (cols); ++i)
				{
					if ((ratio[i]) < (0.0f)) n_undef++;
					else r += (float) (ratio[i]);
				}
				r = (float) ((0) < ((1.0f) < (1.0f - r) ? (1.0f) : (1.0f - r)) ? ((1.0f) < (1.0f - r) ? (1.0f) : (1.0f - r)) : (0));
				layout.row.type = (int) (NK_LAYOUT_DYNAMIC);
				layout.row.item_width = (float) ((((r) > (0)) && ((n_undef) > (0))) ? (r/(float) (n_undef)) : 0);
			}
			else
			{
				layout.row.ratio = ratio;
				layout.row.type = (int) (NK_LAYOUT_STATIC);
				layout.row.item_width = (float) (0);
				layout.row.item_offset = (float) (0);
			}

			layout.row.item_offset = (float) (0);
			layout.row.filled = (float) (0);
		}

		public static void nk_layout_row_template_begin(nk_context ctx, float height)
		{
			nk_window win;
			nk_panel layout;
			if (((ctx == null) || (ctx.current == null)) || (ctx.current.layout == null)) return;
			win = ctx.current;
			layout = win.layout;
			nk_panel_layout(ctx, win, (float) (height), (int) (1));
			layout.row.type = (int) (NK_LAYOUT_TEMPLATE);
			layout.row.columns = (int) (0);
			layout.row.ratio = null;
			layout.row.item_width = (float) (0);
			layout.row.item_height = (float) (0);
			layout.row.item_offset = (float) (0);
			layout.row.filled = (float) (0);
			layout.row.item.x = (float) (0);
			layout.row.item.y = (float) (0);
			layout.row.item.w = (float) (0);
			layout.row.item.h = (float) (0);
		}

		public static void nk_layout_row_template_push_dynamic(nk_context ctx)
		{
			nk_window win;
			nk_panel layout;
			if (((ctx == null) || (ctx.current == null)) || (ctx.current.layout == null)) return;
			win = ctx.current;
			layout = win.layout;
			if (layout.row.type != NK_LAYOUT_TEMPLATE) return;
			if ((layout.row.columns) >= (16)) return;
			layout.row.templates[layout.row.columns++] = (float) (-1.0f);
		}

		public static void nk_layout_row_template_push_variable(nk_context ctx, float min_width)
		{
			nk_window win;
			nk_panel layout;
			if (((ctx == null) || (ctx.current == null)) || (ctx.current.layout == null)) return;
			win = ctx.current;
			layout = win.layout;
			if (layout.row.type != NK_LAYOUT_TEMPLATE) return;
			if ((layout.row.columns) >= (16)) return;
			layout.row.templates[layout.row.columns++] = (float) (-min_width);
		}

		public static void nk_layout_row_template_push_static(nk_context ctx, float width)
		{
			nk_window win;
			nk_panel layout;
			if (((ctx == null) || (ctx.current == null)) || (ctx.current.layout == null)) return;
			win = ctx.current;
			layout = win.layout;
			if (layout.row.type != NK_LAYOUT_TEMPLATE) return;
			if ((layout.row.columns) >= (16)) return;
			layout.row.templates[layout.row.columns++] = (float) (width);
		}

		public static void nk_layout_row_template_end(nk_context ctx)
		{
			nk_window win;
			nk_panel layout;
			int i = (int) (0);
			int variable_count = (int) (0);
			int min_variable_count = (int) (0);
			float min_fixed_width = (float) (0.0f);
			float total_fixed_width = (float) (0.0f);
			float max_variable_width = (float) (0.0f);
			if (((ctx == null) || (ctx.current == null)) || (ctx.current.layout == null)) return;
			win = ctx.current;
			layout = win.layout;
			if (layout.row.type != NK_LAYOUT_TEMPLATE) return;
			for (i = (int) (0); (i) < (layout.row.columns); ++i)
			{
				float width = (float) (layout.row.templates[i]);
				if ((width) >= (0.0f))
				{
					total_fixed_width += (float) (width);
					min_fixed_width += (float) (width);
				}
				else if ((width) < (-1.0f))
				{
					width = (float) (-width);
					total_fixed_width += (float) (width);
					max_variable_width = (float) ((max_variable_width) < (width) ? (width) : (max_variable_width));
					variable_count++;
				}
				else
				{
					min_variable_count++;
					variable_count++;
				}
			}
			if ((variable_count) != 0)
			{
				float space =
					(float)
						(nk_layout_row_calculate_usable_space(ctx.style, (int) (layout.type), (float) (layout.bounds.w),
							(int) (layout.row.columns)));
				float var_width =
					(float) (((space - min_fixed_width) < (0.0f) ? (0.0f) : (space - min_fixed_width))/(float) (variable_count));
				int enough_space = (int) ((var_width) >= (max_variable_width) ? 1 : 0);
				if (enough_space == 0)
					var_width =
						(float) (((space - total_fixed_width) < (0) ? (0) : (space - total_fixed_width))/(float) (min_variable_count));
				for (i = (int) (0); (i) < (layout.row.columns); ++i)
				{
					float* width = (float*) layout.row.templates + i;
					*width =
						(float) (((*width) >= (0.0f)) ? *width : (((*width) < (-1.0f)) && (enough_space == 0)) ? -(*width) : var_width);
				}
			}

		}

		public static void nk_layout_space_begin(nk_context ctx, int fmt, float height, int widget_count)
		{
			nk_window win;
			nk_panel layout;
			if (((ctx == null) || (ctx.current == null)) || (ctx.current.layout == null)) return;
			win = ctx.current;
			layout = win.layout;
			nk_panel_layout(ctx, win, (float) (height), (int) (widget_count));
			if ((fmt) == (NK_STATIC)) layout.row.type = (int) (NK_LAYOUT_STATIC_FREE);
			else layout.row.type = (int) (NK_LAYOUT_DYNAMIC_FREE);
			layout.row.ratio = null;
			layout.row.filled = (float) (0);
			layout.row.item_width = (float) (0);
			layout.row.item_offset = (float) (0);
		}

		public static void nk_layout_space_end(nk_context ctx)
		{
			nk_window win;
			nk_panel layout;
			if (((ctx == null) || (ctx.current == null)) || (ctx.current.layout == null)) return;
			win = ctx.current;
			layout = win.layout;
			layout.row.item_width = (float) (0);
			layout.row.item_height = (float) (0);
			layout.row.item_offset = (float) (0);
			fixed (void* ptr = &layout.row.item)
			{
				nk_zero(ptr, (ulong) (sizeof (nk_rect)));
			}
		}

		public static void nk_layout_space_push(nk_context ctx, nk_rect rect)
		{
			nk_window win;
			nk_panel layout;
			if (((ctx == null) || (ctx.current == null)) || (ctx.current.layout == null)) return;
			win = ctx.current;
			layout = win.layout;
			layout.row.item = (nk_rect) (rect);
		}

		public static nk_rect nk_layout_space_bounds(nk_context ctx)
		{
			nk_rect ret = new nk_rect();
			nk_window win;
			nk_panel layout;
			win = ctx.current;
			layout = win.layout;
			ret.x = (float) (layout.clip.x);
			ret.y = (float) (layout.clip.y);
			ret.w = (float) (layout.clip.w);
			ret.h = (float) (layout.row.height);
			return (nk_rect) (ret);
		}

		public static nk_rect nk_layout_widget_bounds(nk_context ctx)
		{
			nk_rect ret = new nk_rect();
			nk_window win;
			nk_panel layout;
			win = ctx.current;
			layout = win.layout;
			ret.x = (float) (layout.at_x);
			ret.y = (float) (layout.at_y);
			ret.w = (float) (layout.bounds.w - ((layout.at_x - layout.bounds.x) < (0) ? (0) : (layout.at_x - layout.bounds.x)));
			ret.h = (float) (layout.row.height);
			return (nk_rect) (ret);
		}

		public static nk_vec2 nk_layout_space_to_screen(nk_context ctx, nk_vec2 ret)
		{
			nk_window win;
			nk_panel layout;
			win = ctx.current;
			layout = win.layout;
			ret.x += (float) (layout.at_x - (float) (layout.offset.x));
			ret.y += (float) (layout.at_y - (float) (layout.offset.y));
			return (nk_vec2) (ret);
		}

		public static nk_vec2 nk_layout_space_to_local(nk_context ctx, nk_vec2 ret)
		{
			nk_window win;
			nk_panel layout;
			win = ctx.current;
			layout = win.layout;
			ret.x += (float) (-layout.at_x + (float) (layout.offset.x));
			ret.y += (float) (-layout.at_y + (float) (layout.offset.y));
			return (nk_vec2) (ret);
		}

		public static nk_rect nk_layout_space_rect_to_screen(nk_context ctx, nk_rect ret)
		{
			nk_window win;
			nk_panel layout;
			win = ctx.current;
			layout = win.layout;
			ret.x += (float) (layout.at_x - (float) (layout.offset.x));
			ret.y += (float) (layout.at_y - (float) (layout.offset.y));
			return (nk_rect) (ret);
		}

		public static nk_rect nk_layout_space_rect_to_local(nk_context ctx, nk_rect ret)
		{
			nk_window win;
			nk_panel layout;
			win = ctx.current;
			layout = win.layout;
			ret.x += (float) (-layout.at_x + (float) (layout.offset.x));
			ret.y += (float) (-layout.at_y + (float) (layout.offset.y));
			return (nk_rect) (ret);
		}

		public static void nk_panel_alloc_row(nk_context ctx, nk_window win)
		{
			nk_panel layout = win.layout;
			nk_vec2 spacing = (nk_vec2) (ctx.style.window.spacing);
			float row_height = (float) (layout.row.height - spacing.y);
			nk_panel_layout(ctx, win, (float) (row_height), (int) (layout.row.columns));
		}

		public static void nk_layout_widget_space(nk_rect* bounds, nk_context ctx, nk_window win, int modify)
		{
			nk_panel layout;
			nk_style style;
			nk_vec2 spacing = new nk_vec2();
			nk_vec2 padding = new nk_vec2();
			float item_offset = (float) (0);
			float item_width = (float) (0);
			float item_spacing = (float) (0);
			float panel_space = (float) (0);
			if (((ctx == null) || (ctx.current == null)) || (ctx.current.layout == null)) return;
			win = ctx.current;
			layout = win.layout;
			style = ctx.style;
			spacing = (nk_vec2) (style.window.spacing);
			padding = (nk_vec2) (nk_panel_get_padding(style, (int) (layout.type)));
			panel_space =
				(float)
					(nk_layout_row_calculate_usable_space(ctx.style, (int) (layout.type), (float) (layout.bounds.w),
						(int) (layout.row.columns)));
			switch (layout.row.type)
			{
				case NK_LAYOUT_DYNAMIC_FIXED:
				{
					item_width = (float) (((1.0f) < (panel_space - 1.0f) ? (panel_space - 1.0f) : (1.0f))/(float) (layout.row.columns));
					item_offset = (float) ((float) (layout.row.index)*item_width);
					item_spacing = (float) ((float) (layout.row.index)*spacing.x);
				}
					break;
				case NK_LAYOUT_DYNAMIC_ROW:
				{
					item_width = (float) (layout.row.item_width*panel_space);
					item_offset = (float) (layout.row.item_offset);
					item_spacing = (float) (0);
					if ((modify) != 0)
					{
						layout.row.item_offset += (float) (item_width + spacing.x);
						layout.row.filled += (float) (layout.row.item_width);
						layout.row.index = (int) (0);
					}
				}
					break;
				case NK_LAYOUT_DYNAMIC_FREE:
				{
					bounds->x = (float) (layout.at_x + (layout.bounds.w*layout.row.item.x));
					bounds->x -= ((float) (layout.offset.x));
					bounds->y = (float) (layout.at_y + (layout.row.height*layout.row.item.y));
					bounds->y -= ((float) (layout.offset.y));
					bounds->w = (float) (layout.bounds.w*layout.row.item.w);
					bounds->h = (float) (layout.row.height*layout.row.item.h);
					return;
				}
					break;
				case NK_LAYOUT_DYNAMIC:
				{
					float ratio;
					ratio =
						(float)
							(((layout.row.ratio[layout.row.index]) < (0)) ? layout.row.item_width : layout.row.ratio[layout.row.index]);
					item_spacing = (float) ((float) (layout.row.index)*spacing.x);
					item_width = (float) (ratio*panel_space);
					item_offset = (float) (layout.row.item_offset);
					if ((modify) != 0)
					{
						layout.row.item_offset += (float) (item_width);
						layout.row.filled += (float) (ratio);
					}
				}
					break;
				case NK_LAYOUT_STATIC_FIXED:
				{
					item_width = (float) (layout.row.item_width);
					item_offset = (float) ((float) (layout.row.index)*item_width);
					item_spacing = (float) ((float) (layout.row.index)*spacing.x);
				}
					break;
				case NK_LAYOUT_STATIC_ROW:
				{
					item_width = (float) (layout.row.item_width);
					item_offset = (float) (layout.row.item_offset);
					item_spacing = (float) ((float) (layout.row.index)*spacing.x);
					if ((modify) != 0) layout.row.item_offset += (float) (item_width);
				}
					break;
				case NK_LAYOUT_STATIC_FREE:
				{
					bounds->x = (float) (layout.at_x + layout.row.item.x);
					bounds->w = (float) (layout.row.item.w);
					if (((bounds->x + bounds->w) > (layout.max_x)) && ((modify) != 0)) layout.max_x = (float) (bounds->x + bounds->w);
					bounds->x -= ((float) (layout.offset.x));
					bounds->y = (float) (layout.at_y + layout.row.item.y);
					bounds->y -= ((float) (layout.offset.y));
					bounds->h = (float) (layout.row.item.h);
					return;
				}
					break;
				case NK_LAYOUT_STATIC:
				{
					item_spacing = (float) ((float) (layout.row.index)*spacing.x);
					item_width = (float) (layout.row.ratio[layout.row.index]);
					item_offset = (float) (layout.row.item_offset);
					if ((modify) != 0) layout.row.item_offset += (float) (item_width);
				}
					break;
				case NK_LAYOUT_TEMPLATE:
				{
					item_width = (float) (layout.row.templates[layout.row.index]);
					item_offset = (float) (layout.row.item_offset);
					item_spacing = (float) ((float) (layout.row.index)*spacing.x);
					if ((modify) != 0) layout.row.item_offset += (float) (item_width);
				}
					break;
				default:
					;
					break;
			}

			bounds->w = (float) (item_width);
			bounds->h = (float) (layout.row.height - spacing.y);
			bounds->y = (float) (layout.at_y - (float) (layout.offset.y));
			bounds->x = (float) (layout.at_x + item_offset + item_spacing + padding.x);
			if (((bounds->x + bounds->w) > (layout.max_x)) && ((modify) != 0)) layout.max_x = (float) (bounds->x + bounds->w);
			bounds->x -= ((float) (layout.offset.x));
		}

		public static void nk_panel_alloc_space(nk_rect* bounds, nk_context ctx)
		{
			nk_window win;
			nk_panel layout;
			if (((ctx == null) || (ctx.current == null)) || (ctx.current.layout == null)) return;
			win = ctx.current;
			layout = win.layout;
			if ((layout.row.index) >= (layout.row.columns)) nk_panel_alloc_row(ctx, win);
			nk_layout_widget_space(bounds, ctx, win, (int) (nk_true));
			layout.row.index++;
		}

		public static void nk_layout_peek(nk_rect* bounds, nk_context ctx)
		{
			float y;
			int index;
			nk_window win;
			nk_panel layout;
			if (((ctx == null) || (ctx.current == null)) || (ctx.current.layout == null)) return;
			win = ctx.current;
			layout = win.layout;
			y = (float) (layout.at_y);
			index = (int) (layout.row.index);
			if ((layout.row.index) >= (layout.row.columns))
			{
				layout.at_y += (float) (layout.row.height);
				layout.row.index = (int) (0);
			}

			nk_layout_widget_space(bounds, ctx, win, (int) (nk_false));
			if (layout.row.index == 0)
			{
				bounds->x -= (float) (layout.row.item_offset);
			}

			layout.at_y = (float) (y);
			layout.row.index = (int) (index);
		}

		public static int nk_tree_state_base(nk_context ctx, int type, nk_image img, char* title, ref int state)
		{
			nk_window win;
			nk_panel layout;
			nk_style style;
			nk_command_buffer _out_;
			nk_input _in_;
			nk_style_button button;
			int symbol;
			float row_height;
			nk_vec2 item_spacing = new nk_vec2();
			nk_rect header = new nk_rect();
			nk_rect sym = new nk_rect();
			nk_text text = new nk_text();
			uint ws = (uint) (0);
			int widget_state;
			if (((ctx == null) || (ctx.current == null)) || (ctx.current.layout == null)) return (int) (0);
			win = ctx.current;
			layout = win.layout;
			_out_ = win.buffer;
			style = ctx.style;
			item_spacing = (nk_vec2) (style.window.spacing);
			row_height = (float) (style.font.height + 2*style.tab.padding.y);
			nk_layout_set_min_row_height(ctx, (float) (row_height));
			nk_layout_row_dynamic(ctx, (float) (row_height), (int) (1));
			nk_layout_reset_min_row_height(ctx);
			widget_state = (int) (nk_widget(&header, ctx));
			if ((type) == (NK_TREE_TAB))
			{
				nk_style_item background = style.tab.background;
				if ((background.type) == (NK_STYLE_ITEM_IMAGE))
				{
					nk_draw_image(_out_, (nk_rect) (header), background.data.image, (nk_color) (nk_white));
					text.background = (nk_color) (nk_rgba((int) (0), (int) (0), (int) (0), (int) (0)));
				}
				else
				{
					text.background = (nk_color) (background.data.color);
					nk_fill_rect(_out_, (nk_rect) (header), (float) (0), (nk_color) (style.tab.border_color));
					nk_fill_rect(_out_, (nk_rect) (nk_shrink_rect_((nk_rect) (header), (float) (style.tab.border))),
						(float) (style.tab.rounding), (nk_color) (background.data.color));
				}
			}
			else text.background = (nk_color) (style.window.background);
			_in_ = ((layout.flags & NK_WINDOW_ROM) == 0) ? ctx.input : null;
			_in_ = (((_in_) != null) && ((widget_state) == (NK_WIDGET_VALID))) ? ctx.input : null;
			if ((nk_button_behavior(ref ws, (nk_rect) (header), _in_, (int) (NK_BUTTON_DEFAULT))) != 0)
				state = (int) (((state) == (NK_MAXIMIZED)) ? NK_MINIMIZED : NK_MAXIMIZED);
			if ((state) == (NK_MAXIMIZED))
			{
				symbol = (int) (style.tab.sym_maximize);
				if ((type) == (NK_TREE_TAB)) button = style.tab.tab_maximize_button;
				else button = style.tab.node_maximize_button;
			}
			else
			{
				symbol = (int) (style.tab.sym_minimize);
				if ((type) == (NK_TREE_TAB)) button = style.tab.tab_minimize_button;
				else button = style.tab.node_minimize_button;
			}

			{
				sym.w = (float) (sym.h = (float) (style.font.height));
				sym.y = (float) (header.y + style.tab.padding.y);
				sym.x = (float) (header.x + style.tab.padding.x);
				nk_do_button_symbol(ref ws, win.buffer, (nk_rect) (sym), (int) (symbol), (int) (NK_BUTTON_DEFAULT), button, null,
					style.font);
				if ((img) != null)
				{
					sym.x = (float) (sym.x + sym.w + 4*item_spacing.x);
					nk_draw_image(win.buffer, (nk_rect) (sym), img, (nk_color) (nk_white));
					sym.w = (float) (style.font.height + style.tab.spacing.x);
				}
			}

			{
				nk_rect label = new nk_rect();
				header.w = (float) ((header.w) < (sym.w + item_spacing.x) ? (sym.w + item_spacing.x) : (header.w));
				label.x = (float) (sym.x + sym.w + item_spacing.x);
				label.y = (float) (sym.y);
				label.w = (float) (header.w - (sym.w + item_spacing.y + style.tab.indent));
				label.h = (float) (style.font.height);
				text.text = (nk_color) (style.tab.text);
				text.padding = (nk_vec2) (nk_vec2_((float) (0), (float) (0)));
				nk_widget_text(_out_, (nk_rect) (label), title, (int) (nk_strlen(title)), &text, (uint) (NK_TEXT_LEFT), style.font);
			}

			if ((state) == (NK_MAXIMIZED))
			{
				layout.at_x = (float) (header.x + (float) (layout.offset.x) + style.tab.indent);
				layout.bounds.w = (float) ((layout.bounds.w) < (style.tab.indent) ? (style.tab.indent) : (layout.bounds.w));
				layout.bounds.w -= (float) (style.tab.indent + style.window.padding.x);
				layout.row.tree_depth++;
				return (int) (nk_true);
			}
			else return (int) (nk_false);
		}

		public static int nk_tree_base(nk_context ctx, int type, nk_image img, char* title, int initial_state, sbyte* hash,
			int len, int line)
		{
			nk_window win = ctx.current;
			int title_len = (int) (0);
			uint tree_hash = (uint) (0);
			uint* state = null;
			if (hash == null)
			{
				title_len = (int) (nk_strlen(title));
				tree_hash = (uint) (nk_murmur_hash(title, (int) (title_len), (uint) (line)));
			}
			else tree_hash = (uint) (nk_murmur_hash(hash, (int) (len), (uint) (line)));
			state = nk_find_value(win, (uint) (tree_hash));
			if (state == null)
			{
				state = nk_add_value(ctx, win, (uint) (tree_hash), (uint) (0));
				*state = (uint) (initial_state);
			}

			int kkk = (int) (*state);
			int result = (int) (nk_tree_state_base(ctx, (int) (type), img, title, ref kkk));
			*state = (uint) kkk;
			return result;
		}

		public static int nk_tree_state_push(nk_context ctx, int type, char* title, ref int state)
		{
			return (int) (nk_tree_state_base(ctx, (int) (type), null, title, ref state));
		}

		public static int nk_tree_state_image_push(nk_context ctx, int type, nk_image img, char* title, ref int state)
		{
			return (int) (nk_tree_state_base(ctx, (int) (type), img, title, ref state));
		}

		public static void nk_tree_state_pop(nk_context ctx)
		{
			nk_window win = null;
			nk_panel layout = null;
			if (((ctx == null) || (ctx.current == null)) || (ctx.current.layout == null)) return;
			win = ctx.current;
			layout = win.layout;
			layout.at_x -= (float) (ctx.style.tab.indent + ctx.style.window.padding.x);
			layout.bounds.w += (float) (ctx.style.tab.indent + ctx.style.window.padding.x);
			layout.row.tree_depth--;
		}

		public static int nk_tree_push_hashed(nk_context ctx, int type, char* title, int initial_state, sbyte* hash, int len,
			int line)
		{
			return (int) (nk_tree_base(ctx, (int) (type), null, title, (int) (initial_state), hash, (int) (len), (int) (line)));
		}

		public static int nk_tree_image_push_hashed(nk_context ctx, int type, nk_image img, char* title, int initial_state,
			sbyte* hash, int len, int seed)
		{
			return (int) (nk_tree_base(ctx, (int) (type), img, title, (int) (initial_state), hash, (int) (len), (int) (seed)));
		}

		public static void nk_tree_pop(nk_context ctx)
		{
			nk_tree_state_pop(ctx);
		}

		public static nk_rect nk_widget_bounds(nk_context ctx)
		{
			nk_rect bounds = new nk_rect();
			if ((ctx == null) || (ctx.current == null))
				return (nk_rect) (nk_rect_((float) (0), (float) (0), (float) (0), (float) (0)));
			nk_layout_peek(&bounds, ctx);
			return (nk_rect) (bounds);
		}

		public static nk_vec2 nk_widget_position(nk_context ctx)
		{
			nk_rect bounds = new nk_rect();
			if ((ctx == null) || (ctx.current == null)) return (nk_vec2) (nk_vec2_((float) (0), (float) (0)));
			nk_layout_peek(&bounds, ctx);
			return (nk_vec2) (nk_vec2_((float) (bounds.x), (float) (bounds.y)));
		}

		public static nk_vec2 nk_widget_size(nk_context ctx)
		{
			nk_rect bounds = new nk_rect();
			if ((ctx == null) || (ctx.current == null)) return (nk_vec2) (nk_vec2_((float) (0), (float) (0)));
			nk_layout_peek(&bounds, ctx);
			return (nk_vec2) (nk_vec2_((float) (bounds.w), (float) (bounds.h)));
		}

		public static float nk_widget_width(nk_context ctx)
		{
			nk_rect bounds = new nk_rect();
			if ((ctx == null) || (ctx.current == null)) return (float) (0);
			nk_layout_peek(&bounds, ctx);
			return (float) (bounds.w);
		}

		public static float nk_widget_height(nk_context ctx)
		{
			nk_rect bounds = new nk_rect();
			if ((ctx == null) || (ctx.current == null)) return (float) (0);
			nk_layout_peek(&bounds, ctx);
			return (float) (bounds.h);
		}

		public static int nk_widget_is_hovered(nk_context ctx)
		{
			nk_rect c = new nk_rect();
			nk_rect v = new nk_rect();
			nk_rect bounds = new nk_rect();
			if (((ctx == null) || (ctx.current == null)) || (ctx.active != ctx.current)) return (int) (0);
			c = (nk_rect) (ctx.current.layout.clip);
			c.x = ((float) ((int) (c.x)));
			c.y = ((float) ((int) (c.y)));
			c.w = ((float) ((int) (c.w)));
			c.h = ((float) ((int) (c.h)));
			nk_layout_peek(&bounds, ctx);
			nk_unify(ref v, ref c, (float) (bounds.x), (float) (bounds.y), (float) (bounds.x + bounds.w),
				(float) (bounds.y + bounds.h));
			if (
				!(!(((((bounds.x) > (c.x + c.w)) || ((bounds.x + bounds.w) < (c.x))) || ((bounds.y) > (c.y + c.h))) ||
				    ((bounds.y + bounds.h) < (c.y))))) return (int) (0);
			return (int) (nk_input_is_mouse_hovering_rect(ctx.input, (nk_rect) (bounds)));
		}

		public static int nk_widget_is_mouse_clicked(nk_context ctx, int btn)
		{
			nk_rect c = new nk_rect();
			nk_rect v = new nk_rect();
			nk_rect bounds = new nk_rect();
			if (((ctx == null) || (ctx.current == null)) || (ctx.active != ctx.current)) return (int) (0);
			c = (nk_rect) (ctx.current.layout.clip);
			c.x = ((float) ((int) (c.x)));
			c.y = ((float) ((int) (c.y)));
			c.w = ((float) ((int) (c.w)));
			c.h = ((float) ((int) (c.h)));
			nk_layout_peek(&bounds, ctx);
			nk_unify(ref v, ref c, (float) (bounds.x), (float) (bounds.y), (float) (bounds.x + bounds.w),
				(float) (bounds.y + bounds.h));
			if (
				!(!(((((bounds.x) > (c.x + c.w)) || ((bounds.x + bounds.w) < (c.x))) || ((bounds.y) > (c.y + c.h))) ||
				    ((bounds.y + bounds.h) < (c.y))))) return (int) (0);
			return (int) (nk_input_mouse_clicked(ctx.input, (int) (btn), (nk_rect) (bounds)));
		}

		public static int nk_widget_has_mouse_click_down(nk_context ctx, int btn, int down)
		{
			nk_rect c = new nk_rect();
			nk_rect v = new nk_rect();
			nk_rect bounds = new nk_rect();
			if (((ctx == null) || (ctx.current == null)) || (ctx.active != ctx.current)) return (int) (0);
			c = (nk_rect) (ctx.current.layout.clip);
			c.x = ((float) ((int) (c.x)));
			c.y = ((float) ((int) (c.y)));
			c.w = ((float) ((int) (c.w)));
			c.h = ((float) ((int) (c.h)));
			nk_layout_peek(&bounds, ctx);
			nk_unify(ref v, ref c, (float) (bounds.x), (float) (bounds.y), (float) (bounds.x + bounds.w),
				(float) (bounds.y + bounds.h));
			if (
				!(!(((((bounds.x) > (c.x + c.w)) || ((bounds.x + bounds.w) < (c.x))) || ((bounds.y) > (c.y + c.h))) ||
				    ((bounds.y + bounds.h) < (c.y))))) return (int) (0);
			return (int) (nk_input_has_mouse_click_down_in_rect(ctx.input, (int) (btn), (nk_rect) (bounds), (int) (down)));
		}

		public static int nk_widget(nk_rect* bounds, nk_context ctx)
		{
			nk_rect c = new nk_rect();
			nk_rect v = new nk_rect();
			nk_window win;
			nk_panel layout;
			nk_input _in_;
			if (((ctx == null) || (ctx.current == null)) || (ctx.current.layout == null)) return (int) (NK_WIDGET_INVALID);
			nk_panel_alloc_space(bounds, ctx);
			win = ctx.current;
			layout = win.layout;
			_in_ = ctx.input;
			c = (nk_rect) (layout.clip);
			bounds->x = ((float) ((int) (bounds->x)));
			bounds->y = ((float) ((int) (bounds->y)));
			bounds->w = ((float) ((int) (bounds->w)));
			bounds->h = ((float) ((int) (bounds->h)));
			c.x = ((float) ((int) (c.x)));
			c.y = ((float) ((int) (c.y)));
			c.w = ((float) ((int) (c.w)));
			c.h = ((float) ((int) (c.h)));
			nk_unify(ref v, ref c, (float) (bounds->x), (float) (bounds->y), (float) (bounds->x + bounds->w),
				(float) (bounds->y + bounds->h));
			if (
				!(!(((((bounds->x) > (c.x + c.w)) || ((bounds->x + bounds->w) < (c.x))) || ((bounds->y) > (c.y + c.h))) ||
				    ((bounds->y + bounds->h) < (c.y))))) return (int) (NK_WIDGET_INVALID);
			if (
				!((((v.x) <= (_in_.mouse.pos.x)) && ((_in_.mouse.pos.x) < (v.x + v.w))) &&
				  (((v.y) <= (_in_.mouse.pos.y)) && ((_in_.mouse.pos.y) < (v.y + v.h))))) return (int) (NK_WIDGET_ROM);
			return (int) (NK_WIDGET_VALID);
		}

		public static int nk_widget_fitting(nk_rect* bounds, nk_context ctx, nk_vec2 item_padding)
		{
			nk_window win;
			nk_style style;
			nk_panel layout;
			int state;
			nk_vec2 panel_padding = new nk_vec2();
			if (((ctx == null) || (ctx.current == null)) || (ctx.current.layout == null)) return (int) (NK_WIDGET_INVALID);
			win = ctx.current;
			style = ctx.style;
			layout = win.layout;
			state = (int) (nk_widget(bounds, ctx));
			panel_padding = (nk_vec2) (nk_panel_get_padding(style, (int) (layout.type)));
			if ((layout.row.index) == (1))
			{
				bounds->w += (float) (panel_padding.x);
				bounds->x -= (float) (panel_padding.x);
			}
			else bounds->x -= (float) (item_padding.x);
			if ((layout.row.index) == (layout.row.columns)) bounds->w += (float) (panel_padding.x);
			else bounds->w += (float) (item_padding.x);
			return (int) (state);
		}

		public static void nk_spacing(nk_context ctx, int cols)
		{
			nk_window win;
			nk_panel layout;
			nk_rect none = new nk_rect();
			int i;
			int index;
			int rows;
			if (((ctx == null) || (ctx.current == null)) || (ctx.current.layout == null)) return;
			win = ctx.current;
			layout = win.layout;
			index = (int) ((layout.row.index + cols)%layout.row.columns);
			rows = (int) ((layout.row.index + cols)/layout.row.columns);
			if ((rows) != 0)
			{
				for (i = (int) (0); (i) < (rows); ++i)
				{
					nk_panel_alloc_row(ctx, win);
				}
				cols = (int) (index);
			}

			if ((layout.row.type != NK_LAYOUT_DYNAMIC_FIXED) && (layout.row.type != NK_LAYOUT_STATIC_FIXED))
			{
				for (i = (int) (0); (i) < (cols); ++i)
				{
					nk_panel_alloc_space(&none, ctx);
				}
			}

			layout.row.index = (int) (index);
		}

		public static void nk_text_colored(nk_context ctx, char* str, int len, uint alignment, nk_color color)
		{
			nk_window win;
			nk_style style;
			nk_vec2 item_padding = new nk_vec2();
			nk_rect bounds = new nk_rect();
			nk_text text = new nk_text();
			if (((ctx == null) || (ctx.current == null)) || (ctx.current.layout == null)) return;
			win = ctx.current;
			style = ctx.style;
			nk_panel_alloc_space(&bounds, ctx);
			item_padding = (nk_vec2) (style.text.padding);
			text.padding.x = (float) (item_padding.x);
			text.padding.y = (float) (item_padding.y);
			text.background = (nk_color) (style.window.background);
			text.text = (nk_color) (color);
			nk_widget_text(win.buffer, (nk_rect) (bounds), str, (int) (len), &text, (uint) (alignment), style.font);
		}

		public static void nk_text_wrap_colored(nk_context ctx, char* str, int len, nk_color color)
		{
			nk_window win;
			nk_style style;
			nk_vec2 item_padding = new nk_vec2();
			nk_rect bounds = new nk_rect();
			nk_text text = new nk_text();
			if (((ctx == null) || (ctx.current == null)) || (ctx.current.layout == null)) return;
			win = ctx.current;
			style = ctx.style;
			nk_panel_alloc_space(&bounds, ctx);
			item_padding = (nk_vec2) (style.text.padding);
			text.padding.x = (float) (item_padding.x);
			text.padding.y = (float) (item_padding.y);
			text.background = (nk_color) (style.window.background);
			text.text = (nk_color) (color);
			nk_widget_text_wrap(win.buffer, (nk_rect) (bounds), str, (int) (len), &text, style.font);
		}

		public static void nk_text_(nk_context ctx, char* str, int len, uint alignment)
		{
			if (ctx == null) return;
			nk_text_colored(ctx, str, (int) (len), (uint) (alignment), (nk_color) (ctx.style.text.color));
		}

		public static void nk_text_wrap(nk_context ctx, char* str, int len)
		{
			if (ctx == null) return;
			nk_text_wrap_colored(ctx, str, (int) (len), (nk_color) (ctx.style.text.color));
		}

		public static void nk_label(nk_context ctx, char* str, uint alignment)
		{
			nk_text_(ctx, str, (int) (nk_strlen(str)), (uint) (alignment));
		}

		public static void nk_label_colored(nk_context ctx, char* str, uint align, nk_color color)
		{
			nk_text_colored(ctx, str, (int) (nk_strlen(str)), (uint) (align), (nk_color) (color));
		}

		public static void nk_label_wrap(nk_context ctx, char* str)
		{
			nk_text_wrap(ctx, str, (int) (nk_strlen(str)));
		}

		public static void nk_label_colored_wrap(nk_context ctx, char* str, nk_color color)
		{
			nk_text_wrap_colored(ctx, str, (int) (nk_strlen(str)), (nk_color) (color));
		}

		public static void nk_image_(nk_context ctx, nk_image img)
		{
			nk_window win;
			nk_rect bounds = new nk_rect();
			if (((ctx == null) || (ctx.current == null)) || (ctx.current.layout == null)) return;
			win = ctx.current;
			if (nk_widget(&bounds, ctx) == 0) return;
			nk_draw_image(win.buffer, (nk_rect) (bounds), img, (nk_color) (nk_white));
		}

		public static void nk_button_set_behavior(nk_context ctx, int behavior)
		{
			if (ctx == null) return;
			ctx.button_behavior = (int) (behavior);
		}

		public static int nk_button_push_behavior(nk_context ctx, int behavior)
		{
			nk_config_stack_button_behavior button_stack;
			nk_config_stack_button_behavior_element* element;
			if (ctx == null) return (int) (0);
			button_stack = ctx.stacks.button_behaviors;
			if ((button_stack.head) >= ((int) ((int) button_stack.elements.Length))) return (int) (0);
			element = (nk_config_stack_button_behavior_element*) button_stack.elements + (button_stack.head++);
			;

			element->old_value = (int) (ctx.button_behavior);
			ctx.button_behavior = (int) (behavior);
			return (int) (1);
		}

		public static int nk_button_pop_behavior(nk_context ctx)
		{
			nk_config_stack_button_behavior button_stack;
			nk_config_stack_button_behavior_element* element;
			if (ctx == null) return (int) (0);
			button_stack = ctx.stacks.button_behaviors;
			if ((button_stack.head) < (1)) return (int) (0);
			element = (nk_config_stack_button_behavior_element*) button_stack.elements + (--button_stack.head);
			;
			ctx.button_behavior = element->old_value;
			return (int) (1);
		}

		public static int nk_button_text_styled(nk_context ctx, nk_style_button style, char* title, int len)
		{
			nk_window win;
			nk_panel layout;
			nk_input _in_;
			nk_rect bounds = new nk_rect();
			int state;
			if ((((style == null) || (ctx == null)) || (ctx.current == null)) || (ctx.current.layout == null)) return (int) (0);
			win = ctx.current;
			layout = win.layout;
			state = (int) (nk_widget(&bounds, ctx));
			if (state == 0) return (int) (0);
			_in_ = (((state) == (NK_WIDGET_ROM)) || ((layout.flags & NK_WINDOW_ROM) != 0)) ? null : ctx.input;
			return
				(int)
					(nk_do_button_text(ref ctx.last_widget_state, win.buffer, (nk_rect) (bounds), title, (int) (len),
						(uint) (style.text_alignment), (int) (ctx.button_behavior), style, _in_, ctx.style.font));
		}

		public static int nk_button_text(nk_context ctx, char* title, int len)
		{
			if (ctx == null) return (int) (0);
			return (int) (nk_button_text_styled(ctx, ctx.style.button, title, (int) (len)));
		}

		public static int nk_button_label_styled(nk_context ctx, nk_style_button style, char* title)
		{
			return (int) (nk_button_text_styled(ctx, style, title, (int) (nk_strlen(title))));
		}

		public static int nk_button_label(nk_context ctx, char* title)
		{
			return (int) (nk_button_text(ctx, title, (int) (nk_strlen(title))));
		}

		public static int nk_button_color(nk_context ctx, nk_color color)
		{
			nk_window win;
			nk_panel layout;
			nk_input _in_;
			nk_style_button button = new nk_style_button();
			int ret = (int) (0);
			nk_rect bounds = new nk_rect();
			nk_rect content = new nk_rect();
			int state;
			if (((ctx == null) || (ctx.current == null)) || (ctx.current.layout == null)) return (int) (0);
			win = ctx.current;
			layout = win.layout;
			state = (int) (nk_widget(&bounds, ctx));
			if (state == 0) return (int) (0);
			_in_ = (((state) == (NK_WIDGET_ROM)) || ((layout.flags & NK_WINDOW_ROM) != 0)) ? null : ctx.input;
			button = (nk_style_button) (ctx.style.button);
			button.normal = (nk_style_item) (nk_style_item_color((nk_color) (color)));
			button.hover = (nk_style_item) (nk_style_item_color((nk_color) (color)));
			button.active = (nk_style_item) (nk_style_item_color((nk_color) (color)));
			ret =
				(int)
					(nk_do_button(ref ctx.last_widget_state, win.buffer, (nk_rect) (bounds), button, _in_, (int) (ctx.button_behavior),
						&content));
			nk_draw_button(win.buffer, &bounds, (uint) (ctx.last_widget_state), button);
			return (int) (ret);
		}

		public static int nk_button_symbol_styled(nk_context ctx, nk_style_button style, int symbol)
		{
			nk_window win;
			nk_panel layout;
			nk_input _in_;
			nk_rect bounds = new nk_rect();
			int state;
			if (((ctx == null) || (ctx.current == null)) || (ctx.current.layout == null)) return (int) (0);
			win = ctx.current;
			layout = win.layout;
			state = (int) (nk_widget(&bounds, ctx));
			if (state == 0) return (int) (0);
			_in_ = (((state) == (NK_WIDGET_ROM)) || ((layout.flags & NK_WINDOW_ROM) != 0)) ? null : ctx.input;
			return
				(int)
					(nk_do_button_symbol(ref ctx.last_widget_state, win.buffer, (nk_rect) (bounds), (int) (symbol),
						(int) (ctx.button_behavior), style, _in_, ctx.style.font));
		}

		public static int nk_button_symbol(nk_context ctx, int symbol)
		{
			if (ctx == null) return (int) (0);
			return (int) (nk_button_symbol_styled(ctx, ctx.style.button, (int) (symbol)));
		}

		public static int nk_button_image_styled(nk_context ctx, nk_style_button style, nk_image img)
		{
			nk_window win;
			nk_panel layout;
			nk_input _in_;
			nk_rect bounds = new nk_rect();
			int state;
			if (((ctx == null) || (ctx.current == null)) || (ctx.current.layout == null)) return (int) (0);
			win = ctx.current;
			layout = win.layout;
			state = (int) (nk_widget(&bounds, ctx));
			if (state == 0) return (int) (0);
			_in_ = (((state) == (NK_WIDGET_ROM)) || ((layout.flags & NK_WINDOW_ROM) != 0)) ? null : ctx.input;
			return
				(int)
					(nk_do_button_image(ref ctx.last_widget_state, win.buffer, (nk_rect) (bounds), (nk_image) (img),
						(int) (ctx.button_behavior), style, _in_));
		}

		public static int nk_button_image(nk_context ctx, nk_image img)
		{
			if (ctx == null) return (int) (0);
			return (int) (nk_button_image_styled(ctx, ctx.style.button, (nk_image) (img)));
		}

		public static int nk_button_symbol_text_styled(nk_context ctx, nk_style_button style, int symbol, char* text, int len,
			uint align)
		{
			nk_window win;
			nk_panel layout;
			nk_input _in_;
			nk_rect bounds = new nk_rect();
			int state;
			if (((ctx == null) || (ctx.current == null)) || (ctx.current.layout == null)) return (int) (0);
			win = ctx.current;
			layout = win.layout;
			state = (int) (nk_widget(&bounds, ctx));
			if (state == 0) return (int) (0);
			_in_ = (((state) == (NK_WIDGET_ROM)) || ((layout.flags & NK_WINDOW_ROM) != 0)) ? null : ctx.input;
			return
				(int)
					(nk_do_button_text_symbol(ref ctx.last_widget_state, win.buffer, (nk_rect) (bounds), (int) (symbol), text,
						(int) (len), (uint) (align), (int) (ctx.button_behavior), style, ctx.style.font, _in_));
		}

		public static int nk_button_symbol_text(nk_context ctx, int symbol, char* text, int len, uint align)
		{
			if (ctx == null) return (int) (0);
			return (int) (nk_button_symbol_text_styled(ctx, ctx.style.button, (int) (symbol), text, (int) (len), (uint) (align)));
		}

		public static int nk_button_symbol_label(nk_context ctx, int symbol, char* label, uint align)
		{
			return (int) (nk_button_symbol_text(ctx, (int) (symbol), label, (int) (nk_strlen(label)), (uint) (align)));
		}

		public static int nk_button_symbol_label_styled(nk_context ctx, nk_style_button style, int symbol, char* title,
			uint align)
		{
			return
				(int) (nk_button_symbol_text_styled(ctx, style, (int) (symbol), title, (int) (nk_strlen(title)), (uint) (align)));
		}

		public static int nk_button_image_text_styled(nk_context ctx, nk_style_button style, nk_image img, char* text, int len,
			uint align)
		{
			nk_window win;
			nk_panel layout;
			nk_input _in_;
			nk_rect bounds = new nk_rect();
			int state;
			if (((ctx == null) || (ctx.current == null)) || (ctx.current.layout == null)) return (int) (0);
			win = ctx.current;
			layout = win.layout;
			state = (int) (nk_widget(&bounds, ctx));
			if (state == 0) return (int) (0);
			_in_ = (((state) == (NK_WIDGET_ROM)) || ((layout.flags & NK_WINDOW_ROM) != 0)) ? null : ctx.input;
			return
				(int)
					(nk_do_button_text_image(ref ctx.last_widget_state, win.buffer, (nk_rect) (bounds), (nk_image) (img), text,
						(int) (len), (uint) (align), (int) (ctx.button_behavior), style, ctx.style.font, _in_));
		}

		public static int nk_button_image_text(nk_context ctx, nk_image img, char* text, int len, uint align)
		{
			return
				(int) (nk_button_image_text_styled(ctx, ctx.style.button, (nk_image) (img), text, (int) (len), (uint) (align)));
		}

		public static int nk_button_image_label(nk_context ctx, nk_image img, char* label, uint align)
		{
			return (int) (nk_button_image_text(ctx, (nk_image) (img), label, (int) (nk_strlen(label)), (uint) (align)));
		}

		public static int nk_button_image_label_styled(nk_context ctx, nk_style_button style, nk_image img, char* label,
			uint text_alignment)
		{
			return
				(int)
					(nk_button_image_text_styled(ctx, style, (nk_image) (img), label, (int) (nk_strlen(label)), (uint) (text_alignment)));
		}

		public static int nk_selectable_text(nk_context ctx, char* str, int len, uint align, ref int value)
		{
			nk_window win;
			nk_panel layout;
			nk_input _in_;
			nk_style style;
			int state;
			nk_rect bounds = new nk_rect();
			if ((((ctx == null) || (ctx.current == null)) || (ctx.current.layout == null)) || (value == null)) return (int) (0);
			win = ctx.current;
			layout = win.layout;
			style = ctx.style;
			state = (int) (nk_widget(&bounds, ctx));
			if (state == 0) return (int) (0);
			_in_ = (((state) == (NK_WIDGET_ROM)) || ((layout.flags & NK_WINDOW_ROM) != 0)) ? null : ctx.input;
			return
				(int)
					(nk_do_selectable(ref ctx.last_widget_state, win.buffer, (nk_rect) (bounds), str, (int) (len), (uint) (align),
						ref value, style.selectable, _in_, style.font));
		}

		public static int nk_selectable_image_text(nk_context ctx, nk_image img, char* str, int len, uint align, ref int value)
		{
			nk_window win;
			nk_panel layout;
			nk_input _in_;
			nk_style style;
			int state;
			nk_rect bounds = new nk_rect();
			if ((((ctx == null) || (ctx.current == null)) || (ctx.current.layout == null)) || (value == null)) return (int) (0);
			win = ctx.current;
			layout = win.layout;
			style = ctx.style;
			state = (int) (nk_widget(&bounds, ctx));
			if (state == 0) return (int) (0);
			_in_ = (((state) == (NK_WIDGET_ROM)) || ((layout.flags & NK_WINDOW_ROM) != 0)) ? null : ctx.input;
			return
				(int)
					(nk_do_selectable_image(ref ctx.last_widget_state, win.buffer, (nk_rect) (bounds), str, (int) (len), (uint) (align),
						ref value, img, style.selectable, _in_, style.font));
		}

		public static int nk_select_text(nk_context ctx, char* str, int len, uint align, int value)
		{
			nk_selectable_text(ctx, str, (int) (len), (uint) (align), ref value);
			return (int) (value);
		}

		public static int nk_selectable_label(nk_context ctx, char* str, uint align, ref int value)
		{
			return (int) (nk_selectable_text(ctx, str, (int) (nk_strlen(str)), (uint) (align), ref value));
		}

		public static int nk_selectable_image_label(nk_context ctx, nk_image img, char* str, uint align, ref int value)
		{
			return
				(int) (nk_selectable_image_text(ctx, (nk_image) (img), str, (int) (nk_strlen(str)), (uint) (align), ref value));
		}

		public static int nk_select_label(nk_context ctx, char* str, uint align, int value)
		{
			nk_selectable_text(ctx, str, (int) (nk_strlen(str)), (uint) (align), ref value);
			return (int) (value);
		}

		public static int nk_select_image_label(nk_context ctx, nk_image img, char* str, uint align, int value)
		{
			nk_selectable_image_text(ctx, (nk_image) (img), str, (int) (nk_strlen(str)), (uint) (align), ref value);
			return (int) (value);
		}

		public static int nk_select_image_text(nk_context ctx, nk_image img, char* str, int len, uint align, int value)
		{
			nk_selectable_image_text(ctx, (nk_image) (img), str, (int) (len), (uint) (align), ref value);
			return (int) (value);
		}

		public static int nk_check_text(nk_context ctx, char* text, int len, int active)
		{
			nk_window win;
			nk_panel layout;
			nk_input _in_;
			nk_style style;
			nk_rect bounds = new nk_rect();
			int state;
			if (((ctx == null) || (ctx.current == null)) || (ctx.current.layout == null)) return (int) (active);
			win = ctx.current;
			style = ctx.style;
			layout = win.layout;
			state = (int) (nk_widget(&bounds, ctx));
			if (state == 0) return (int) (active);
			_in_ = (((state) == (NK_WIDGET_ROM)) || ((layout.flags & NK_WINDOW_ROM) != 0)) ? null : ctx.input;
			nk_do_toggle(ref ctx.last_widget_state, win.buffer, (nk_rect) (bounds), &active, text, (int) (len),
				(int) (NK_TOGGLE_CHECK), style.checkbox, _in_, style.font);
			return (int) (active);
		}

		public static uint nk_check_flags_text(nk_context ctx, char* text, int len, uint flags, uint value)
		{
			int old_active;
			if ((ctx == null) || (text == null)) return (uint) (flags);
			old_active = ((int) ((flags & value) & value));
			if ((nk_check_text(ctx, text, (int) (len), (int) (old_active))) != 0) flags |= (uint) (value);
			else flags &= (uint) (~value);
			return (uint) (flags);
		}

		public static int nk_checkbox_text(nk_context ctx, char* text, int len, int* active)
		{
			int old_val;
			if (((ctx == null) || (text == null)) || (active == null)) return (int) (0);
			old_val = (int) (*active);
			*active = (int) (nk_check_text(ctx, text, (int) (len), (int) (*active)));
			return (old_val != *active) ? 1 : 0;
		}

		public static int nk_checkbox_flags_text(nk_context ctx, char* text, int len, uint* flags, uint value)
		{
			int active;
			if (((ctx == null) || (text == null)) || (flags == null)) return (int) (0);
			active = ((int) ((*flags & value) & value));
			if ((nk_checkbox_text(ctx, text, (int) (len), &active)) != 0)
			{
				if ((active) != 0) *flags |= (uint) (value);
				else *flags &= (uint) (~value);
				return (int) (1);
			}

			return (int) (0);
		}

		public static int nk_check_label(nk_context ctx, char* label, int active)
		{
			return (int) (nk_check_text(ctx, label, (int) (nk_strlen(label)), (int) (active)));
		}

		public static uint nk_check_flags_label(nk_context ctx, char* label, uint flags, uint value)
		{
			return (uint) (nk_check_flags_text(ctx, label, (int) (nk_strlen(label)), (uint) (flags), (uint) (value)));
		}

		public static int nk_checkbox_label(nk_context ctx, char* label, int* active)
		{
			return (int) (nk_checkbox_text(ctx, label, (int) (nk_strlen(label)), active));
		}

		public static int nk_checkbox_flags_label(nk_context ctx, char* label, uint* flags, uint value)
		{
			return (int) (nk_checkbox_flags_text(ctx, label, (int) (nk_strlen(label)), flags, (uint) (value)));
		}

		public static int nk_option_text(nk_context ctx, char* text, int len, int is_active)
		{
			nk_window win;
			nk_panel layout;
			nk_input _in_;
			nk_style style;
			nk_rect bounds = new nk_rect();
			int state;
			if (((ctx == null) || (ctx.current == null)) || (ctx.current.layout == null)) return (int) (is_active);
			win = ctx.current;
			style = ctx.style;
			layout = win.layout;
			state = (int) (nk_widget(&bounds, ctx));
			if (state == 0) return (int) (state);
			_in_ = (((state) == (NK_WIDGET_ROM)) || ((layout.flags & NK_WINDOW_ROM) != 0)) ? null : ctx.input;
			nk_do_toggle(ref ctx.last_widget_state, win.buffer, (nk_rect) (bounds), &is_active, text, (int) (len),
				(int) (NK_TOGGLE_OPTION), style.option, _in_, style.font);
			return (int) (is_active);
		}

		public static int nk_radio_text(nk_context ctx, char* text, int len, int* active)
		{
			int old_value;
			if (((ctx == null) || (text == null)) || (active == null)) return (int) (0);
			old_value = (int) (*active);
			*active = (int) (nk_option_text(ctx, text, (int) (len), (int) (old_value)));
			return (old_value != *active) ? 1 : 0;
		}

		public static int nk_option_label(nk_context ctx, char* label, int active)
		{
			return (int) (nk_option_text(ctx, label, (int) (nk_strlen(label)), (int) (active)));
		}

		public static int nk_radio_label(nk_context ctx, char* label, int* active)
		{
			return (int) (nk_radio_text(ctx, label, (int) (nk_strlen(label)), active));
		}

		public static int nk_slider_float(nk_context ctx, float min_value, ref float value, float max_value, float value_step)
		{
			nk_window win;
			nk_panel layout;
			nk_input _in_;
			nk_style style;
			int ret = (int) (0);
			float old_value;
			nk_rect bounds = new nk_rect();
			int state;
			if ((((ctx == null) || (ctx.current == null)) || (ctx.current.layout == null)) || (value == null))
				return (int) (ret);
			win = ctx.current;
			style = ctx.style;
			layout = win.layout;
			state = (int) (nk_widget(&bounds, ctx));
			if (state == 0) return (int) (ret);
			_in_ = (((state) == (NK_WIDGET_ROM)) || ((layout.flags & NK_WINDOW_ROM) != 0)) ? null : ctx.input;
			old_value = (float) (value);
			value =
				(float)
					(nk_do_slider(ref ctx.last_widget_state, win.buffer, (nk_rect) (bounds), (float) (min_value), (float) (old_value),
						(float) (max_value), (float) (value_step), style.slider, _in_, style.font));
			return (((old_value) > (value)) || ((old_value) < (value))) ? 1 : 0;
		}

		public static float nk_slide_float(nk_context ctx, float min, float val, float max, float step)
		{
			nk_slider_float(ctx, (float) (min), ref val, (float) (max), (float) (step));
			return (float) (val);
		}

		public static int nk_slide_int(nk_context ctx, int min, int val, int max, int step)
		{
			float value = (float) (val);
			nk_slider_float(ctx, (float) (min), ref value, (float) (max), (float) (step));
			return (int) (value);
		}

		public static int nk_slider_int(nk_context ctx, int min, ref int val, int max, int step)
		{
			int ret;
			float value = (float) (val);
			ret = (int) (nk_slider_float(ctx, (float) (min), ref value, (float) (max), (float) (step)));
			val = ((int) (value));
			return (int) (ret);
		}

		public static int nk_progress(nk_context ctx, ulong* cur, ulong max, int is_modifyable)
		{
			nk_window win;
			nk_panel layout;
			nk_style style;
			nk_input _in_;
			nk_rect bounds = new nk_rect();
			int state;
			ulong old_value;
			if ((((ctx == null) || (ctx.current == null)) || (ctx.current.layout == null)) || (cur == null)) return (int) (0);
			win = ctx.current;
			style = ctx.style;
			layout = win.layout;
			state = (int) (nk_widget(&bounds, ctx));
			if (state == 0) return (int) (0);
			_in_ = (((state) == (NK_WIDGET_ROM)) || ((layout.flags & NK_WINDOW_ROM) != 0)) ? null : ctx.input;
			old_value = (ulong) (*cur);
			*cur =
				(ulong)
					(nk_do_progress(ref ctx.last_widget_state, win.buffer, (nk_rect) (bounds), (ulong) (*cur), (ulong) (max),
						(int) (is_modifyable), style.progress, _in_));
			return (*cur != old_value) ? 1 : 0;
		}

		public static ulong nk_prog(nk_context ctx, ulong cur, ulong max, int modifyable)
		{
			nk_progress(ctx, &cur, (ulong) (max), (int) (modifyable));
			return (ulong) (cur);
		}

		public static void nk_edit_focus(nk_context ctx, uint flags)
		{
			uint hash;
			nk_window win;
			if ((ctx == null) || (ctx.current == null)) return;
			win = ctx.current;
			hash = (uint) (win.edit.seq);
			win.edit.active = (int) (nk_true);
			win.edit.name = (uint) (hash);
			if ((flags & NK_EDIT_ALWAYS_INSERT_MODE) != 0) win.edit.mode = (byte) (NK_TEXT_EDIT_MODE_INSERT);
		}

		public static void nk_edit_unfocus(nk_context ctx)
		{
			nk_window win;
			if ((ctx == null) || (ctx.current == null)) return;
			win = ctx.current;
			win.edit.active = (int) (nk_false);
			win.edit.name = (uint) (0);
		}

		public static uint nk_edit_string(nk_context ctx, uint flags, char* memory, int* len, int max, NkPluginFilter filter)
		{
			uint hash;
			uint state;
			nk_text_edit edit;
			nk_window win;
			if (((ctx == null) || (memory == null)) || (len == null)) return (uint) (0);
			filter = (filter == null) ? nk_filter_default : filter;
			win = ctx.current;
			hash = (uint) (win.edit.seq);
			edit = ctx.text_edit;
			nk_textedit_clear_state(ctx.text_edit,
				(int) ((flags & NK_EDIT_MULTILINE) != 0 ? NK_TEXT_EDIT_MULTI_LINE : NK_TEXT_EDIT_SINGLE_LINE), filter);
			if (((win.edit.active) != 0) && ((hash) == (win.edit.name)))
			{
				if ((flags & NK_EDIT_NO_CURSOR) != 0) edit.cursor = (int) (nk_utf_len(memory, (int) (*len)));
				else edit.cursor = (int) (win.edit.cursor);
				if ((flags & NK_EDIT_SELECTABLE) == 0)
				{
					edit.select_start = (int) (win.edit.cursor);
					edit.select_end = (int) (win.edit.cursor);
				}
				else
				{
					edit.select_start = (int) (win.edit.sel_start);
					edit.select_end = (int) (win.edit.sel_end);
				}
				edit.mode = (byte) (win.edit.mode);
				edit.scrollbar.x = ((float) (win.edit.scrollbar.x));
				edit.scrollbar.y = ((float) (win.edit.scrollbar.y));
				edit.active = (byte) (nk_true);
			}
			else edit.active = (byte) (nk_false);
			max = (int) ((1) < (max) ? (max) : (1));
			*len = (int) ((*len) < (max - 1) ? (*len) : (max - 1));
			nk_str_init_fixed(edit._string_, memory, (ulong) (max));
			edit._string_.buffer.allocated = ((ulong) (*len));
			edit._string_.len = (int) (nk_utf_len(memory, (int) (*len)));
			state = (uint) (nk_edit_buffer(ctx, (uint) (flags), edit, filter));
			*len = ((int) (edit._string_.buffer.allocated));
			if ((edit.active) != 0)
			{
				win.edit.cursor = (int) (edit.cursor);
				win.edit.sel_start = (int) (edit.select_start);
				win.edit.sel_end = (int) (edit.select_end);
				win.edit.mode = (byte) (edit.mode);
				win.edit.scrollbar.x = ((uint) (edit.scrollbar.x));
				win.edit.scrollbar.y = ((uint) (edit.scrollbar.y));
			}

			return (uint) (state);
		}

		public static uint nk_edit_buffer(nk_context ctx, uint flags, nk_text_edit edit, NkPluginFilter filter)
		{
			nk_window win;
			nk_style style;
			nk_input _in_;
			int state;
			nk_rect bounds = new nk_rect();
			uint ret_flags = (uint) (0);
			byte prev_state;
			uint hash;
			if (((ctx == null) || (ctx.current == null)) || (ctx.current.layout == null)) return (uint) (0);
			win = ctx.current;
			style = ctx.style;
			state = (int) (nk_widget(&bounds, ctx));
			if (state == 0) return (uint) (state);
			_in_ = (win.layout.flags & NK_WINDOW_ROM) != 0 ? null : ctx.input;
			hash = (uint) (win.edit.seq++);
			if (((win.edit.active) != 0) && ((hash) == (win.edit.name)))
			{
				if ((flags & NK_EDIT_NO_CURSOR) != 0) edit.cursor = (int) (edit._string_.len);
				if ((flags & NK_EDIT_SELECTABLE) == 0)
				{
					edit.select_start = (int) (edit.cursor);
					edit.select_end = (int) (edit.cursor);
				}
				if ((flags & NK_EDIT_CLIPBOARD) != 0) edit.clip = (nk_clipboard) (ctx.clip);
				edit.active = ((byte) (win.edit.active));
			}
			else edit.active = (byte) (nk_false);
			edit.mode = (byte) (win.edit.mode);
			filter = (filter == null) ? nk_filter_default : filter;
			prev_state = (byte) (edit.active);
			_in_ = (flags & NK_EDIT_READ_ONLY) != 0 ? null : _in_;
			ret_flags =
				(uint)
					(nk_do_edit(ref ctx.last_widget_state, win.buffer, (nk_rect) (bounds), (uint) (flags), filter, edit, style.edit,
						_in_, style.font));
			if ((ctx.last_widget_state & NK_WIDGET_STATE_HOVER) != 0)
				ctx.style.cursor_active = ctx.style.cursors[NK_CURSOR_TEXT];
			if (((edit.active) != 0) && (prev_state != edit.active))
			{
				win.edit.active = (int) (nk_true);
				win.edit.name = (uint) (hash);
			}
			else if (((prev_state) != 0) && (edit.active == 0))
			{
				win.edit.active = (int) (nk_false);
			}

			return (uint) (ret_flags);
		}

		public static uint nk_edit_string_zero_terminated(nk_context ctx, uint flags, char* buffer, int max,
			NkPluginFilter filter)
		{
			uint result;
			int len = (int) (nk_strlen(buffer));
			result = (uint) (nk_edit_string(ctx, (uint) (flags), buffer, &len, (int) (max), filter));
			buffer[(((max - 1) < (0) ? (0) : (max - 1)) < (len) ? ((max - 1) < (0) ? (0) : (max - 1)) : (len))] = ('\0');
			return (uint) (result);
		}

		public static nk_property_variant nk_property_variant_int(int value, int min_value, int max_value, int step)
		{
			nk_property_variant result = new nk_property_variant();
			result.kind = (int) (NK_PROPERTY_INT);
			result.value.i = (int) (value);
			result.min_value.i = (int) (min_value);
			result.max_value.i = (int) (max_value);
			result.step.i = (int) (step);
			return (nk_property_variant) (result);
		}

		public static nk_property_variant nk_property_variant_float(float value, float min_value, float max_value, float step)
		{
			nk_property_variant result = new nk_property_variant();
			result.kind = (int) (NK_PROPERTY_FLOAT);
			result.value.f = (float) (value);
			result.min_value.f = (float) (min_value);
			result.max_value.f = (float) (max_value);
			result.step.f = (float) (step);
			return (nk_property_variant) (result);
		}

		public static nk_property_variant nk_property_variant_double(double value, double min_value, double max_value,
			double step)
		{
			nk_property_variant result = new nk_property_variant();
			result.kind = (int) (NK_PROPERTY_DOUBLE);
			result.value.d = (double) (value);
			result.min_value.d = (double) (min_value);
			result.max_value.d = (double) (max_value);
			result.step.d = (double) (step);
			return (nk_property_variant) (result);
		}

		public static void nk_property_int(nk_context ctx, char* name, int min, ref int val, int max, int step,
			float inc_per_pixel)
		{
			nk_property_variant variant = new nk_property_variant();
			if ((((ctx == null) || (ctx.current == null)) || (name == null)) || (val == null)) return;
			variant = (nk_property_variant) (nk_property_variant_int((int) (val), (int) (min), (int) (max), (int) (step)));
			nk_property_(ctx, name, &variant, (float) (inc_per_pixel), (int) (NK_FILTER_INT));
			val = (int) (variant.value.i);
		}

		public static void nk_property_float(nk_context ctx, char* name, float min, ref float val, float max, float step,
			float inc_per_pixel)
		{
			nk_property_variant variant = new nk_property_variant();
			if ((((ctx == null) || (ctx.current == null)) || (name == null)) || (val == null)) return;
			variant =
				(nk_property_variant) (nk_property_variant_float((float) (val), (float) (min), (float) (max), (float) (step)));
			nk_property_(ctx, name, &variant, (float) (inc_per_pixel), (int) (NK_FILTER_FLOAT));
			val = (float) (variant.value.f);
		}

		public static void nk_property_double(nk_context ctx, char* name, double min, ref double val, double max, double step,
			float inc_per_pixel)
		{
			nk_property_variant variant = new nk_property_variant();
			if ((((ctx == null) || (ctx.current == null)) || (name == null)) || (val == null)) return;
			variant =
				(nk_property_variant) (nk_property_variant_double((double) (val), (double) (min), (double) (max), (double) (step)));
			nk_property_(ctx, name, &variant, (float) (inc_per_pixel), (int) (NK_FILTER_FLOAT));
			val = (double) (variant.value.d);
		}

		public static int nk_propertyi(nk_context ctx, char* name, int min, int val, int max, int step, float inc_per_pixel)
		{
			nk_property_variant variant = new nk_property_variant();
			if (((ctx == null) || (ctx.current == null)) || (name == null)) return (int) (val);
			variant = (nk_property_variant) (nk_property_variant_int((int) (val), (int) (min), (int) (max), (int) (step)));
			nk_property_(ctx, name, &variant, (float) (inc_per_pixel), (int) (NK_FILTER_INT));
			val = (int) (variant.value.i);
			return (int) (val);
		}

		public static float nk_propertyf(nk_context ctx, char* name, float min, float val, float max, float step,
			float inc_per_pixel)
		{
			nk_property_variant variant = new nk_property_variant();
			if (((ctx == null) || (ctx.current == null)) || (name == null)) return (float) (val);
			variant =
				(nk_property_variant) (nk_property_variant_float((float) (val), (float) (min), (float) (max), (float) (step)));
			nk_property_(ctx, name, &variant, (float) (inc_per_pixel), (int) (NK_FILTER_FLOAT));
			val = (float) (variant.value.f);
			return (float) (val);
		}

		public static double nk_propertyd(nk_context ctx, char* name, double min, double val, double max, double step,
			float inc_per_pixel)
		{
			nk_property_variant variant = new nk_property_variant();
			if (((ctx == null) || (ctx.current == null)) || (name == null)) return (double) (val);
			variant =
				(nk_property_variant) (nk_property_variant_double((double) (val), (double) (min), (double) (max), (double) (step)));
			nk_property_(ctx, name, &variant, (float) (inc_per_pixel), (int) (NK_FILTER_FLOAT));
			val = (double) (variant.value.d);
			return (double) (val);
		}

		public static int nk_color_pick(nk_context ctx, nk_colorf* color, int fmt)
		{
			nk_window win;
			nk_panel layout;
			nk_style config;
			nk_input _in_;
			int state;
			nk_rect bounds = new nk_rect();
			if ((((ctx == null) || (ctx.current == null)) || (ctx.current.layout == null)) || (color == null)) return (int) (0);
			win = ctx.current;
			config = ctx.style;
			layout = win.layout;
			state = (int) (nk_widget(&bounds, ctx));
			if (state == 0) return (int) (0);
			_in_ = (((state) == (NK_WIDGET_ROM)) || ((layout.flags & NK_WINDOW_ROM) != 0)) ? null : ctx.input;
			return
				(int)
					(nk_do_color_picker(ref ctx.last_widget_state, win.buffer, color, (int) (fmt), (nk_rect) (bounds),
						(nk_vec2) (nk_vec2_((float) (0), (float) (0))), _in_, config.font));
		}

		public static nk_colorf nk_color_picker(nk_context ctx, nk_colorf color, int fmt)
		{
			nk_color_pick(ctx, &color, (int) (fmt));
			return (nk_colorf) (color);
		}

		public static int nk_chart_begin_colored(nk_context ctx, int type, nk_color color, nk_color highlight, int count,
			float min_value, float max_value)
		{
			nk_window win;
			nk_chart chart;
			nk_style config;
			nk_style_chart style;
			nk_style_item background;
			nk_rect bounds = new nk_rect();
			if (((ctx == null) || (ctx.current == null)) || (ctx.current.layout == null)) return (int) (0);
			if (nk_widget(&bounds, ctx) == 0)
			{
				chart = ctx.current.layout.chart;
				return (int) (0);
			}

			win = ctx.current;
			config = ctx.style;
			chart = win.layout.chart;
			style = config.chart;

			chart.x = (float) (bounds.x + style.padding.x);
			chart.y = (float) (bounds.y + style.padding.y);
			chart.w = (float) (bounds.w - 2*style.padding.x);
			chart.h = (float) (bounds.h - 2*style.padding.y);
			chart.w = (float) ((chart.w) < (2*style.padding.x) ? (2*style.padding.x) : (chart.w));
			chart.h = (float) ((chart.h) < (2*style.padding.y) ? (2*style.padding.y) : (chart.h));
			{
				nk_chart_slot slot = chart.slots[chart.slot++];
				slot.type = (int) (type);
				slot.count = (int) (count);
				slot.color = (nk_color) (color);
				slot.highlight = (nk_color) (highlight);
				slot.min = (float) ((min_value) < (max_value) ? (min_value) : (max_value));
				slot.max = (float) ((min_value) < (max_value) ? (max_value) : (min_value));
				slot.range = (float) (slot.max - slot.min);
			}

			background = style.background;
			if ((background.type) == (NK_STYLE_ITEM_IMAGE))
			{
				nk_draw_image(win.buffer, (nk_rect) (bounds), background.data.image, (nk_color) (nk_white));
			}
			else
			{
				nk_fill_rect(win.buffer, (nk_rect) (bounds), (float) (style.rounding), (nk_color) (style.border_color));
				nk_fill_rect(win.buffer, (nk_rect) (nk_shrink_rect_((nk_rect) (bounds), (float) (style.border))),
					(float) (style.rounding), (nk_color) (style.background.data.color));
			}

			return (int) (1);
		}

		public static int nk_chart_begin(nk_context ctx, int type, int count, float min_value, float max_value)
		{
			return
				(int)
					(nk_chart_begin_colored(ctx, (int) (type), (nk_color) (ctx.style.chart.color),
						(nk_color) (ctx.style.chart.selected_color), (int) (count), (float) (min_value), (float) (max_value)));
		}

		public static void nk_chart_add_slot_colored(nk_context ctx, int type, nk_color color, nk_color highlight, int count,
			float min_value, float max_value)
		{
			if (((ctx == null) || (ctx.current == null)) || (ctx.current.layout == null)) return;
			if ((ctx.current.layout.chart.slot) >= (4)) return;
			{
				nk_chart chart = ctx.current.layout.chart;
				nk_chart_slot slot = chart.slots[chart.slot++];
				slot.type = (int) (type);
				slot.count = (int) (count);
				slot.color = (nk_color) (color);
				slot.highlight = (nk_color) (highlight);
				slot.min = (float) ((min_value) < (max_value) ? (min_value) : (max_value));
				slot.max = (float) ((min_value) < (max_value) ? (max_value) : (min_value));
				slot.range = (float) (slot.max - slot.min);
			}

		}

		public static void nk_chart_add_slot(nk_context ctx, int type, int count, float min_value, float max_value)
		{
			nk_chart_add_slot_colored(ctx, (int) (type), (nk_color) (ctx.style.chart.color),
				(nk_color) (ctx.style.chart.selected_color), (int) (count), (float) (min_value), (float) (max_value));
		}

		public static uint nk_chart_push_line(nk_context ctx, nk_window win, nk_chart g, float value, int slot)
		{
			nk_panel layout = win.layout;
			nk_input i = ctx.input;
			nk_command_buffer _out_ = win.buffer;
			uint ret = (uint) (0);
			nk_vec2 cur = new nk_vec2();
			nk_rect bounds = new nk_rect();
			nk_color color = new nk_color();
			float step;
			float range;
			float ratio;
			step = (float) (g.w/(float) (g.slots[slot].count));
			range = (float) (g.slots[slot].max - g.slots[slot].min);
			ratio = (float) ((value - g.slots[slot].min)/range);
			if ((g.slots[slot].index) == (0))
			{
				g.slots[slot].last.x = (float) (g.x);
				g.slots[slot].last.y = (float) ((g.y + g.h) - ratio*g.h);
				bounds.x = (float) (g.slots[slot].last.x - 2);
				bounds.y = (float) (g.slots[slot].last.y - 2);
				bounds.w = (float) (bounds.h = (float) (4));
				color = (nk_color) (g.slots[slot].color);
				if (((layout.flags & NK_WINDOW_ROM) == 0) &&
				    ((((g.slots[slot].last.x - 3) <= (i.mouse.pos.x)) && ((i.mouse.pos.x) < (g.slots[slot].last.x - 3 + 6))) &&
				     (((g.slots[slot].last.y - 3) <= (i.mouse.pos.y)) && ((i.mouse.pos.y) < (g.slots[slot].last.y - 3 + 6)))))
				{
					ret = (uint) ((nk_input_is_mouse_hovering_rect(i, (nk_rect) (bounds))) != 0 ? NK_CHART_HOVERING : 0);
					ret |=
						(uint)
							((((i.mouse.buttons[NK_BUTTON_LEFT].down) != 0) && ((i.mouse.buttons[NK_BUTTON_LEFT].clicked) != 0))
								? NK_CHART_CLICKED
								: 0);
					color = (nk_color) (g.slots[slot].highlight);
				}
				nk_fill_rect(_out_, (nk_rect) (bounds), (float) (0), (nk_color) (color));
				g.slots[slot].index += (int) (1);
				return (uint) (ret);
			}

			color = (nk_color) (g.slots[slot].color);
			cur.x = (float) (g.x + (step*(float) (g.slots[slot].index)));
			cur.y = (float) ((g.y + g.h) - (ratio*g.h));
			nk_stroke_line(_out_, (float) (g.slots[slot].last.x), (float) (g.slots[slot].last.y), (float) (cur.x),
				(float) (cur.y), (float) (1.0f), (nk_color) (color));
			bounds.x = (float) (cur.x - 3);
			bounds.y = (float) (cur.y - 3);
			bounds.w = (float) (bounds.h = (float) (6));
			if ((layout.flags & NK_WINDOW_ROM) == 0)
			{
				if ((nk_input_is_mouse_hovering_rect(i, (nk_rect) (bounds))) != 0)
				{
					ret = (uint) (NK_CHART_HOVERING);
					ret |=
						(uint)
							(((i.mouse.buttons[NK_BUTTON_LEFT].down == 0) && ((i.mouse.buttons[NK_BUTTON_LEFT].clicked) != 0))
								? NK_CHART_CLICKED
								: 0);
					color = (nk_color) (g.slots[slot].highlight);
				}
			}

			nk_fill_rect(_out_, (nk_rect) (nk_rect_((float) (cur.x - 2), (float) (cur.y - 2), (float) (4), (float) (4))),
				(float) (0), (nk_color) (color));
			g.slots[slot].last.x = (float) (cur.x);
			g.slots[slot].last.y = (float) (cur.y);
			g.slots[slot].index += (int) (1);
			return (uint) (ret);
		}

		public static uint nk_chart_push_column(nk_context ctx, nk_window win, nk_chart chart, float value, int slot)
		{
			nk_command_buffer _out_ = win.buffer;
			nk_input _in_ = ctx.input;
			nk_panel layout = win.layout;
			float ratio;
			uint ret = (uint) (0);
			nk_color color = new nk_color();
			nk_rect item = new nk_rect();
			if ((chart.slots[slot].index) >= (chart.slots[slot].count)) return (uint) (nk_false);
			if ((chart.slots[slot].count) != 0)
			{
				float padding = (float) (chart.slots[slot].count - 1);
				item.w = (float) ((chart.w - padding)/(float) (chart.slots[slot].count));
			}

			color = (nk_color) (chart.slots[slot].color);
			item.h =
				(float)
					(chart.h*
					 (((value/chart.slots[slot].range) < (0)) ? -(value/chart.slots[slot].range) : (value/chart.slots[slot].range)));
			if ((value) >= (0))
			{
				ratio =
					(float)
						((value + (((chart.slots[slot].min) < (0)) ? -(chart.slots[slot].min) : (chart.slots[slot].min)))/
						 (((chart.slots[slot].range) < (0)) ? -(chart.slots[slot].range) : (chart.slots[slot].range)));
				item.y = (float) ((chart.y + chart.h) - chart.h*ratio);
			}
			else
			{
				ratio = (float) ((value - chart.slots[slot].max)/chart.slots[slot].range);
				item.y = (float) (chart.y + (chart.h*(((ratio) < (0)) ? -(ratio) : (ratio))) - item.h);
			}

			item.x = (float) (chart.x + ((float) (chart.slots[slot].index)*item.w));
			item.x = (float) (item.x + ((float) (chart.slots[slot].index)));
			if (((layout.flags & NK_WINDOW_ROM) == 0) &&
			    ((((item.x) <= (_in_.mouse.pos.x)) && ((_in_.mouse.pos.x) < (item.x + item.w))) &&
			     (((item.y) <= (_in_.mouse.pos.y)) && ((_in_.mouse.pos.y) < (item.y + item.h)))))
			{
				ret = (uint) (NK_CHART_HOVERING);
				ret |=
					(uint)
						(((((nk_mouse_button*) _in_.mouse.buttons + NK_BUTTON_LEFT)->down == 0) &&
						  ((((nk_mouse_button*) _in_.mouse.buttons + NK_BUTTON_LEFT)->clicked) != 0))
							? NK_CHART_CLICKED
							: 0);
				color = (nk_color) (chart.slots[slot].highlight);
			}

			nk_fill_rect(_out_, (nk_rect) (item), (float) (0), (nk_color) (color));
			chart.slots[slot].index += (int) (1);
			return (uint) (ret);
		}

		public static uint nk_chart_push_slot(nk_context ctx, float value, int slot)
		{
			uint flags;
			nk_window win;
			if (((ctx == null) || (ctx.current == null)) || ((slot) >= (4))) return (uint) (nk_false);
			if ((slot) >= (ctx.current.layout.chart.slot)) return (uint) (nk_false);
			win = ctx.current;
			if ((win.layout.chart.slot) < (slot)) return (uint) (nk_false);
			switch (win.layout.chart.slots[slot].type)
			{
				case NK_CHART_LINES:
					flags = (uint) (nk_chart_push_line(ctx, win, win.layout.chart, (float) (value), (int) (slot)));
					break;
				case NK_CHART_COLUMN:
					flags = (uint) (nk_chart_push_column(ctx, win, win.layout.chart, (float) (value), (int) (slot)));
					break;
				default:
				case NK_CHART_MAX:
					flags = (uint) (0);
					break;
			}

			return (uint) (flags);
		}

		public static uint nk_chart_push(nk_context ctx, float value)
		{
			return (uint) (nk_chart_push_slot(ctx, (float) (value), (int) (0)));
		}

		public static void nk_chart_end(nk_context ctx)
		{
			nk_window win;
			nk_chart chart;
			if ((ctx == null) || (ctx.current == null)) return;
			win = ctx.current;
			chart = win.layout.chart;

			return;
		}

		public static void nk_plot(nk_context ctx, int type, float* values, int count, int offset)
		{
			int i = (int) (0);
			float min_value;
			float max_value;
			if (((ctx == null) || (values == null)) || (count == 0)) return;
			min_value = (float) (values[offset]);
			max_value = (float) (values[offset]);
			for (i = (int) (0); (i) < (count); ++i)
			{
				min_value = (float) ((values[i + offset]) < (min_value) ? (values[i + offset]) : (min_value));
				max_value = (float) ((values[i + offset]) < (max_value) ? (max_value) : (values[i + offset]));
			}
			if ((nk_chart_begin(ctx, (int) (type), (int) (count), (float) (min_value), (float) (max_value))) != 0)
			{
				for (i = (int) (0); (i) < (count); ++i)
				{
					nk_chart_push(ctx, (float) (values[i + offset]));
				}
				nk_chart_end(ctx);
			}

		}

		public static void nk_plot_function(nk_context ctx, int type, void* userdata, NkFloatValueGetter value_getter,
			int count, int offset)
		{
			int i = (int) (0);
			float min_value;
			float max_value;
			if (((ctx == null) || (value_getter == null)) || (count == 0)) return;
			max_value = (float) (min_value = (float) (value_getter(userdata, (int) (offset))));
			for (i = (int) (0); (i) < (count); ++i)
			{
				float value = (float) (value_getter(userdata, (int) (i + offset)));
				min_value = (float) ((value) < (min_value) ? (value) : (min_value));
				max_value = (float) ((value) < (max_value) ? (max_value) : (value));
			}
			if ((nk_chart_begin(ctx, (int) (type), (int) (count), (float) (min_value), (float) (max_value))) != 0)
			{
				for (i = (int) (0); (i) < (count); ++i)
				{
					nk_chart_push(ctx, (float) (value_getter(userdata, (int) (i + offset))));
				}
				nk_chart_end(ctx);
			}

		}

		public static int nk_group_scrolled_offset_begin(nk_context ctx, nk_scroll offset, char* title, uint flags)
		{
			nk_rect bounds = new nk_rect();
			nk_window panel = new nk_window();
			nk_window win;
			win = ctx.current;
			nk_panel_alloc_space(&bounds, ctx);
			{
				if (
					(!(!(((((bounds.x) > (win.layout.clip.x + win.layout.clip.w)) || ((bounds.x + bounds.w) < (win.layout.clip.x))) ||
					      ((bounds.y) > (win.layout.clip.y + win.layout.clip.h))) || ((bounds.y + bounds.h) < (win.layout.clip.y))))) &&
					((flags & NK_WINDOW_MOVABLE) == 0))
				{
					return (int) (0);
				}
			}

			if ((win.flags & NK_WINDOW_ROM) != 0) flags |= (uint) (NK_WINDOW_ROM);

			panel.bounds = (nk_rect) (bounds);
			panel.flags = (uint) (flags);
			panel.scrollbar.x = offset.x;
			panel.scrollbar.y = offset.y;
			panel.buffer = (nk_command_buffer) (win.buffer);
			panel.layout = (nk_panel) (nk_create_panel(ctx));
			ctx.current = panel;
			nk_panel_begin(ctx, (flags & NK_WINDOW_TITLE) != 0 ? title : null, (int) (NK_PANEL_GROUP));
			win.buffer = (nk_command_buffer) (panel.buffer);
			win.buffer.clip = (nk_rect) (panel.layout.clip);
			panel.layout.offset = offset;

			panel.layout.parent = win.layout;
			win.layout = panel.layout;
			ctx.current = win;
			if (((panel.layout.flags & NK_WINDOW_CLOSED) != 0) || ((panel.layout.flags & NK_WINDOW_MINIMIZED) != 0))
			{
				uint f = (uint) (panel.layout.flags);
				nk_group_scrolled_end(ctx);
				if ((f & NK_WINDOW_CLOSED) != 0) return (int) (NK_WINDOW_CLOSED);
				if ((f & NK_WINDOW_MINIMIZED) != 0) return (int) (NK_WINDOW_MINIMIZED);
			}

			return (int) (1);
		}

		public static void nk_group_scrolled_end(nk_context ctx)
		{
			nk_window win;
			nk_panel parent;
			nk_panel g;
			nk_rect clip = new nk_rect();
			nk_window pan = new nk_window();
			nk_vec2 panel_padding = new nk_vec2();
			if ((ctx == null) || (ctx.current == null)) return;
			win = ctx.current;
			g = win.layout;
			parent = g.parent;

			panel_padding = (nk_vec2) (nk_panel_get_padding(ctx.style, (int) (NK_PANEL_GROUP)));
			pan.bounds.y = (float) (g.bounds.y - (g.header_height + g.menu.h));
			pan.bounds.x = (float) (g.bounds.x - panel_padding.x);
			pan.bounds.w = (float) (g.bounds.w + 2*panel_padding.x);
			pan.bounds.h = (float) (g.bounds.h + g.header_height + g.menu.h);
			if ((g.flags & NK_WINDOW_BORDER) != 0)
			{
				pan.bounds.x -= (float) (g.border);
				pan.bounds.y -= (float) (g.border);
				pan.bounds.w += (float) (2*g.border);
				pan.bounds.h += (float) (2*g.border);
			}

			if ((g.flags & NK_WINDOW_NO_SCROLLBAR) == 0)
			{
				pan.bounds.w += (float) (ctx.style.window.scrollbar_size.x);
				pan.bounds.h += (float) (ctx.style.window.scrollbar_size.y);
			}

			pan.scrollbar.x = (uint) (g.offset.x);
			pan.scrollbar.y = (uint) (g.offset.y);
			pan.flags = (uint) (g.flags);
			pan.buffer = (nk_command_buffer) (win.buffer);
			pan.layout = g;
			pan.parent = win;
			ctx.current = pan;
			nk_unify(ref clip, ref parent.clip, (float) (pan.bounds.x), (float) (pan.bounds.y),
				(float) (pan.bounds.x + pan.bounds.w), (float) (pan.bounds.y + pan.bounds.h + panel_padding.x));
			nk_push_scissor(pan.buffer, (nk_rect) (clip));
			nk_end(ctx);
			win.buffer = (nk_command_buffer) (pan.buffer);
			nk_push_scissor(win.buffer, (nk_rect) (parent.clip));
			ctx.current = win;
			win.layout = parent;
			g.bounds = (nk_rect) (pan.bounds);
			return;
		}

		public static int nk_group_scrolled_begin(nk_context ctx, nk_scroll scroll, char* title, uint flags)
		{
			return (int) (nk_group_scrolled_offset_begin(ctx, scroll, title, (uint) (flags)));
		}

		public static int nk_group_begin_titled(nk_context ctx, char* id, char* title, uint flags)
		{
			int id_len;
			uint id_hash;
			nk_window win;
			uint* x_offset;
			uint* y_offset;
			if ((((ctx == null) || (ctx.current == null)) || (ctx.current.layout == null)) || (id == null)) return (int) (0);
			win = ctx.current;
			id_len = (int) (nk_strlen(id));
			id_hash = (uint) (nk_murmur_hash(id, (int) (id_len), (uint) (NK_PANEL_GROUP)));
			x_offset = nk_find_value(win, (uint) (id_hash));
			if (x_offset == null)
			{
				x_offset = nk_add_value(ctx, win, (uint) (id_hash), (uint) (0));
				y_offset = nk_add_value(ctx, win, (uint) (id_hash + 1), (uint) (0));
				if ((x_offset == null) || (y_offset == null)) return (int) (0);
				*x_offset = (uint) (*y_offset = (uint) (0));
			}
			else y_offset = nk_find_value(win, (uint) (id_hash + 1));
			return
				(int) (nk_group_scrolled_offset_begin(ctx, new nk_scroll {x = *x_offset, y = *y_offset}, title, (uint) (flags)));
		}

		public static int nk_group_begin(nk_context ctx, char* title, uint flags)
		{
			return (int) (nk_group_begin_titled(ctx, title, title, (uint) (flags)));
		}

		public static void nk_group_end(nk_context ctx)
		{
			nk_group_scrolled_end(ctx);
		}

		public static int nk_list_view_begin(nk_context ctx, nk_list_view view, char* title, uint flags, int row_height,
			int row_count)
		{
			int title_len;
			uint title_hash;
			uint* x_offset;
			uint* y_offset;
			int result;
			nk_window win;
			nk_panel layout;
			nk_style style;
			nk_vec2 item_spacing = new nk_vec2();
			if (((ctx == null) || (view == null)) || (title == null)) return (int) (0);
			win = ctx.current;
			style = ctx.style;
			item_spacing = (nk_vec2) (style.window.spacing);
			row_height += (int) ((0) < ((int) (item_spacing.y)) ? ((int) (item_spacing.y)) : (0));
			title_len = (int) (nk_strlen(title));
			title_hash = (uint) (nk_murmur_hash(title, (int) (title_len), (uint) (NK_PANEL_GROUP)));
			x_offset = nk_find_value(win, (uint) (title_hash));
			if (x_offset == null)
			{
				x_offset = nk_add_value(ctx, win, (uint) (title_hash), (uint) (0));
				y_offset = nk_add_value(ctx, win, (uint) (title_hash + 1), (uint) (0));
				if ((x_offset == null) || (y_offset == null)) return (int) (0);
				*x_offset = (uint) (*y_offset = (uint) (0));
			}
			else y_offset = nk_find_value(win, (uint) (title_hash + 1));
			view.scroll_value = *y_offset;
			view.scroll_pointer = y_offset;
			*y_offset = (uint) (0);
			result =
				(int) (nk_group_scrolled_offset_begin(ctx, new nk_scroll {x = *x_offset, y = *y_offset}, title, (uint) (flags)));
			win = ctx.current;
			layout = win.layout;
			view.total_height = (int) (row_height*((row_count) < (1) ? (1) : (row_count)));
			view.begin =
				((int)
					(((float) (view.scroll_value)/(float) (row_height)) < (0.0f)
						? (0.0f)
						: ((float) (view.scroll_value)/(float) (row_height))));
			view.count =
				(int)
					((nk_iceilf((float) ((layout.clip.h)/(float) (row_height)))) < (0)
						? (0)
						: (nk_iceilf((float) ((layout.clip.h)/(float) (row_height)))));
			view.end = (int) (view.begin + view.count);
			view.ctx = ctx;
			return (int) (result);
		}

		public static void nk_list_view_end(nk_list_view view)
		{
			nk_context ctx;
			nk_window win;
			nk_panel layout;
			if ((view == null) || (view.ctx == null)) return;
			ctx = view.ctx;
			win = ctx.current;
			layout = win.layout;
			layout.at_y = (float) (layout.bounds.y + (float) (view.total_height));
			*view.scroll_pointer = (uint) (*view.scroll_pointer + view.scroll_value);
			nk_group_end(view.ctx);
		}

		public static int nk_popup_begin(nk_context ctx, int type, char* title, uint flags, nk_rect rect)
		{
			nk_window popup;
			nk_window win;
			nk_panel panel;
			int title_len;
			uint title_hash;
			ulong allocated;
			if (((ctx == null) || (ctx.current == null)) || (ctx.current.layout == null)) return (int) (0);
			win = ctx.current;
			panel = win.layout;
			title_len = (int) (nk_strlen(title));
			title_hash = (uint) (nk_murmur_hash(title, (int) (title_len), (uint) (NK_PANEL_POPUP)));
			popup = win.popup.win;
			if (popup == null)
			{
				popup = (nk_window) (nk_create_window(ctx));
				popup.parent = win;
				win.popup.win = popup;
				win.popup.active = (int) (0);
				win.popup.type = (int) (NK_PANEL_POPUP);
			}

			if (win.popup.name != title_hash)
			{
				if (win.popup.active == 0)
				{
					win.popup.name = (uint) (title_hash);
					win.popup.active = (int) (1);
					win.popup.type = (int) (NK_PANEL_POPUP);
				}
				else return (int) (0);
			}

			ctx.current = popup;
			rect.x += (float) (win.layout.clip.x);
			rect.y += (float) (win.layout.clip.y);
			popup.parent = win;
			popup.bounds = (nk_rect) (rect);
			popup.seq = (uint) (ctx.seq);
			popup.layout = (nk_panel) (nk_create_panel(ctx));
			popup.flags = (uint) (flags);
			popup.flags |= (uint) (NK_WINDOW_BORDER);
			if ((type) == (NK_POPUP_DYNAMIC)) popup.flags |= (uint) (NK_WINDOW_DYNAMIC);
			popup.buffer = (nk_command_buffer) (win.buffer);
			nk_start_popup(ctx, win);
			allocated = (ulong) (ctx.memory.allocated);
			nk_push_scissor(popup.buffer, (nk_rect) (nk_null_rect));
			if ((nk_panel_begin(ctx, title, (int) (NK_PANEL_POPUP))) != 0)
			{
				nk_panel root;
				root = win.layout;
				while ((root) != null)
				{
					root.flags |= (uint) (NK_WINDOW_ROM);
					root.flags &= (uint) (~(uint) (NK_WINDOW_REMOVE_ROM));
					root = root.parent;
				}
				win.popup.active = (int) (1);
				popup.layout.offset = popup.scrollbar;
				popup.layout.parent = win.layout;
				return (int) (1);
			}
			else
			{
				nk_panel root;
				root = win.layout;
				while ((root) != null)
				{
					root.flags |= (uint) (NK_WINDOW_REMOVE_ROM);
					root = root.parent;
				}
				win.popup.buf.active = (int) (0);
				win.popup.active = (int) (0);
				ctx.memory.allocated = (ulong) (allocated);
				ctx.current = win;
				nk_free_panel(ctx, popup.layout);
				popup.layout = null;
				return (int) (0);
			}

		}

		public static int nk_nonblock_begin(nk_context ctx, uint flags, nk_rect body, nk_rect header, int panel_type)
		{
			nk_window popup;
			nk_window win;
			nk_panel panel;
			int is_active = (int) (nk_true);
			if (((ctx == null) || (ctx.current == null)) || (ctx.current.layout == null)) return (int) (0);
			win = ctx.current;
			panel = win.layout;
			popup = win.popup.win;
			if (popup == null)
			{
				popup = (nk_window) (nk_create_window(ctx));
				popup.parent = win;
				win.popup.win = popup;
				win.popup.type = (int) (panel_type);
				nk_command_buffer_init(popup.buffer, (int) (NK_CLIPPING_ON));
			}
			else
			{
				int pressed;
				int in_body;
				int in_header;
				pressed = (int) (nk_input_is_mouse_pressed(ctx.input, (int) (NK_BUTTON_LEFT)));
				in_body = (int) (nk_input_is_mouse_hovering_rect(ctx.input, (nk_rect) (body)));
				in_header = (int) (nk_input_is_mouse_hovering_rect(ctx.input, (nk_rect) (header)));
				if (((pressed) != 0) && ((in_body == 0) || ((in_header) != 0))) is_active = (int) (nk_false);
			}

			win.popup.header = (nk_rect) (header);
			if (is_active == 0)
			{
				nk_panel root = win.layout;
				while ((root) != null)
				{
					root.flags |= (uint) (NK_WINDOW_REMOVE_ROM);
					root = root.parent;
				}
				return (int) (is_active);
			}

			popup.bounds = (nk_rect) (body);
			popup.parent = win;
			popup.layout = (nk_panel) (nk_create_panel(ctx));
			popup.flags = (uint) (flags);
			popup.flags |= (uint) (NK_WINDOW_BORDER);
			popup.flags |= (uint) (NK_WINDOW_DYNAMIC);
			popup.seq = (uint) (ctx.seq);
			win.popup.active = (int) (1);
			nk_start_popup(ctx, win);
			popup.buffer = (nk_command_buffer) (win.buffer);
			nk_push_scissor(popup.buffer, (nk_rect) (nk_null_rect));
			ctx.current = popup;
			nk_panel_begin(ctx, null, (int) (panel_type));
			win.buffer = (nk_command_buffer) (popup.buffer);
			popup.layout.parent = win.layout;
			popup.layout.offset = popup.scrollbar;

			{
				nk_panel root;
				root = win.layout;
				while ((root) != null)
				{
					root.flags |= (uint) (NK_WINDOW_ROM);
					root = root.parent;
				}
			}

			return (int) (is_active);
		}

		public static void nk_popup_close(nk_context ctx)
		{
			nk_window popup;
			if ((ctx == null) || (ctx.current == null)) return;
			popup = ctx.current;
			popup.flags |= (uint) (NK_WINDOW_HIDDEN);
		}

		public static void nk_popup_end(nk_context ctx)
		{
			nk_window win;
			nk_window popup;
			if (((ctx == null) || (ctx.current == null)) || (ctx.current.layout == null)) return;
			popup = ctx.current;
			if (popup.parent == null) return;
			win = popup.parent;
			if ((popup.flags & NK_WINDOW_HIDDEN) != 0)
			{
				nk_panel root;
				root = win.layout;
				while ((root) != null)
				{
					root.flags |= (uint) (NK_WINDOW_REMOVE_ROM);
					root = root.parent;
				}
				win.popup.active = (int) (0);
			}

			nk_push_scissor(popup.buffer, (nk_rect) (nk_null_rect));
			nk_end(ctx);
			win.buffer = (nk_command_buffer) (popup.buffer);
			nk_finish_popup(ctx, win);
			ctx.current = win;
			nk_push_scissor(win.buffer, (nk_rect) (win.layout.clip));
		}

		public static int nk_tooltip_begin(nk_context ctx, float width)
		{
			int x;
			int y;
			int w;
			int h;
			nk_window win;
			nk_input _in_;
			nk_rect bounds = new nk_rect();
			int ret;
			if (((ctx == null) || (ctx.current == null)) || (ctx.current.layout == null)) return (int) (0);
			win = ctx.current;
			_in_ = ctx.input;
			if (((win.popup.win) != null) && ((win.popup.type & NK_PANEL_SET_NONBLOCK) != 0)) return (int) (0);
			w = (int) (nk_iceilf((float) (width)));
			h = (int) (nk_iceilf((float) (nk_null_rect.h)));
			x = (int) (nk_ifloorf((float) (_in_.mouse.pos.x + 1)) - (int) (win.layout.clip.x));
			y = (int) (nk_ifloorf((float) (_in_.mouse.pos.y + 1)) - (int) (win.layout.clip.y));
			bounds.x = ((float) (x));
			bounds.y = ((float) (y));
			bounds.w = ((float) (w));
			bounds.h = ((float) (h));
			ret =
				(int)
					(nk_popup_begin(ctx, (int) (NK_POPUP_DYNAMIC), "__##Tooltip##__",
						(uint) (NK_WINDOW_NO_SCROLLBAR | NK_WINDOW_BORDER), (nk_rect) (bounds)));
			if ((ret) != 0) win.layout.flags &= (uint) (~(uint) (NK_WINDOW_ROM));
			win.popup.type = (int) (NK_PANEL_TOOLTIP);
			ctx.current.layout.type = (int) (NK_PANEL_TOOLTIP);
			return (int) (ret);
		}

		public static void nk_tooltip_end(nk_context ctx)
		{
			if ((ctx == null) || (ctx.current == null)) return;
			ctx.current.seq--;
			nk_popup_close(ctx);
			nk_popup_end(ctx);
		}

		public static void nk_tooltip(nk_context ctx, char* text)
		{
			nk_style style;
			nk_vec2 padding = new nk_vec2();
			int text_len;
			float text_width;
			float text_height;
			if ((((ctx == null) || (ctx.current == null)) || (ctx.current.layout == null)) || (text == null)) return;
			style = ctx.style;
			padding = (nk_vec2) (style.window.padding);
			text_len = (int) (nk_strlen(text));
			text_width =
				(float) (style.font.width((nk_handle) (style.font.userdata), (float) (style.font.height), text, (int) (text_len)));
			text_width += (float) (4*padding.x);
			text_height = (float) (style.font.height + 2*padding.y);
			if ((nk_tooltip_begin(ctx, (float) (text_width))) != 0)
			{
				nk_layout_row_dynamic(ctx, (float) (text_height), (int) (1));
				nk_text_(ctx, text, (int) (text_len), (uint) (NK_TEXT_LEFT));
				nk_tooltip_end(ctx);
			}

		}

		public static int nk_contextual_begin(nk_context ctx, uint flags, nk_vec2 size, nk_rect trigger_bounds)
		{
			nk_window win;
			nk_window popup;
			nk_rect body = new nk_rect();
			nk_rect null_rect = new nk_rect();
			int is_clicked = (int) (0);
			int is_active = (int) (0);
			int is_open = (int) (0);
			int ret = (int) (0);
			if (((ctx == null) || (ctx.current == null)) || (ctx.current.layout == null)) return (int) (0);
			win = ctx.current;
			++win.popup.con_count;
			popup = win.popup.win;
			is_open = (int) (((popup) != null) && ((win.popup.type) == (NK_PANEL_CONTEXTUAL)) ? 1 : 0);
			is_clicked = (int) (nk_input_mouse_clicked(ctx.input, (int) (NK_BUTTON_RIGHT), (nk_rect) (trigger_bounds)));
			if (((win.popup.active_con) != 0) && (win.popup.con_count != win.popup.active_con)) return (int) (0);
			if (((((is_clicked) != 0) && ((is_open) != 0)) && (is_active == 0)) ||
			    (((is_open == 0) && (is_active == 0)) && (is_clicked == 0))) return (int) (0);
			win.popup.active_con = (uint) (win.popup.con_count);
			if ((is_clicked) != 0)
			{
				body.x = (float) (ctx.input.mouse.pos.x);
				body.y = (float) (ctx.input.mouse.pos.y);
			}
			else
			{
				body.x = (float) (popup.bounds.x);
				body.y = (float) (popup.bounds.y);
			}

			body.w = (float) (size.x);
			body.h = (float) (size.y);
			ret =
				(int)
					(nk_nonblock_begin(ctx, (uint) (flags | NK_WINDOW_NO_SCROLLBAR), (nk_rect) (body), (nk_rect) (null_rect),
						(int) (NK_PANEL_CONTEXTUAL)));
			if ((ret) != 0) win.popup.type = (int) (NK_PANEL_CONTEXTUAL);
			else
			{
				win.popup.active_con = (uint) (0);
				if ((win.popup.win) != null) win.popup.win.flags = (uint) (0);
			}

			return (int) (ret);
		}

		public static int nk_contextual_item_text(nk_context ctx, char* text, int len, uint alignment)
		{
			nk_window win;
			nk_input _in_;
			nk_style style;
			nk_rect bounds = new nk_rect();
			int state;
			if (((ctx == null) || (ctx.current == null)) || (ctx.current.layout == null)) return (int) (0);
			win = ctx.current;
			style = ctx.style;
			state = (int) (nk_widget_fitting(&bounds, ctx, (nk_vec2) (style.contextual_button.padding)));
			if (state == 0) return (int) (nk_false);
			_in_ = (((state) == (NK_WIDGET_ROM)) || ((win.layout.flags & NK_WINDOW_ROM) != 0)) ? null : ctx.input;
			if (
				(nk_do_button_text(ref ctx.last_widget_state, win.buffer, (nk_rect) (bounds), text, (int) (len), (uint) (alignment),
					(int) (NK_BUTTON_DEFAULT), style.contextual_button, _in_, style.font)) != 0)
			{
				nk_contextual_close(ctx);
				return (int) (nk_true);
			}

			return (int) (nk_false);
		}

		public static int nk_contextual_item_label(nk_context ctx, char* label, uint align)
		{
			return (int) (nk_contextual_item_text(ctx, label, (int) (nk_strlen(label)), (uint) (align)));
		}

		public static int nk_contextual_item_image_text(nk_context ctx, nk_image img, char* text, int len, uint align)
		{
			nk_window win;
			nk_input _in_;
			nk_style style;
			nk_rect bounds = new nk_rect();
			int state;
			if (((ctx == null) || (ctx.current == null)) || (ctx.current.layout == null)) return (int) (0);
			win = ctx.current;
			style = ctx.style;
			state = (int) (nk_widget_fitting(&bounds, ctx, (nk_vec2) (style.contextual_button.padding)));
			if (state == 0) return (int) (nk_false);
			_in_ = (((state) == (NK_WIDGET_ROM)) || ((win.layout.flags & NK_WINDOW_ROM) != 0)) ? null : ctx.input;
			if (
				(nk_do_button_text_image(ref ctx.last_widget_state, win.buffer, (nk_rect) (bounds), (nk_image) (img), text,
					(int) (len), (uint) (align), (int) (NK_BUTTON_DEFAULT), style.contextual_button, style.font, _in_)) != 0)
			{
				nk_contextual_close(ctx);
				return (int) (nk_true);
			}

			return (int) (nk_false);
		}

		public static int nk_contextual_item_image_label(nk_context ctx, nk_image img, char* label, uint align)
		{
			return (int) (nk_contextual_item_image_text(ctx, (nk_image) (img), label, (int) (nk_strlen(label)), (uint) (align)));
		}

		public static int nk_contextual_item_symbol_text(nk_context ctx, int symbol, char* text, int len, uint align)
		{
			nk_window win;
			nk_input _in_;
			nk_style style;
			nk_rect bounds = new nk_rect();
			int state;
			if (((ctx == null) || (ctx.current == null)) || (ctx.current.layout == null)) return (int) (0);
			win = ctx.current;
			style = ctx.style;
			state = (int) (nk_widget_fitting(&bounds, ctx, (nk_vec2) (style.contextual_button.padding)));
			if (state == 0) return (int) (nk_false);
			_in_ = (((state) == (NK_WIDGET_ROM)) || ((win.layout.flags & NK_WINDOW_ROM) != 0)) ? null : ctx.input;
			if (
				(nk_do_button_text_symbol(ref ctx.last_widget_state, win.buffer, (nk_rect) (bounds), (int) (symbol), text,
					(int) (len), (uint) (align), (int) (NK_BUTTON_DEFAULT), style.contextual_button, style.font, _in_)) != 0)
			{
				nk_contextual_close(ctx);
				return (int) (nk_true);
			}

			return (int) (nk_false);
		}

		public static int nk_contextual_item_symbol_label(nk_context ctx, int symbol, char* text, uint align)
		{
			return (int) (nk_contextual_item_symbol_text(ctx, (int) (symbol), text, (int) (nk_strlen(text)), (uint) (align)));
		}

		public static void nk_contextual_close(nk_context ctx)
		{
			if (((ctx == null) || (ctx.current == null)) || (ctx.current.layout == null)) return;
			nk_popup_close(ctx);
		}

		public static void nk_contextual_end(nk_context ctx)
		{
			nk_window popup;
			nk_panel panel;
			if ((ctx == null) || (ctx.current == null)) return;
			popup = ctx.current;
			panel = popup.layout;
			if ((panel.flags & NK_WINDOW_DYNAMIC) != 0)
			{
				nk_rect body = new nk_rect();
				if ((panel.at_y) < (panel.bounds.y + panel.bounds.h))
				{
					nk_vec2 padding = (nk_vec2) (nk_panel_get_padding(ctx.style, (int) (panel.type)));
					body = (nk_rect) (panel.bounds);
					body.y = (float) (panel.at_y + panel.footer_height + panel.border + padding.y + panel.row.height);
					body.h = (float) ((panel.bounds.y + panel.bounds.h) - body.y);
				}
				{
					int pressed = (int) (nk_input_is_mouse_pressed(ctx.input, (int) (NK_BUTTON_LEFT)));
					int in_body = (int) (nk_input_is_mouse_hovering_rect(ctx.input, (nk_rect) (body)));
					if (((pressed) != 0) && ((in_body) != 0)) popup.flags |= (uint) (NK_WINDOW_HIDDEN);
				}
			}

			if ((popup.flags & NK_WINDOW_HIDDEN) != 0) popup.seq = (uint) (0);
			nk_popup_end(ctx);
			return;
		}

		public static int nk_combo_begin(nk_context ctx, nk_window win, nk_vec2 size, int is_clicked, nk_rect header)
		{
			nk_window popup;
			int is_open = (int) (0);
			int is_active = (int) (0);
			nk_rect body = new nk_rect();
			uint hash;
			if (((ctx == null) || (ctx.current == null)) || (ctx.current.layout == null)) return (int) (0);
			popup = win.popup.win;
			body.x = (float) (header.x);
			body.w = (float) (size.x);
			body.y = (float) (header.y + header.h - ctx.style.window.combo_border);
			body.h = (float) (size.y);
			hash = (uint) (win.popup.combo_count++);
			is_open = (int) ((popup != null) ? nk_true : nk_false);
			is_active =
				(int) ((((popup) != null) && ((win.popup.name) == (hash))) && ((win.popup.type) == (NK_PANEL_COMBO)) ? 1 : 0);
			if ((((((is_clicked) != 0) && ((is_open) != 0)) && (is_active == 0)) || (((is_open) != 0) && (is_active == 0))) ||
			    (((is_open == 0) && (is_active == 0)) && (is_clicked == 0))) return (int) (0);
			if (
				nk_nonblock_begin(ctx, (uint) (0), (nk_rect) (body),
					(nk_rect)
						((((is_clicked) != 0) && ((is_open) != 0)) ? nk_rect_((float) (0), (float) (0), (float) (0), (float) (0)) : header),
					(int) (NK_PANEL_COMBO)) == 0) return (int) (0);
			win.popup.type = (int) (NK_PANEL_COMBO);
			win.popup.name = (uint) (hash);
			return (int) (1);
		}

		public static int nk_combo_begin_text(nk_context ctx, char* selected, int len, nk_vec2 size)
		{
			nk_input _in_;
			nk_window win;
			nk_style style;
			int s;
			int is_clicked = (int) (nk_false);
			nk_rect header = new nk_rect();
			nk_style_item background;
			nk_text text = new nk_text();
			if ((((ctx == null) || (ctx.current == null)) || (ctx.current.layout == null)) || (selected == null))
				return (int) (0);
			win = ctx.current;
			style = ctx.style;
			s = (int) (nk_widget(&header, ctx));
			if ((s) == (NK_WIDGET_INVALID)) return (int) (0);
			_in_ = (((win.layout.flags & NK_WINDOW_ROM) != 0) || ((s) == (NK_WIDGET_ROM))) ? null : ctx.input;
			if ((nk_button_behavior(ref ctx.last_widget_state, (nk_rect) (header), _in_, (int) (NK_BUTTON_DEFAULT))) != 0)
				is_clicked = (int) (nk_true);
			if ((ctx.last_widget_state & NK_WIDGET_STATE_ACTIVED) != 0)
			{
				background = style.combo.active;
				text.text = (nk_color) (style.combo.label_active);
			}
			else if ((ctx.last_widget_state & NK_WIDGET_STATE_HOVER) != 0)
			{
				background = style.combo.hover;
				text.text = (nk_color) (style.combo.label_hover);
			}
			else
			{
				background = style.combo.normal;
				text.text = (nk_color) (style.combo.label_normal);
			}

			if ((background.type) == (NK_STYLE_ITEM_IMAGE))
			{
				text.background = (nk_color) (nk_rgba((int) (0), (int) (0), (int) (0), (int) (0)));
				nk_draw_image(win.buffer, (nk_rect) (header), background.data.image, (nk_color) (nk_white));
			}
			else
			{
				text.background = (nk_color) (background.data.color);
				nk_fill_rect(win.buffer, (nk_rect) (header), (float) (style.combo.rounding), (nk_color) (background.data.color));
				nk_stroke_rect(win.buffer, (nk_rect) (header), (float) (style.combo.rounding), (float) (style.combo.border),
					(nk_color) (style.combo.border_color));
			}

			{
				nk_rect label = new nk_rect();
				nk_rect button = new nk_rect();
				nk_rect content = new nk_rect();
				int sym;
				if ((ctx.last_widget_state & NK_WIDGET_STATE_HOVER) != 0) sym = (int) (style.combo.sym_hover);
				else if ((is_clicked) != 0) sym = (int) (style.combo.sym_active);
				else sym = (int) (style.combo.sym_normal);
				button.w = (float) (header.h - 2*style.combo.button_padding.y);
				button.x = (float) ((header.x + header.w - header.h) - style.combo.button_padding.x);
				button.y = (float) (header.y + style.combo.button_padding.y);
				button.h = (float) (button.w);
				content.x = (float) (button.x + style.combo.button.padding.x);
				content.y = (float) (button.y + style.combo.button.padding.y);
				content.w = (float) (button.w - 2*style.combo.button.padding.x);
				content.h = (float) (button.h - 2*style.combo.button.padding.y);
				text.padding = (nk_vec2) (nk_vec2_((float) (0), (float) (0)));
				label.x = (float) (header.x + style.combo.content_padding.x);
				label.y = (float) (header.y + style.combo.content_padding.y);
				label.w = (float) (button.x - (style.combo.content_padding.x + style.combo.spacing.x) - label.x);
				label.h = (float) (header.h - 2*style.combo.content_padding.y);
				nk_widget_text(win.buffer, (nk_rect) (label), selected, (int) (len), &text, (uint) (NK_TEXT_LEFT), ctx.style.font);
				nk_draw_button_symbol(win.buffer, &button, &content, (uint) (ctx.last_widget_state), ctx.style.combo.button,
					(int) (sym), style.font);
			}

			return (int) (nk_combo_begin(ctx, win, (nk_vec2) (size), (int) (is_clicked), (nk_rect) (header)));
		}

		public static int nk_combo_begin_label(nk_context ctx, char* selected, nk_vec2 size)
		{
			return (int) (nk_combo_begin_text(ctx, selected, (int) (nk_strlen(selected)), (nk_vec2) (size)));
		}

		public static int nk_combo_begin_color(nk_context ctx, nk_color color, nk_vec2 size)
		{
			nk_window win;
			nk_style style;
			nk_input _in_;
			nk_rect header = new nk_rect();
			int is_clicked = (int) (nk_false);
			int s;
			nk_style_item background;
			if (((ctx == null) || (ctx.current == null)) || (ctx.current.layout == null)) return (int) (0);
			win = ctx.current;
			style = ctx.style;
			s = (int) (nk_widget(&header, ctx));
			if ((s) == (NK_WIDGET_INVALID)) return (int) (0);
			_in_ = (((win.layout.flags & NK_WINDOW_ROM) != 0) || ((s) == (NK_WIDGET_ROM))) ? null : ctx.input;
			if ((nk_button_behavior(ref ctx.last_widget_state, (nk_rect) (header), _in_, (int) (NK_BUTTON_DEFAULT))) != 0)
				is_clicked = (int) (nk_true);
			if ((ctx.last_widget_state & NK_WIDGET_STATE_ACTIVED) != 0) background = style.combo.active;
			else if ((ctx.last_widget_state & NK_WIDGET_STATE_HOVER) != 0) background = style.combo.hover;
			else background = style.combo.normal;
			if ((background.type) == (NK_STYLE_ITEM_IMAGE))
			{
				nk_draw_image(win.buffer, (nk_rect) (header), background.data.image, (nk_color) (nk_white));
			}
			else
			{
				nk_fill_rect(win.buffer, (nk_rect) (header), (float) (style.combo.rounding), (nk_color) (background.data.color));
				nk_stroke_rect(win.buffer, (nk_rect) (header), (float) (style.combo.rounding), (float) (style.combo.border),
					(nk_color) (style.combo.border_color));
			}

			{
				nk_rect content = new nk_rect();
				nk_rect button = new nk_rect();
				nk_rect bounds = new nk_rect();
				int sym;
				if ((ctx.last_widget_state & NK_WIDGET_STATE_HOVER) != 0) sym = (int) (style.combo.sym_hover);
				else if ((is_clicked) != 0) sym = (int) (style.combo.sym_active);
				else sym = (int) (style.combo.sym_normal);
				button.w = (float) (header.h - 2*style.combo.button_padding.y);
				button.x = (float) ((header.x + header.w - header.h) - style.combo.button_padding.x);
				button.y = (float) (header.y + style.combo.button_padding.y);
				button.h = (float) (button.w);
				content.x = (float) (button.x + style.combo.button.padding.x);
				content.y = (float) (button.y + style.combo.button.padding.y);
				content.w = (float) (button.w - 2*style.combo.button.padding.x);
				content.h = (float) (button.h - 2*style.combo.button.padding.y);
				bounds.h = (float) (header.h - 4*style.combo.content_padding.y);
				bounds.y = (float) (header.y + 2*style.combo.content_padding.y);
				bounds.x = (float) (header.x + 2*style.combo.content_padding.x);
				bounds.w = (float) ((button.x - (style.combo.content_padding.x + style.combo.spacing.x)) - bounds.x);
				nk_fill_rect(win.buffer, (nk_rect) (bounds), (float) (0), (nk_color) (color));
				nk_draw_button_symbol(win.buffer, &button, &content, (uint) (ctx.last_widget_state), ctx.style.combo.button,
					(int) (sym), style.font);
			}

			return (int) (nk_combo_begin(ctx, win, (nk_vec2) (size), (int) (is_clicked), (nk_rect) (header)));
		}

		public static int nk_combo_begin_symbol(nk_context ctx, int symbol, nk_vec2 size)
		{
			nk_window win;
			nk_style style;
			nk_input _in_;
			nk_rect header = new nk_rect();
			int is_clicked = (int) (nk_false);
			int s;
			nk_style_item background;
			nk_color sym_background = new nk_color();
			nk_color symbol_color = new nk_color();
			if (((ctx == null) || (ctx.current == null)) || (ctx.current.layout == null)) return (int) (0);
			win = ctx.current;
			style = ctx.style;
			s = (int) (nk_widget(&header, ctx));
			if ((s) == (NK_WIDGET_INVALID)) return (int) (0);
			_in_ = (((win.layout.flags & NK_WINDOW_ROM) != 0) || ((s) == (NK_WIDGET_ROM))) ? null : ctx.input;
			if ((nk_button_behavior(ref ctx.last_widget_state, (nk_rect) (header), _in_, (int) (NK_BUTTON_DEFAULT))) != 0)
				is_clicked = (int) (nk_true);
			if ((ctx.last_widget_state & NK_WIDGET_STATE_ACTIVED) != 0)
			{
				background = style.combo.active;
				symbol_color = (nk_color) (style.combo.symbol_active);
			}
			else if ((ctx.last_widget_state & NK_WIDGET_STATE_HOVER) != 0)
			{
				background = style.combo.hover;
				symbol_color = (nk_color) (style.combo.symbol_hover);
			}
			else
			{
				background = style.combo.normal;
				symbol_color = (nk_color) (style.combo.symbol_hover);
			}

			if ((background.type) == (NK_STYLE_ITEM_IMAGE))
			{
				sym_background = (nk_color) (nk_rgba((int) (0), (int) (0), (int) (0), (int) (0)));
				nk_draw_image(win.buffer, (nk_rect) (header), background.data.image, (nk_color) (nk_white));
			}
			else
			{
				sym_background = (nk_color) (background.data.color);
				nk_fill_rect(win.buffer, (nk_rect) (header), (float) (style.combo.rounding), (nk_color) (background.data.color));
				nk_stroke_rect(win.buffer, (nk_rect) (header), (float) (style.combo.rounding), (float) (style.combo.border),
					(nk_color) (style.combo.border_color));
			}

			{
				nk_rect bounds = new nk_rect();
				nk_rect content = new nk_rect();
				nk_rect button = new nk_rect();
				int sym;
				if ((ctx.last_widget_state & NK_WIDGET_STATE_HOVER) != 0) sym = (int) (style.combo.sym_hover);
				else if ((is_clicked) != 0) sym = (int) (style.combo.sym_active);
				else sym = (int) (style.combo.sym_normal);
				button.w = (float) (header.h - 2*style.combo.button_padding.y);
				button.x = (float) ((header.x + header.w - header.h) - style.combo.button_padding.y);
				button.y = (float) (header.y + style.combo.button_padding.y);
				button.h = (float) (button.w);
				content.x = (float) (button.x + style.combo.button.padding.x);
				content.y = (float) (button.y + style.combo.button.padding.y);
				content.w = (float) (button.w - 2*style.combo.button.padding.x);
				content.h = (float) (button.h - 2*style.combo.button.padding.y);
				bounds.h = (float) (header.h - 2*style.combo.content_padding.y);
				bounds.y = (float) (header.y + style.combo.content_padding.y);
				bounds.x = (float) (header.x + style.combo.content_padding.x);
				bounds.w = (float) ((button.x - style.combo.content_padding.y) - bounds.x);
				nk_draw_symbol(win.buffer, (int) (symbol), (nk_rect) (bounds), (nk_color) (sym_background),
					(nk_color) (symbol_color), (float) (1.0f), style.font);
				nk_draw_button_symbol(win.buffer, &bounds, &content, (uint) (ctx.last_widget_state), ctx.style.combo.button,
					(int) (sym), style.font);
			}

			return (int) (nk_combo_begin(ctx, win, (nk_vec2) (size), (int) (is_clicked), (nk_rect) (header)));
		}

		public static int nk_combo_begin_symbol_text(nk_context ctx, char* selected, int len, int symbol, nk_vec2 size)
		{
			nk_window win;
			nk_style style;
			nk_input _in_;
			nk_rect header = new nk_rect();
			int is_clicked = (int) (nk_false);
			int s;
			nk_style_item background;
			nk_color symbol_color = new nk_color();
			nk_text text = new nk_text();
			if (((ctx == null) || (ctx.current == null)) || (ctx.current.layout == null)) return (int) (0);
			win = ctx.current;
			style = ctx.style;
			s = (int) (nk_widget(&header, ctx));
			if (s == 0) return (int) (0);
			_in_ = (((win.layout.flags & NK_WINDOW_ROM) != 0) || ((s) == (NK_WIDGET_ROM))) ? null : ctx.input;
			if ((nk_button_behavior(ref ctx.last_widget_state, (nk_rect) (header), _in_, (int) (NK_BUTTON_DEFAULT))) != 0)
				is_clicked = (int) (nk_true);
			if ((ctx.last_widget_state & NK_WIDGET_STATE_ACTIVED) != 0)
			{
				background = style.combo.active;
				symbol_color = (nk_color) (style.combo.symbol_active);
				text.text = (nk_color) (style.combo.label_active);
			}
			else if ((ctx.last_widget_state & NK_WIDGET_STATE_HOVER) != 0)
			{
				background = style.combo.hover;
				symbol_color = (nk_color) (style.combo.symbol_hover);
				text.text = (nk_color) (style.combo.label_hover);
			}
			else
			{
				background = style.combo.normal;
				symbol_color = (nk_color) (style.combo.symbol_normal);
				text.text = (nk_color) (style.combo.label_normal);
			}

			if ((background.type) == (NK_STYLE_ITEM_IMAGE))
			{
				text.background = (nk_color) (nk_rgba((int) (0), (int) (0), (int) (0), (int) (0)));
				nk_draw_image(win.buffer, (nk_rect) (header), background.data.image, (nk_color) (nk_white));
			}
			else
			{
				text.background = (nk_color) (background.data.color);
				nk_fill_rect(win.buffer, (nk_rect) (header), (float) (style.combo.rounding), (nk_color) (background.data.color));
				nk_stroke_rect(win.buffer, (nk_rect) (header), (float) (style.combo.rounding), (float) (style.combo.border),
					(nk_color) (style.combo.border_color));
			}

			{
				nk_rect content = new nk_rect();
				nk_rect button = new nk_rect();
				nk_rect label = new nk_rect();
				nk_rect image = new nk_rect();
				int sym;
				if ((ctx.last_widget_state & NK_WIDGET_STATE_HOVER) != 0) sym = (int) (style.combo.sym_hover);
				else if ((is_clicked) != 0) sym = (int) (style.combo.sym_active);
				else sym = (int) (style.combo.sym_normal);
				button.w = (float) (header.h - 2*style.combo.button_padding.y);
				button.x = (float) ((header.x + header.w - header.h) - style.combo.button_padding.x);
				button.y = (float) (header.y + style.combo.button_padding.y);
				button.h = (float) (button.w);
				content.x = (float) (button.x + style.combo.button.padding.x);
				content.y = (float) (button.y + style.combo.button.padding.y);
				content.w = (float) (button.w - 2*style.combo.button.padding.x);
				content.h = (float) (button.h - 2*style.combo.button.padding.y);
				nk_draw_button_symbol(win.buffer, &button, &content, (uint) (ctx.last_widget_state), ctx.style.combo.button,
					(int) (sym), style.font);
				image.x = (float) (header.x + style.combo.content_padding.x);
				image.y = (float) (header.y + style.combo.content_padding.y);
				image.h = (float) (header.h - 2*style.combo.content_padding.y);
				image.w = (float) (image.h);
				nk_draw_symbol(win.buffer, (int) (symbol), (nk_rect) (image), (nk_color) (text.background),
					(nk_color) (symbol_color), (float) (1.0f), style.font);
				text.padding = (nk_vec2) (nk_vec2_((float) (0), (float) (0)));
				label.x = (float) (image.x + image.w + style.combo.spacing.x + style.combo.content_padding.x);
				label.y = (float) (header.y + style.combo.content_padding.y);
				label.w = (float) ((button.x - style.combo.content_padding.x) - label.x);
				label.h = (float) (header.h - 2*style.combo.content_padding.y);
				nk_widget_text(win.buffer, (nk_rect) (label), selected, (int) (len), &text, (uint) (NK_TEXT_LEFT), style.font);
			}

			return (int) (nk_combo_begin(ctx, win, (nk_vec2) (size), (int) (is_clicked), (nk_rect) (header)));
		}

		public static int nk_combo_begin_image(nk_context ctx, nk_image img, nk_vec2 size)
		{
			nk_window win;
			nk_style style;
			nk_input _in_;
			nk_rect header = new nk_rect();
			int is_clicked = (int) (nk_false);
			int s;
			nk_style_item background;
			if (((ctx == null) || (ctx.current == null)) || (ctx.current.layout == null)) return (int) (0);
			win = ctx.current;
			style = ctx.style;
			s = (int) (nk_widget(&header, ctx));
			if ((s) == (NK_WIDGET_INVALID)) return (int) (0);
			_in_ = (((win.layout.flags & NK_WINDOW_ROM) != 0) || ((s) == (NK_WIDGET_ROM))) ? null : ctx.input;
			if ((nk_button_behavior(ref ctx.last_widget_state, (nk_rect) (header), _in_, (int) (NK_BUTTON_DEFAULT))) != 0)
				is_clicked = (int) (nk_true);
			if ((ctx.last_widget_state & NK_WIDGET_STATE_ACTIVED) != 0) background = style.combo.active;
			else if ((ctx.last_widget_state & NK_WIDGET_STATE_HOVER) != 0) background = style.combo.hover;
			else background = style.combo.normal;
			if ((background.type) == (NK_STYLE_ITEM_IMAGE))
			{
				nk_draw_image(win.buffer, (nk_rect) (header), background.data.image, (nk_color) (nk_white));
			}
			else
			{
				nk_fill_rect(win.buffer, (nk_rect) (header), (float) (style.combo.rounding), (nk_color) (background.data.color));
				nk_stroke_rect(win.buffer, (nk_rect) (header), (float) (style.combo.rounding), (float) (style.combo.border),
					(nk_color) (style.combo.border_color));
			}

			{
				nk_rect bounds = new nk_rect();
				nk_rect content = new nk_rect();
				nk_rect button = new nk_rect();
				int sym;
				if ((ctx.last_widget_state & NK_WIDGET_STATE_HOVER) != 0) sym = (int) (style.combo.sym_hover);
				else if ((is_clicked) != 0) sym = (int) (style.combo.sym_active);
				else sym = (int) (style.combo.sym_normal);
				button.w = (float) (header.h - 2*style.combo.button_padding.y);
				button.x = (float) ((header.x + header.w - header.h) - style.combo.button_padding.y);
				button.y = (float) (header.y + style.combo.button_padding.y);
				button.h = (float) (button.w);
				content.x = (float) (button.x + style.combo.button.padding.x);
				content.y = (float) (button.y + style.combo.button.padding.y);
				content.w = (float) (button.w - 2*style.combo.button.padding.x);
				content.h = (float) (button.h - 2*style.combo.button.padding.y);
				bounds.h = (float) (header.h - 2*style.combo.content_padding.y);
				bounds.y = (float) (header.y + style.combo.content_padding.y);
				bounds.x = (float) (header.x + style.combo.content_padding.x);
				bounds.w = (float) ((button.x - style.combo.content_padding.y) - bounds.x);
				nk_draw_image(win.buffer, (nk_rect) (bounds), img, (nk_color) (nk_white));
				nk_draw_button_symbol(win.buffer, &bounds, &content, (uint) (ctx.last_widget_state), ctx.style.combo.button,
					(int) (sym), style.font);
			}

			return (int) (nk_combo_begin(ctx, win, (nk_vec2) (size), (int) (is_clicked), (nk_rect) (header)));
		}

		public static int nk_combo_begin_image_text(nk_context ctx, char* selected, int len, nk_image img, nk_vec2 size)
		{
			nk_window win;
			nk_style style;
			nk_input _in_;
			nk_rect header = new nk_rect();
			int is_clicked = (int) (nk_false);
			int s;
			nk_style_item background;
			nk_text text = new nk_text();
			if (((ctx == null) || (ctx.current == null)) || (ctx.current.layout == null)) return (int) (0);
			win = ctx.current;
			style = ctx.style;
			s = (int) (nk_widget(&header, ctx));
			if (s == 0) return (int) (0);
			_in_ = (((win.layout.flags & NK_WINDOW_ROM) != 0) || ((s) == (NK_WIDGET_ROM))) ? null : ctx.input;
			if ((nk_button_behavior(ref ctx.last_widget_state, (nk_rect) (header), _in_, (int) (NK_BUTTON_DEFAULT))) != 0)
				is_clicked = (int) (nk_true);
			if ((ctx.last_widget_state & NK_WIDGET_STATE_ACTIVED) != 0)
			{
				background = style.combo.active;
				text.text = (nk_color) (style.combo.label_active);
			}
			else if ((ctx.last_widget_state & NK_WIDGET_STATE_HOVER) != 0)
			{
				background = style.combo.hover;
				text.text = (nk_color) (style.combo.label_hover);
			}
			else
			{
				background = style.combo.normal;
				text.text = (nk_color) (style.combo.label_normal);
			}

			if ((background.type) == (NK_STYLE_ITEM_IMAGE))
			{
				text.background = (nk_color) (nk_rgba((int) (0), (int) (0), (int) (0), (int) (0)));
				nk_draw_image(win.buffer, (nk_rect) (header), background.data.image, (nk_color) (nk_white));
			}
			else
			{
				text.background = (nk_color) (background.data.color);
				nk_fill_rect(win.buffer, (nk_rect) (header), (float) (style.combo.rounding), (nk_color) (background.data.color));
				nk_stroke_rect(win.buffer, (nk_rect) (header), (float) (style.combo.rounding), (float) (style.combo.border),
					(nk_color) (style.combo.border_color));
			}

			{
				nk_rect content = new nk_rect();
				nk_rect button = new nk_rect();
				nk_rect label = new nk_rect();
				nk_rect image = new nk_rect();
				int sym;
				if ((ctx.last_widget_state & NK_WIDGET_STATE_HOVER) != 0) sym = (int) (style.combo.sym_hover);
				else if ((is_clicked) != 0) sym = (int) (style.combo.sym_active);
				else sym = (int) (style.combo.sym_normal);
				button.w = (float) (header.h - 2*style.combo.button_padding.y);
				button.x = (float) ((header.x + header.w - header.h) - style.combo.button_padding.x);
				button.y = (float) (header.y + style.combo.button_padding.y);
				button.h = (float) (button.w);
				content.x = (float) (button.x + style.combo.button.padding.x);
				content.y = (float) (button.y + style.combo.button.padding.y);
				content.w = (float) (button.w - 2*style.combo.button.padding.x);
				content.h = (float) (button.h - 2*style.combo.button.padding.y);
				nk_draw_button_symbol(win.buffer, &button, &content, (uint) (ctx.last_widget_state), ctx.style.combo.button,
					(int) (sym), style.font);
				image.x = (float) (header.x + style.combo.content_padding.x);
				image.y = (float) (header.y + style.combo.content_padding.y);
				image.h = (float) (header.h - 2*style.combo.content_padding.y);
				image.w = (float) (image.h);
				nk_draw_image(win.buffer, (nk_rect) (image), img, (nk_color) (nk_white));
				text.padding = (nk_vec2) (nk_vec2_((float) (0), (float) (0)));
				label.x = (float) (image.x + image.w + style.combo.spacing.x + style.combo.content_padding.x);
				label.y = (float) (header.y + style.combo.content_padding.y);
				label.w = (float) ((button.x - style.combo.content_padding.x) - label.x);
				label.h = (float) (header.h - 2*style.combo.content_padding.y);
				nk_widget_text(win.buffer, (nk_rect) (label), selected, (int) (len), &text, (uint) (NK_TEXT_LEFT), style.font);
			}

			return (int) (nk_combo_begin(ctx, win, (nk_vec2) (size), (int) (is_clicked), (nk_rect) (header)));
		}

		public static int nk_combo_begin_symbol_label(nk_context ctx, char* selected, int type, nk_vec2 size)
		{
			return (int) (nk_combo_begin_symbol_text(ctx, selected, (int) (nk_strlen(selected)), (int) (type), (nk_vec2) (size)));
		}

		public static int nk_combo_begin_image_label(nk_context ctx, char* selected, nk_image img, nk_vec2 size)
		{
			return
				(int) (nk_combo_begin_image_text(ctx, selected, (int) (nk_strlen(selected)), (nk_image) (img), (nk_vec2) (size)));
		}

		public static int nk_combo_item_text(nk_context ctx, char* text, int len, uint align)
		{
			return (int) (nk_contextual_item_text(ctx, text, (int) (len), (uint) (align)));
		}

		public static int nk_combo_item_label(nk_context ctx, char* label, uint align)
		{
			return (int) (nk_contextual_item_label(ctx, label, (uint) (align)));
		}

		public static int nk_combo_item_image_text(nk_context ctx, nk_image img, char* text, int len, uint alignment)
		{
			return (int) (nk_contextual_item_image_text(ctx, (nk_image) (img), text, (int) (len), (uint) (alignment)));
		}

		public static int nk_combo_item_image_label(nk_context ctx, nk_image img, char* text, uint alignment)
		{
			return (int) (nk_contextual_item_image_label(ctx, (nk_image) (img), text, (uint) (alignment)));
		}

		public static int nk_combo_item_symbol_text(nk_context ctx, int sym, char* text, int len, uint alignment)
		{
			return (int) (nk_contextual_item_symbol_text(ctx, (int) (sym), text, (int) (len), (uint) (alignment)));
		}

		public static int nk_combo_item_symbol_label(nk_context ctx, int sym, char* label, uint alignment)
		{
			return (int) (nk_contextual_item_symbol_label(ctx, (int) (sym), label, (uint) (alignment)));
		}

		public static void nk_combo_end(nk_context ctx)
		{
			nk_contextual_end(ctx);
		}

		public static void nk_combo_close(nk_context ctx)
		{
			nk_contextual_close(ctx);
		}

		public static int nk_combo(nk_context ctx, char** items, int count, int selected, int item_height, nk_vec2 size)
		{
			int i = (int) (0);
			int max_height;
			nk_vec2 item_spacing = new nk_vec2();
			nk_vec2 window_padding = new nk_vec2();
			if (((ctx == null) || (items == null)) || (count == 0)) return (int) (selected);
			item_spacing = (nk_vec2) (ctx.style.window.spacing);
			window_padding = (nk_vec2) (nk_panel_get_padding(ctx.style, (int) (ctx.current.layout.type)));
			max_height = (int) (count*item_height + count*(int) (item_spacing.y));
			max_height += (int) ((int) (item_spacing.y)*2 + (int) (window_padding.y)*2);
			size.y = (float) ((size.y) < ((float) (max_height)) ? (size.y) : ((float) (max_height)));
			if ((nk_combo_begin_label(ctx, items[selected], (nk_vec2) (size))) != 0)
			{
				nk_layout_row_dynamic(ctx, (float) (item_height), (int) (1));
				for (i = (int) (0); (i) < (count); ++i)
				{
					if ((nk_combo_item_label(ctx, items[i], (uint) (NK_TEXT_LEFT))) != 0) selected = (int) (i);
				}
				nk_combo_end(ctx);
			}

			return (int) (selected);
		}

		public static int nk_combo_separator(nk_context ctx, char* items_separated_by_separator, int separator, int selected,
			int count, int item_height, nk_vec2 size)
		{
			int i;
			int max_height;
			nk_vec2 item_spacing = new nk_vec2();
			nk_vec2 window_padding = new nk_vec2();
			char* current_item;
			char* iter;
			;
			int length = (int) (0);
			if ((ctx == null) || (items_separated_by_separator == null)) return (int) (selected);
			item_spacing = (nk_vec2) (ctx.style.window.spacing);
			window_padding = (nk_vec2) (nk_panel_get_padding(ctx.style, (int) (ctx.current.layout.type)));
			max_height = (int) (count*item_height + count*(int) (item_spacing.y));
			max_height += (int) ((int) (item_spacing.y)*2 + (int) (window_padding.y)*2);
			size.y = (float) ((size.y) < ((float) (max_height)) ? (size.y) : ((float) (max_height)));
			current_item = items_separated_by_separator;
			for (i = (int) (0); (i) < (count); ++i)
			{
				iter = current_item;
				while (((*iter) != 0) && (*iter != separator))
				{
					iter++;
				}
				length = ((int) (iter - current_item));
				if ((i) == (selected)) break;
				current_item = iter + 1;
			}
			if ((nk_combo_begin_text(ctx, current_item, (int) (length), (nk_vec2) (size))) != 0)
			{
				current_item = items_separated_by_separator;
				nk_layout_row_dynamic(ctx, (float) (item_height), (int) (1));
				for (i = (int) (0); (i) < (count); ++i)
				{
					iter = current_item;
					while (((*iter) != 0) && (*iter != separator))
					{
						iter++;
					}
					length = ((int) (iter - current_item));
					if ((nk_combo_item_text(ctx, current_item, (int) (length), (uint) (NK_TEXT_LEFT))) != 0) selected = (int) (i);
					current_item = current_item + length + 1;
				}
				nk_combo_end(ctx);
			}

			return (int) (selected);
		}

		public static int nk_combo_string(nk_context ctx, char* items_separated_by_zeros, int selected, int count,
			int item_height, nk_vec2 size)
		{
			return
				(int)
					(nk_combo_separator(ctx, items_separated_by_zeros, (int) ('\0'), (int) (selected), (int) (count),
						(int) (item_height), (nk_vec2) (size)));
		}

		public static int nk_combo_callback(nk_context ctx, NkComboCallback item_getter, void* userdata, int selected,
			int count, int item_height, nk_vec2 size)
		{
			int i;
			int max_height;
			nk_vec2 item_spacing = new nk_vec2();
			nk_vec2 window_padding = new nk_vec2();
			char* item;
			if ((ctx == null) || (item_getter == null)) return (int) (selected);
			item_spacing = (nk_vec2) (ctx.style.window.spacing);
			window_padding = (nk_vec2) (nk_panel_get_padding(ctx.style, (int) (ctx.current.layout.type)));
			max_height = (int) (count*item_height + count*(int) (item_spacing.y));
			max_height += (int) ((int) (item_spacing.y)*2 + (int) (window_padding.y)*2);
			size.y = (float) ((size.y) < ((float) (max_height)) ? (size.y) : ((float) (max_height)));
			item_getter(userdata, (int) (selected), &item);
			if ((nk_combo_begin_label(ctx, item, (nk_vec2) (size))) != 0)
			{
				nk_layout_row_dynamic(ctx, (float) (item_height), (int) (1));
				for (i = (int) (0); (i) < (count); ++i)
				{
					item_getter(userdata, (int) (i), &item);
					if ((nk_combo_item_label(ctx, item, (uint) (NK_TEXT_LEFT))) != 0) selected = (int) (i);
				}
				nk_combo_end(ctx);
			}

			return (int) (selected);
		}

		public static void nk_combobox(nk_context ctx, char** items, int count, int* selected, int item_height, nk_vec2 size)
		{
			*selected = (int) (nk_combo(ctx, items, (int) (count), (int) (*selected), (int) (item_height), (nk_vec2) (size)));
		}

		public static void nk_combobox_string(nk_context ctx, char* items_separated_by_zeros, int* selected, int count,
			int item_height, nk_vec2 size)
		{
			*selected =
				(int)
					(nk_combo_string(ctx, items_separated_by_zeros, (int) (*selected), (int) (count), (int) (item_height),
						(nk_vec2) (size)));
		}

		public static void nk_combobox_separator(nk_context ctx, char* items_separated_by_separator, int separator,
			int* selected, int count, int item_height, nk_vec2 size)
		{
			*selected =
				(int)
					(nk_combo_separator(ctx, items_separated_by_separator, (int) (separator), (int) (*selected), (int) (count),
						(int) (item_height), (nk_vec2) (size)));
		}

		public static void nk_combobox_callback(nk_context ctx, NkComboCallback item_getter, void* userdata, int* selected,
			int count, int item_height, nk_vec2 size)
		{
			*selected =
				(int)
					(nk_combo_callback(ctx, item_getter, userdata, (int) (*selected), (int) (count), (int) (item_height),
						(nk_vec2) (size)));
		}

		public static int nk_menu_begin(nk_context ctx, nk_window win, char* id, int is_clicked, nk_rect header, nk_vec2 size)
		{
			int is_open = (int) (0);
			int is_active = (int) (0);
			nk_rect body = new nk_rect();
			nk_window popup;
			uint hash = (uint) (nk_murmur_hash(id, (int) (nk_strlen(id)), (uint) (NK_PANEL_MENU)));
			if (((ctx == null) || (ctx.current == null)) || (ctx.current.layout == null)) return (int) (0);
			body.x = (float) (header.x);
			body.w = (float) (size.x);
			body.y = (float) (header.y + header.h);
			body.h = (float) (size.y);
			popup = win.popup.win;
			is_open = (int) (popup != null ? nk_true : nk_false);
			is_active =
				(int) ((((popup) != null) && ((win.popup.name) == (hash))) && ((win.popup.type) == (NK_PANEL_MENU)) ? 1 : 0);
			if ((((((is_clicked) != 0) && ((is_open) != 0)) && (is_active == 0)) || (((is_open) != 0) && (is_active == 0))) ||
			    (((is_open == 0) && (is_active == 0)) && (is_clicked == 0))) return (int) (0);
			if (
				nk_nonblock_begin(ctx, (uint) (NK_WINDOW_NO_SCROLLBAR), (nk_rect) (body), (nk_rect) (header), (int) (NK_PANEL_MENU)) ==
				0) return (int) (0);
			win.popup.type = (int) (NK_PANEL_MENU);
			win.popup.name = (uint) (hash);
			return (int) (1);
		}

		public static int nk_menu_begin_text(nk_context ctx, char* title, int len, uint align, nk_vec2 size)
		{
			nk_window win;
			nk_input _in_;
			nk_rect header = new nk_rect();
			int is_clicked = (int) (nk_false);
			uint state;
			if (((ctx == null) || (ctx.current == null)) || (ctx.current.layout == null)) return (int) (0);
			win = ctx.current;
			state = (uint) (nk_widget(&header, ctx));
			if (state == 0) return (int) (0);
			_in_ = (((state) == (NK_WIDGET_ROM)) || ((win.flags & NK_WINDOW_ROM) != 0)) ? null : ctx.input;
			if (
				(nk_do_button_text(ref ctx.last_widget_state, win.buffer, (nk_rect) (header), title, (int) (len), (uint) (align),
					(int) (NK_BUTTON_DEFAULT), ctx.style.menu_button, _in_, ctx.style.font)) != 0) is_clicked = (int) (nk_true);
			return (int) (nk_menu_begin(ctx, win, title, (int) (is_clicked), (nk_rect) (header), (nk_vec2) (size)));
		}

		public static int nk_menu_begin_label(nk_context ctx, char* text, uint align, nk_vec2 size)
		{
			return (int) (nk_menu_begin_text(ctx, text, (int) (nk_strlen(text)), (uint) (align), (nk_vec2) (size)));
		}

		public static int nk_menu_begin_image(nk_context ctx, char* id, nk_image img, nk_vec2 size)
		{
			nk_window win;
			nk_rect header = new nk_rect();
			nk_input _in_;
			int is_clicked = (int) (nk_false);
			uint state;
			if (((ctx == null) || (ctx.current == null)) || (ctx.current.layout == null)) return (int) (0);
			win = ctx.current;
			state = (uint) (nk_widget(&header, ctx));
			if (state == 0) return (int) (0);
			_in_ = (((state) == (NK_WIDGET_ROM)) || ((win.layout.flags & NK_WINDOW_ROM) != 0)) ? null : ctx.input;
			if (
				(nk_do_button_image(ref ctx.last_widget_state, win.buffer, (nk_rect) (header), (nk_image) (img),
					(int) (NK_BUTTON_DEFAULT), ctx.style.menu_button, _in_)) != 0) is_clicked = (int) (nk_true);
			return (int) (nk_menu_begin(ctx, win, id, (int) (is_clicked), (nk_rect) (header), (nk_vec2) (size)));
		}

		public static int nk_menu_begin_symbol(nk_context ctx, char* id, int sym, nk_vec2 size)
		{
			nk_window win;
			nk_input _in_;
			nk_rect header = new nk_rect();
			int is_clicked = (int) (nk_false);
			uint state;
			if (((ctx == null) || (ctx.current == null)) || (ctx.current.layout == null)) return (int) (0);
			win = ctx.current;
			state = (uint) (nk_widget(&header, ctx));
			if (state == 0) return (int) (0);
			_in_ = (((state) == (NK_WIDGET_ROM)) || ((win.layout.flags & NK_WINDOW_ROM) != 0)) ? null : ctx.input;
			if (
				(nk_do_button_symbol(ref ctx.last_widget_state, win.buffer, (nk_rect) (header), (int) (sym),
					(int) (NK_BUTTON_DEFAULT), ctx.style.menu_button, _in_, ctx.style.font)) != 0) is_clicked = (int) (nk_true);
			return (int) (nk_menu_begin(ctx, win, id, (int) (is_clicked), (nk_rect) (header), (nk_vec2) (size)));
		}

		public static int nk_menu_begin_image_text(nk_context ctx, char* title, int len, uint align, nk_image img,
			nk_vec2 size)
		{
			nk_window win;
			nk_rect header = new nk_rect();
			nk_input _in_;
			int is_clicked = (int) (nk_false);
			uint state;
			if (((ctx == null) || (ctx.current == null)) || (ctx.current.layout == null)) return (int) (0);
			win = ctx.current;
			state = (uint) (nk_widget(&header, ctx));
			if (state == 0) return (int) (0);
			_in_ = (((state) == (NK_WIDGET_ROM)) || ((win.layout.flags & NK_WINDOW_ROM) != 0)) ? null : ctx.input;
			if (
				(nk_do_button_text_image(ref ctx.last_widget_state, win.buffer, (nk_rect) (header), (nk_image) (img), title,
					(int) (len), (uint) (align), (int) (NK_BUTTON_DEFAULT), ctx.style.menu_button, ctx.style.font, _in_)) != 0)
				is_clicked = (int) (nk_true);
			return (int) (nk_menu_begin(ctx, win, title, (int) (is_clicked), (nk_rect) (header), (nk_vec2) (size)));
		}

		public static int nk_menu_begin_image_label(nk_context ctx, char* title, uint align, nk_image img, nk_vec2 size)
		{
			return
				(int)
					(nk_menu_begin_image_text(ctx, title, (int) (nk_strlen(title)), (uint) (align), (nk_image) (img), (nk_vec2) (size)));
		}

		public static int nk_menu_begin_symbol_text(nk_context ctx, char* title, int len, uint align, int sym, nk_vec2 size)
		{
			nk_window win;
			nk_rect header = new nk_rect();
			nk_input _in_;
			int is_clicked = (int) (nk_false);
			uint state;
			if (((ctx == null) || (ctx.current == null)) || (ctx.current.layout == null)) return (int) (0);
			win = ctx.current;
			state = (uint) (nk_widget(&header, ctx));
			if (state == 0) return (int) (0);
			_in_ = (((state) == (NK_WIDGET_ROM)) || ((win.layout.flags & NK_WINDOW_ROM) != 0)) ? null : ctx.input;
			if (
				(nk_do_button_text_symbol(ref ctx.last_widget_state, win.buffer, (nk_rect) (header), (int) (sym), title, (int) (len),
					(uint) (align), (int) (NK_BUTTON_DEFAULT), ctx.style.menu_button, ctx.style.font, _in_)) != 0)
				is_clicked = (int) (nk_true);
			return (int) (nk_menu_begin(ctx, win, title, (int) (is_clicked), (nk_rect) (header), (nk_vec2) (size)));
		}

		public static int nk_menu_begin_symbol_label(nk_context ctx, char* title, uint align, int sym, nk_vec2 size)
		{
			return
				(int)
					(nk_menu_begin_symbol_text(ctx, title, (int) (nk_strlen(title)), (uint) (align), (int) (sym), (nk_vec2) (size)));
		}

		public static int nk_menu_item_text(nk_context ctx, char* title, int len, uint align)
		{
			return (int) (nk_contextual_item_text(ctx, title, (int) (len), (uint) (align)));
		}

		public static int nk_menu_item_label(nk_context ctx, char* label, uint align)
		{
			return (int) (nk_contextual_item_label(ctx, label, (uint) (align)));
		}

		public static int nk_menu_item_image_label(nk_context ctx, nk_image img, char* label, uint align)
		{
			return (int) (nk_contextual_item_image_label(ctx, (nk_image) (img), label, (uint) (align)));
		}

		public static int nk_menu_item_image_text(nk_context ctx, nk_image img, char* text, int len, uint align)
		{
			return (int) (nk_contextual_item_image_text(ctx, (nk_image) (img), text, (int) (len), (uint) (align)));
		}

		public static int nk_menu_item_symbol_text(nk_context ctx, int sym, char* text, int len, uint align)
		{
			return (int) (nk_contextual_item_symbol_text(ctx, (int) (sym), text, (int) (len), (uint) (align)));
		}

		public static int nk_menu_item_symbol_label(nk_context ctx, int sym, char* label, uint align)
		{
			return (int) (nk_contextual_item_symbol_label(ctx, (int) (sym), label, (uint) (align)));
		}

		public static void nk_menu_close(nk_context ctx)
		{
			nk_contextual_close(ctx);
		}

		public static void nk_menu_end(nk_context ctx)
		{
			nk_contextual_end(ctx);
		}

		public static int nk_string_float_limit(string _string_)
		{
			fixed (char* ptr = _string_)
			{
				return nk_string_float_limit(ptr, (int) _string_.Length);
			}
		}

		public static int nk_text_clamp(nk_user_font font, string text, float space, int* glyphs, float* text_width,
			uint* sep_list, int sep_count)
		{
			fixed (char* ptr = text)
			{
				return nk_text_clamp(font, ptr, (int) text.Length, space, glyphs, text_width, sep_list, sep_count);
			}
		}

		public static nk_vec2 nk_text_calculate_text_bounds(nk_user_font font, string begin, float row_height,
			char** remaining, nk_vec2* out_offset, int* glyphs, int op)
		{
			fixed (char* ptr = begin)
			{
				return nk_text_calculate_text_bounds(font, ptr, (int) begin.Length, row_height, remaining, out_offset, glyphs, op);
			}
		}

		public static int nk_str_append_text_char(nk_str s, string str)
		{
			fixed (char* ptr = str)
			{
				return nk_str_append_text_char(s, ptr, (int) str.Length);
			}
		}

		public static int nk_str_append_text_utf8(nk_str str, string text)
		{
			fixed (char* ptr = text)
			{
				return nk_str_append_text_utf8(str, ptr, (int) text.Length);
			}
		}

		public static int nk_str_insert_at_char(nk_str s, int pos, string str)
		{
			fixed (char* ptr = str)
			{
				return nk_str_insert_at_char(s, pos, ptr, (int) str.Length);
			}
		}

		public static int nk_str_insert_at_rune(nk_str str, int pos, string cstr)
		{
			fixed (char* ptr = cstr)
			{
				return nk_str_insert_at_rune(str, pos, ptr, (int) cstr.Length);
			}
		}

		public static int nk_str_insert_text_char(nk_str str, int pos, string text)
		{
			fixed (char* ptr = text)
			{
				return nk_str_insert_text_char(str, pos, ptr, (int) text.Length);
			}
		}

		public static int nk_str_insert_text_utf8(nk_str str, int pos, string text)
		{
			fixed (char* ptr = text)
			{
				return nk_str_insert_text_utf8(str, pos, ptr, (int) text.Length);
			}
		}

		public static void nk_draw_text(nk_command_buffer b, nk_rect r, string _string_, nk_user_font font, nk_color bg,
			nk_color fg)
		{
			fixed (char* ptr = _string_)
			{
				nk_draw_text(b, r, ptr, (int) _string_.Length, font, bg, fg);
			}
		}

		public static void nk_draw_list_add_text(nk_draw_list list, nk_user_font font, nk_rect rect, string text,
			float font_height, nk_color fg)
		{
			fixed (char* ptr = text)
			{
				nk_draw_list_add_text(list, font, rect, ptr, (int) text.Length, font_height, fg);
			}
		}

		public static void nk_font_bake_custom_data(void* img_memory, int img_width, int img_height, nk_recti img_dst,
			string texture_data_mask, int tex_height, char white, char black)
		{
			fixed (char* ptr = texture_data_mask)
			{
				nk_font_bake_custom_data(img_memory, img_width, img_height, img_dst, ptr, (int) texture_data_mask.Length, tex_height,
					white, black);
			}
		}

		public static float nk_font_text_width(nk_font font, float height, string text)
		{
			fixed (char* ptr = text)
			{
				return nk_font_text_width(font, height, ptr, (int) text.Length);
			}
		}

		public static int nk_textedit_paste(nk_text_edit state, string ctext)
		{
			fixed (char* ptr = ctext)
			{
				return nk_textedit_paste(state, ptr, (int) ctext.Length);
			}
		}

		public static void nk_textedit_text(nk_text_edit state, string text)
		{
			fixed (char* ptr = text)
			{
				nk_textedit_text(state, ptr, (int) text.Length);
			}
		}

		public static void nk_widget_text(nk_command_buffer o, nk_rect b, string _string_, nk_text* t, uint a, nk_user_font f)
		{
			fixed (char* ptr = _string_)
			{
				nk_widget_text(o, b, ptr, (int) _string_.Length, t, a, f);
			}
		}

		public static void nk_widget_text_wrap(nk_command_buffer o, nk_rect b, string _string_, nk_text* t, nk_user_font f)
		{
			fixed (char* ptr = _string_)
			{
				nk_widget_text_wrap(o, b, ptr, (int) _string_.Length, t, f);
			}
		}

		public static void nk_draw_button_text(nk_command_buffer _out_, nk_rect* bounds, nk_rect* content, uint state,
			nk_style_button style, string txt, uint text_alignment, nk_user_font font)
		{
			fixed (char* ptr = txt)
			{
				nk_draw_button_text(_out_, bounds, content, state, style, ptr, (int) txt.Length, text_alignment, font);
			}
		}

		public static int nk_do_button_text(ref uint state, nk_command_buffer _out_, nk_rect bounds, string _string_,
			uint align, int behavior, nk_style_button style, nk_input _in_, nk_user_font font)
		{
			fixed (char* ptr = _string_)
			{
				return nk_do_button_text(ref state, _out_, bounds, ptr, (int) _string_.Length, align, behavior, style, _in_, font);
			}
		}

		public static void nk_draw_button_text_symbol(nk_command_buffer _out_, nk_rect* bounds, nk_rect* label,
			nk_rect* symbol, uint state, nk_style_button style, string str, int type, nk_user_font font)
		{
			fixed (char* ptr = str)
			{
				nk_draw_button_text_symbol(_out_, bounds, label, symbol, state, style, ptr, (int) str.Length, type, font);
			}
		}

		public static int nk_do_button_text_symbol(ref uint state, nk_command_buffer _out_, nk_rect bounds, int symbol,
			string str, uint align, int behavior, nk_style_button style, nk_user_font font, nk_input _in_)
		{
			fixed (char* ptr = str)
			{
				return nk_do_button_text_symbol(ref state, _out_, bounds, symbol, ptr, (int) str.Length, align, behavior, style,
					font, _in_);
			}
		}

		public static void nk_draw_button_text_image(nk_command_buffer _out_, nk_rect* bounds, nk_rect* label, nk_rect* image,
			uint state, nk_style_button style, string str, nk_user_font font, nk_image img)
		{
			fixed (char* ptr = str)
			{
				nk_draw_button_text_image(_out_, bounds, label, image, state, style, ptr, (int) str.Length, font, img);
			}
		}

		public static int nk_do_button_text_image(ref uint state, nk_command_buffer _out_, nk_rect bounds, nk_image img,
			string str, uint align, int behavior, nk_style_button style, nk_user_font font, nk_input _in_)
		{
			fixed (char* ptr = str)
			{
				return nk_do_button_text_image(ref state, _out_, bounds, img, ptr, (int) str.Length, align, behavior, style, font,
					_in_);
			}
		}

		public static void nk_draw_checkbox(nk_command_buffer _out_, uint state, nk_style_toggle style, int active,
			nk_rect* label, nk_rect* selector, nk_rect* cursors, string _string_, nk_user_font font)
		{
			fixed (char* ptr = _string_)
			{
				nk_draw_checkbox(_out_, state, style, active, label, selector, cursors, ptr, (int) _string_.Length, font);
			}
		}

		public static void nk_draw_option(nk_command_buffer _out_, uint state, nk_style_toggle style, int active,
			nk_rect* label, nk_rect* selector, nk_rect* cursors, string _string_, nk_user_font font)
		{
			fixed (char* ptr = _string_)
			{
				nk_draw_option(_out_, state, style, active, label, selector, cursors, ptr, (int) _string_.Length, font);
			}
		}

		public static int nk_do_toggle(ref uint state, nk_command_buffer _out_, nk_rect r, int* active, string str, int type,
			nk_style_toggle style, nk_input _in_, nk_user_font font)
		{
			fixed (char* ptr = str)
			{
				return nk_do_toggle(ref state, _out_, r, active, ptr, (int) str.Length, type, style, _in_, font);
			}
		}

		public static void nk_draw_selectable(nk_command_buffer _out_, uint state, nk_style_selectable style, int active,
			nk_rect* bounds, nk_rect* icon, nk_image img, string _string_, uint align, nk_user_font font)
		{
			fixed (char* ptr = _string_)
			{
				nk_draw_selectable(_out_, state, style, active, bounds, icon, img, ptr, (int) _string_.Length, align, font);
			}
		}

		public static int nk_do_selectable(ref uint state, nk_command_buffer _out_, nk_rect bounds, string str, uint align,
			ref int value, nk_style_selectable style, nk_input _in_, nk_user_font font)
		{
			fixed (char* ptr = str)
			{
				return nk_do_selectable(ref state, _out_, bounds, ptr, (int) str.Length, align, ref value, style, _in_, font);
			}
		}

		public static int nk_do_selectable_image(ref uint state, nk_command_buffer _out_, nk_rect bounds, string str,
			uint align, ref int value, nk_image img, nk_style_selectable style, nk_input _in_, nk_user_font font)
		{
			fixed (char* ptr = str)
			{
				return nk_do_selectable_image(ref state, _out_, bounds, ptr, (int) str.Length, align, ref value, img, style, _in_,
					font);
			}
		}

		public static void nk_edit_draw_text(nk_command_buffer _out_, nk_style_edit style, float pos_x, float pos_y,
			float x_offset, string text, float row_height, nk_user_font font, nk_color background, nk_color foreground,
			int is_selected)
		{
			fixed (char* ptr = text)
			{
				nk_edit_draw_text(_out_, style, pos_x, pos_y, x_offset, ptr, (int) text.Length, row_height, font, background,
					foreground, is_selected);
			}
		}

		public static void nk_draw_property(nk_command_buffer _out_, nk_style_property style, nk_rect* bounds, nk_rect* label,
			uint state, string name, nk_user_font font)
		{
			fixed (char* ptr = name)
			{
				nk_draw_property(_out_, style, bounds, label, state, ptr, (int) name.Length, font);
			}
		}

		public static void nk_do_property(ref uint ws, nk_command_buffer _out_, nk_rect property, char* name,
			nk_property_variant* variant, float inc_per_pixel, string buffer, ref int state, int* cursor, int* select_begin,
			int* select_end, nk_style_property style, int filter, nk_input _in_, nk_user_font font, nk_text_edit text_edit,
			int behavior)
		{
			fixed (char* ptr = buffer)
			{
				nk_do_property(ref ws, _out_, property, name, variant, inc_per_pixel, ptr, (int*) buffer.Length, ref state, cursor,
					select_begin, select_end, style, filter, _in_, font, text_edit, behavior);
			}
		}

		public static int nk_panel_begin(nk_context ctx, string title)
		{
			fixed (char* ptr = title)
			{
				return nk_panel_begin(ctx, ptr, (int) title.Length);
			}
		}

		public static void nk_window_collapse(nk_context ctx, string name)
		{
			fixed (char* ptr = name)
			{
				nk_window_collapse(ctx, ptr, (int) name.Length);
			}
		}

		public static void nk_window_collapse_if(nk_context ctx, string name, int cond)
		{
			fixed (char* ptr = name)
			{
				nk_window_collapse_if(ctx, ptr, (int) name.Length, cond);
			}
		}

		public static void nk_window_show(nk_context ctx, string name)
		{
			fixed (char* ptr = name)
			{
				nk_window_show(ctx, ptr, (int) name.Length);
			}
		}

		public static void nk_window_show_if(nk_context ctx, string name, int cond)
		{
			fixed (char* ptr = name)
			{
				nk_window_show_if(ctx, ptr, (int) name.Length, cond);
			}
		}

		public static int nk_tree_base(nk_context ctx, int type, nk_image img, string title, sbyte* hash, int len, int line)
		{
			fixed (char* ptr = title)
			{
				return nk_tree_base(ctx, type, img, ptr, (int) title.Length, hash, len, line);
			}
		}

		public static int nk_tree_push_hashed(nk_context ctx, int type, string title, sbyte* hash, int len, int line)
		{
			fixed (char* ptr = title)
			{
				return nk_tree_push_hashed(ctx, type, ptr, (int) title.Length, hash, len, line);
			}
		}

		public static int nk_tree_image_push_hashed(nk_context ctx, int type, nk_image img, string title, sbyte* hash, int len,
			int seed)
		{
			fixed (char* ptr = title)
			{
				return nk_tree_image_push_hashed(ctx, type, img, ptr, (int) title.Length, hash, len, seed);
			}
		}

		public static void nk_text_colored(nk_context ctx, string str, uint alignment, nk_color color)
		{
			fixed (char* ptr = str)
			{
				nk_text_colored(ctx, ptr, (int) str.Length, alignment, color);
			}
		}

		public static void nk_text_wrap_colored(nk_context ctx, string str, nk_color color)
		{
			fixed (char* ptr = str)
			{
				nk_text_wrap_colored(ctx, ptr, (int) str.Length, color);
			}
		}

		public static void nk_text_(nk_context ctx, string str, uint alignment)
		{
			fixed (char* ptr = str)
			{
				nk_text_(ctx, ptr, (int) str.Length, alignment);
			}
		}

		public static void nk_text_wrap(nk_context ctx, string str)
		{
			fixed (char* ptr = str)
			{
				nk_text_wrap(ctx, ptr, (int) str.Length);
			}
		}

		public static void nk_label(nk_context ctx, string str)
		{
			fixed (char* ptr = str)
			{
				nk_label(ctx, ptr, (uint) str.Length);
			}
		}

		public static void nk_label_colored(nk_context ctx, string str, nk_color color)
		{
			fixed (char* ptr = str)
			{
				nk_label_colored(ctx, ptr, (uint) str.Length, color);
			}
		}

		public static int nk_button_text_styled(nk_context ctx, nk_style_button style, string title)
		{
			fixed (char* ptr = title)
			{
				return nk_button_text_styled(ctx, style, ptr, (int) title.Length);
			}
		}

		public static int nk_button_text(nk_context ctx, string title)
		{
			fixed (char* ptr = title)
			{
				return nk_button_text(ctx, ptr, (int) title.Length);
			}
		}

		public static int nk_button_symbol_text_styled(nk_context ctx, nk_style_button style, int symbol, string text,
			uint align)
		{
			fixed (char* ptr = text)
			{
				return nk_button_symbol_text_styled(ctx, style, symbol, ptr, (int) text.Length, align);
			}
		}

		public static int nk_button_symbol_text(nk_context ctx, int symbol, string text, uint align)
		{
			fixed (char* ptr = text)
			{
				return nk_button_symbol_text(ctx, symbol, ptr, (int) text.Length, align);
			}
		}

		public static int nk_button_symbol_label(nk_context ctx, int symbol, string label)
		{
			fixed (char* ptr = label)
			{
				return nk_button_symbol_label(ctx, symbol, ptr, (uint) label.Length);
			}
		}

		public static int nk_button_symbol_label_styled(nk_context ctx, nk_style_button style, int symbol, string title)
		{
			fixed (char* ptr = title)
			{
				return nk_button_symbol_label_styled(ctx, style, symbol, ptr, (uint) title.Length);
			}
		}

		public static int nk_button_image_text_styled(nk_context ctx, nk_style_button style, nk_image img, string text,
			uint align)
		{
			fixed (char* ptr = text)
			{
				return nk_button_image_text_styled(ctx, style, img, ptr, (int) text.Length, align);
			}
		}

		public static int nk_button_image_text(nk_context ctx, nk_image img, string text, uint align)
		{
			fixed (char* ptr = text)
			{
				return nk_button_image_text(ctx, img, ptr, (int) text.Length, align);
			}
		}

		public static int nk_button_image_label(nk_context ctx, nk_image img, string label)
		{
			fixed (char* ptr = label)
			{
				return nk_button_image_label(ctx, img, ptr, (uint) label.Length);
			}
		}

		public static int nk_button_image_label_styled(nk_context ctx, nk_style_button style, nk_image img, string label)
		{
			fixed (char* ptr = label)
			{
				return nk_button_image_label_styled(ctx, style, img, ptr, (uint) label.Length);
			}
		}

		public static int nk_selectable_text(nk_context ctx, string str, uint align, ref int value)
		{
			fixed (char* ptr = str)
			{
				return nk_selectable_text(ctx, ptr, (int) str.Length, align, ref value);
			}
		}

		public static int nk_selectable_image_text(nk_context ctx, nk_image img, string str, uint align, ref int value)
		{
			fixed (char* ptr = str)
			{
				return nk_selectable_image_text(ctx, img, ptr, (int) str.Length, align, ref value);
			}
		}

		public static int nk_select_text(nk_context ctx, string str, uint align, int value)
		{
			fixed (char* ptr = str)
			{
				return nk_select_text(ctx, ptr, (int) str.Length, align, value);
			}
		}

		public static int nk_selectable_label(nk_context ctx, string str, ref int value)
		{
			fixed (char* ptr = str)
			{
				return nk_selectable_label(ctx, ptr, (uint) str.Length, ref value);
			}
		}

		public static int nk_selectable_image_label(nk_context ctx, nk_image img, string str, ref int value)
		{
			fixed (char* ptr = str)
			{
				return nk_selectable_image_label(ctx, img, ptr, (uint) str.Length, ref value);
			}
		}

		public static int nk_select_label(nk_context ctx, string str, int value)
		{
			fixed (char* ptr = str)
			{
				return nk_select_label(ctx, ptr, (uint) str.Length, value);
			}
		}

		public static int nk_select_image_label(nk_context ctx, nk_image img, string str, int value)
		{
			fixed (char* ptr = str)
			{
				return nk_select_image_label(ctx, img, ptr, (uint) str.Length, value);
			}
		}

		public static int nk_select_image_text(nk_context ctx, nk_image img, string str, uint align, int value)
		{
			fixed (char* ptr = str)
			{
				return nk_select_image_text(ctx, img, ptr, (int) str.Length, align, value);
			}
		}

		public static int nk_check_text(nk_context ctx, string text, int active)
		{
			fixed (char* ptr = text)
			{
				return nk_check_text(ctx, ptr, (int) text.Length, active);
			}
		}

		public static uint nk_check_flags_text(nk_context ctx, string text, uint flags, uint value)
		{
			fixed (char* ptr = text)
			{
				return nk_check_flags_text(ctx, ptr, (int) text.Length, flags, value);
			}
		}

		public static int nk_checkbox_text(nk_context ctx, string text, int* active)
		{
			fixed (char* ptr = text)
			{
				return nk_checkbox_text(ctx, ptr, (int) text.Length, active);
			}
		}

		public static int nk_checkbox_flags_text(nk_context ctx, string text, uint* flags, uint value)
		{
			fixed (char* ptr = text)
			{
				return nk_checkbox_flags_text(ctx, ptr, (int) text.Length, flags, value);
			}
		}

		public static int nk_check_label(nk_context ctx, string label)
		{
			fixed (char* ptr = label)
			{
				return nk_check_label(ctx, ptr, (int) label.Length);
			}
		}

		public static uint nk_check_flags_label(nk_context ctx, string label, uint value)
		{
			fixed (char* ptr = label)
			{
				return nk_check_flags_label(ctx, ptr, (uint) label.Length, value);
			}
		}

		public static int nk_checkbox_label(nk_context ctx, string label)
		{
			fixed (char* ptr = label)
			{
				return nk_checkbox_label(ctx, ptr, (int*) label.Length);
			}
		}

		public static int nk_checkbox_flags_label(nk_context ctx, string label, uint value)
		{
			fixed (char* ptr = label)
			{
				return nk_checkbox_flags_label(ctx, ptr, (uint*) label.Length, value);
			}
		}

		public static int nk_option_text(nk_context ctx, string text, int is_active)
		{
			fixed (char* ptr = text)
			{
				return nk_option_text(ctx, ptr, (int) text.Length, is_active);
			}
		}

		public static int nk_radio_text(nk_context ctx, string text, int* active)
		{
			fixed (char* ptr = text)
			{
				return nk_radio_text(ctx, ptr, (int) text.Length, active);
			}
		}

		public static int nk_option_label(nk_context ctx, string label)
		{
			fixed (char* ptr = label)
			{
				return nk_option_label(ctx, ptr, (int) label.Length);
			}
		}

		public static int nk_radio_label(nk_context ctx, string label)
		{
			fixed (char* ptr = label)
			{
				return nk_radio_label(ctx, ptr, (int*) label.Length);
			}
		}

		public static uint nk_edit_string(nk_context ctx, uint flags, string memory, int max, NkPluginFilter filter)
		{
			fixed (char* ptr = memory)
			{
				return nk_edit_string(ctx, flags, ptr, (int*) memory.Length, max, filter);
			}
		}

		public static uint nk_edit_string_zero_terminated(nk_context ctx, uint flags, string buffer, NkPluginFilter filter)
		{
			fixed (char* ptr = buffer)
			{
				return nk_edit_string_zero_terminated(ctx, flags, ptr, (int) buffer.Length, filter);
			}
		}

		public static void nk_property_int(nk_context ctx, string name, ref int val, int max, int step, float inc_per_pixel)
		{
			fixed (char* ptr = name)
			{
				nk_property_int(ctx, ptr, (int) name.Length, ref val, max, step, inc_per_pixel);
			}
		}

		public static int nk_propertyi(nk_context ctx, string name, int val, int max, int step, float inc_per_pixel)
		{
			fixed (char* ptr = name)
			{
				return nk_propertyi(ctx, ptr, (int) name.Length, val, max, step, inc_per_pixel);
			}
		}

		public static int nk_group_scrolled_begin(nk_context ctx, nk_scroll scroll, string title)
		{
			fixed (char* ptr = title)
			{
				return nk_group_scrolled_begin(ctx, scroll, ptr, (uint) title.Length);
			}
		}

		public static int nk_group_begin_titled(nk_context ctx, char* id, string title)
		{
			fixed (char* ptr = title)
			{
				return nk_group_begin_titled(ctx, id, ptr, (uint) title.Length);
			}
		}

		public static int nk_group_begin(nk_context ctx, string title)
		{
			fixed (char* ptr = title)
			{
				return nk_group_begin(ctx, ptr, (uint) title.Length);
			}
		}

		public static int nk_list_view_begin(nk_context ctx, nk_list_view view, string title, int row_height, int row_count)
		{
			fixed (char* ptr = title)
			{
				return nk_list_view_begin(ctx, view, ptr, (uint) title.Length, row_height, row_count);
			}
		}

		public static int nk_popup_begin(nk_context ctx, int type, string title, nk_rect rect)
		{
			fixed (char* ptr = title)
			{
				return nk_popup_begin(ctx, type, ptr, (uint) title.Length, rect);
			}
		}

		public static int nk_contextual_item_text(nk_context ctx, string text, uint alignment)
		{
			fixed (char* ptr = text)
			{
				return nk_contextual_item_text(ctx, ptr, (int) text.Length, alignment);
			}
		}

		public static int nk_contextual_item_label(nk_context ctx, string label)
		{
			fixed (char* ptr = label)
			{
				return nk_contextual_item_label(ctx, ptr, (uint) label.Length);
			}
		}

		public static int nk_contextual_item_image_text(nk_context ctx, nk_image img, string text, uint align)
		{
			fixed (char* ptr = text)
			{
				return nk_contextual_item_image_text(ctx, img, ptr, (int) text.Length, align);
			}
		}

		public static int nk_contextual_item_image_label(nk_context ctx, nk_image img, string label)
		{
			fixed (char* ptr = label)
			{
				return nk_contextual_item_image_label(ctx, img, ptr, (uint) label.Length);
			}
		}

		public static int nk_contextual_item_symbol_text(nk_context ctx, int symbol, string text, uint align)
		{
			fixed (char* ptr = text)
			{
				return nk_contextual_item_symbol_text(ctx, symbol, ptr, (int) text.Length, align);
			}
		}

		public static int nk_contextual_item_symbol_label(nk_context ctx, int symbol, string text)
		{
			fixed (char* ptr = text)
			{
				return nk_contextual_item_symbol_label(ctx, symbol, ptr, (uint) text.Length);
			}
		}

		public static int nk_combo_begin_text(nk_context ctx, string selected, nk_vec2 size)
		{
			fixed (char* ptr = selected)
			{
				return nk_combo_begin_text(ctx, ptr, (int) selected.Length, size);
			}
		}

		public static int nk_combo_begin_symbol_text(nk_context ctx, string selected, int symbol, nk_vec2 size)
		{
			fixed (char* ptr = selected)
			{
				return nk_combo_begin_symbol_text(ctx, ptr, (int) selected.Length, symbol, size);
			}
		}

		public static int nk_combo_begin_image_text(nk_context ctx, string selected, nk_image img, nk_vec2 size)
		{
			fixed (char* ptr = selected)
			{
				return nk_combo_begin_image_text(ctx, ptr, (int) selected.Length, img, size);
			}
		}

		public static int nk_combo_begin_symbol_label(nk_context ctx, string selected, nk_vec2 size)
		{
			fixed (char* ptr = selected)
			{
				return nk_combo_begin_symbol_label(ctx, ptr, (int) selected.Length, size);
			}
		}

		public static int nk_combo_item_text(nk_context ctx, string text, uint align)
		{
			fixed (char* ptr = text)
			{
				return nk_combo_item_text(ctx, ptr, (int) text.Length, align);
			}
		}

		public static int nk_combo_item_label(nk_context ctx, string label)
		{
			fixed (char* ptr = label)
			{
				return nk_combo_item_label(ctx, ptr, (uint) label.Length);
			}
		}

		public static int nk_combo_item_image_text(nk_context ctx, nk_image img, string text, uint alignment)
		{
			fixed (char* ptr = text)
			{
				return nk_combo_item_image_text(ctx, img, ptr, (int) text.Length, alignment);
			}
		}

		public static int nk_combo_item_image_label(nk_context ctx, nk_image img, string text)
		{
			fixed (char* ptr = text)
			{
				return nk_combo_item_image_label(ctx, img, ptr, (uint) text.Length);
			}
		}

		public static int nk_combo_item_symbol_text(nk_context ctx, int sym, string text, uint alignment)
		{
			fixed (char* ptr = text)
			{
				return nk_combo_item_symbol_text(ctx, sym, ptr, (int) text.Length, alignment);
			}
		}

		public static int nk_combo_item_symbol_label(nk_context ctx, int sym, string label)
		{
			fixed (char* ptr = label)
			{
				return nk_combo_item_symbol_label(ctx, sym, ptr, (uint) label.Length);
			}
		}

		public static int nk_combo_separator(nk_context ctx, string items_separated_by_separator, int selected, int count,
			int item_height, nk_vec2 size)
		{
			fixed (char* ptr = items_separated_by_separator)
			{
				return nk_combo_separator(ctx, ptr, (int) items_separated_by_separator.Length, selected, count, item_height, size);
			}
		}

		public static int nk_combo_string(nk_context ctx, string items_separated_by_zeros, int count, int item_height,
			nk_vec2 size)
		{
			fixed (char* ptr = items_separated_by_zeros)
			{
				return nk_combo_string(ctx, ptr, (int) items_separated_by_zeros.Length, count, item_height, size);
			}
		}

		public static void nk_combobox_string(nk_context ctx, string items_separated_by_zeros, int count, int item_height,
			nk_vec2 size)
		{
			fixed (char* ptr = items_separated_by_zeros)
			{
				nk_combobox_string(ctx, ptr, (int*) items_separated_by_zeros.Length, count, item_height, size);
			}
		}

		public static void nk_combobox_separator(nk_context ctx, string items_separated_by_separator, int* selected, int count,
			int item_height, nk_vec2 size)
		{
			fixed (char* ptr = items_separated_by_separator)
			{
				nk_combobox_separator(ctx, ptr, (int) items_separated_by_separator.Length, selected, count, item_height, size);
			}
		}

		public static int nk_menu_begin(nk_context ctx, nk_window win, string id, nk_rect header, nk_vec2 size)
		{
			fixed (char* ptr = id)
			{
				return nk_menu_begin(ctx, win, ptr, (int) id.Length, header, size);
			}
		}

		public static int nk_menu_begin_text(nk_context ctx, string title, uint align, nk_vec2 size)
		{
			fixed (char* ptr = title)
			{
				return nk_menu_begin_text(ctx, ptr, (int) title.Length, align, size);
			}
		}

		public static int nk_menu_begin_label(nk_context ctx, string text, nk_vec2 size)
		{
			fixed (char* ptr = text)
			{
				return nk_menu_begin_label(ctx, ptr, (uint) text.Length, size);
			}
		}

		public static int nk_menu_begin_symbol(nk_context ctx, string id, nk_vec2 size)
		{
			fixed (char* ptr = id)
			{
				return nk_menu_begin_symbol(ctx, ptr, (int) id.Length, size);
			}
		}

		public static int nk_menu_begin_image_text(nk_context ctx, string title, uint align, nk_image img, nk_vec2 size)
		{
			fixed (char* ptr = title)
			{
				return nk_menu_begin_image_text(ctx, ptr, (int) title.Length, align, img, size);
			}
		}

		public static int nk_menu_begin_image_label(nk_context ctx, string title, nk_image img, nk_vec2 size)
		{
			fixed (char* ptr = title)
			{
				return nk_menu_begin_image_label(ctx, ptr, (uint) title.Length, img, size);
			}
		}

		public static int nk_menu_begin_symbol_text(nk_context ctx, string title, uint align, int sym, nk_vec2 size)
		{
			fixed (char* ptr = title)
			{
				return nk_menu_begin_symbol_text(ctx, ptr, (int) title.Length, align, sym, size);
			}
		}

		public static int nk_menu_begin_symbol_label(nk_context ctx, string title, int sym, nk_vec2 size)
		{
			fixed (char* ptr = title)
			{
				return nk_menu_begin_symbol_label(ctx, ptr, (uint) title.Length, sym, size);
			}
		}

		public static int nk_menu_item_text(nk_context ctx, string title, uint align)
		{
			fixed (char* ptr = title)
			{
				return nk_menu_item_text(ctx, ptr, (int) title.Length, align);
			}
		}

		public static int nk_menu_item_label(nk_context ctx, string label)
		{
			fixed (char* ptr = label)
			{
				return nk_menu_item_label(ctx, ptr, (uint) label.Length);
			}
		}

		public static int nk_menu_item_image_label(nk_context ctx, nk_image img, string label)
		{
			fixed (char* ptr = label)
			{
				return nk_menu_item_image_label(ctx, img, ptr, (uint) label.Length);
			}
		}

		public static int nk_menu_item_image_text(nk_context ctx, nk_image img, string text, uint align)
		{
			fixed (char* ptr = text)
			{
				return nk_menu_item_image_text(ctx, img, ptr, (int) text.Length, align);
			}
		}

		public static int nk_menu_item_symbol_text(nk_context ctx, int sym, string text, uint align)
		{
			fixed (char* ptr = text)
			{
				return nk_menu_item_symbol_text(ctx, sym, ptr, (int) text.Length, align);
			}
		}

		public static int nk_menu_item_symbol_label(nk_context ctx, int sym, string label)
		{
			fixed (char* ptr = label)
			{
				return nk_menu_item_symbol_label(ctx, sym, ptr, (uint) label.Length);
			}
		}
	}
}