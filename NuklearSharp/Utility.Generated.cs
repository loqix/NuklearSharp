// Generated by Sichem at 2/7/2018 6:51:01 PM

using System;
using System.Runtime.InteropServices;

namespace NuklearSharp
{
	public unsafe static partial class Nuklear
	{
		public static float Sqrt(float x)
		{
			return (float) (x*InvSqrt((float) (x)));
		}

		public static float Sin(float x)
		{
			float a0 = (float) (+1.91059300966915117e-31f);
			float a1 = (float) (+1.00086760103908896f);
			float a2 = (float) (-1.21276126894734565e-2f);
			float a3 = (float) (-1.38078780785773762e-1f);
			float a4 = (float) (-2.67353392911981221e-2f);
			float a5 = (float) (+2.08026600266304389e-2f);
			float a6 = (float) (-3.03996055049204407e-3f);
			float a7 = (float) (+1.38235642404333740e-4f);
			return (float) (a0 + x*(a1 + x*(a2 + x*(a3 + x*(a4 + x*(a5 + x*(a6 + x*a7)))))));
		}

		public static float Cos(float x)
		{
			float a0 = (float) (+1.00238601909309722f);
			float a1 = (float) (-3.81919947353040024e-2f);
			float a2 = (float) (-3.94382342128062756e-1f);
			float a3 = (float) (-1.18134036025221444e-1f);
			float a4 = (float) (+1.07123798512170878e-1f);
			float a5 = (float) (-1.86637164165180873e-2f);
			float a6 = (float) (+9.90140908664079833e-4f);
			float a7 = (float) (-5.23022132118824778e-14f);
			return (float) (a0 + x*(a1 + x*(a2 + x*(a3 + x*(a4 + x*(a5 + x*(a6 + x*a7)))))));
		}

		public static uint RoundUpPow2(uint v)
		{
			v--;
			v |= (uint) (v >> 1);
			v |= (uint) (v >> 2);
			v |= (uint) (v >> 4);
			v |= (uint) (v >> 8);
			v |= (uint) (v >> 16);
			v++;
			return (uint) (v);
		}

		public static Rect GetNullRect()
		{
			return (Rect) (Nuklear.nk_null_rect);
		}

		public static Rect Rectz(float x, float y, float w, float h)
		{
			Rect r = new Rect();
			r.x = (float) (x);
			r.y = (float) (y);
			r.w = (float) (w);
			r.h = (float) (h);
			return (Rect) (r);
		}

		public static Rect Rectiz(int x, int y, int w, int h)
		{
			Rect r = new Rect();
			r.x = ((float) (x));
			r.y = ((float) (y));
			r.w = ((float) (w));
			r.h = ((float) (h));
			return (Rect) (r);
		}

		public static Rect Rectv(float* r)
		{
			return (Rect) (Rectz((float) (r[0]), (float) (r[1]), (float) (r[2]), (float) (r[3])));
		}

		public static Rect Rectiv(int* r)
		{
			return (Rect) (Rectiz((int) (r[0]), (int) (r[1]), (int) (r[2]), (int) (r[3])));
		}

		public static Vec2 Vec2z(float x, float y)
		{
			Vec2 ret = new Vec2();
			ret.x = (float) (x);
			ret.y = (float) (y);
			return (Vec2) (ret);
		}

		public static Vec2 Vec2iz(int x, int y)
		{
			Vec2 ret = new Vec2();
			ret.x = ((float) (x));
			ret.y = ((float) (y));
			return (Vec2) (ret);
		}

		public static Vec2 Vec2v(float* v)
		{
			return (Vec2) (Vec2z((float) (v[0]), (float) (v[1])));
		}

		public static Vec2 Vec2iv(int* v)
		{
			return (Vec2) (Vec2iz((int) (v[0]), (int) (v[1])));
		}

		public static int IsLower(int c)
		{
			return (int) ((((c) >= ('a')) && (c <= 'z')) || (((c) >= (0xE0)) && (c <= 0xFF)) ? 1 : 0);
		}

		public static int IsUpper(int c)
		{
			return (int) ((((c) >= ('A')) && (c <= 'Z')) || (((c) >= (0xC0)) && (c <= 0xDF)) ? 1 : 0);
		}

		public static int ToUpper(int c)
		{
			return (int) ((((c) >= ('a')) && (c <= 'z')) ? (c - ('a' - 'A')) : c);
		}

		public static int ToLower(int c)
		{
			return (int) ((((c) >= ('A')) && (c <= 'Z')) ? (c - ('a' + 'A')) : c);
		}

		public static void* Memcopy(void* dst0, void* src0, ulong length)
		{
			ulong t;
			sbyte* dst = (sbyte*) (dst0);
			sbyte* src = (sbyte*) (src0);
			if (((length) == (0)) || ((dst) == (src))) goto done;
			if ((dst) < (src))
			{
				t = ((ulong) (src));
				if (((t | (ulong) (dst)) & (sizeof (int) - 1)) != 0)
				{
					if ((((t ^ (ulong) (dst)) & (sizeof (int) - 1)) != 0) || ((length) < (sizeof (int)))) t = (ulong) (length);
					else t = (ulong) (sizeof (int) - (t & (sizeof (int) - 1)));
					length -= (ulong) (t);
					do
					{
						*dst++ = (sbyte) (*src++);
					} while ((--t) != 0);
				}
				t = (ulong) (length/sizeof (int));
				if ((t) != 0)
					do
					{
						*(int*) ((void*) (dst)) = (int) (*(int*) ((void*) (src)));
						src += sizeof (int);
						dst += sizeof (int);
					} while ((--t) != 0);
				t = (ulong) (length & (sizeof (int) - 1));
				if ((t) != 0)
					do
					{
						*dst++ = (sbyte) (*src++);
					} while ((--t) != 0);
			}
			else
			{
				src += length;
				dst += length;
				t = ((ulong) (src));
				if (((t | (ulong) (dst)) & (sizeof (int) - 1)) != 0)
				{
					if ((((t ^ (ulong) (dst)) & (sizeof (int) - 1)) != 0) || (length <= sizeof (int))) t = (ulong) (length);
					else t &= (ulong) (sizeof (int) - 1);
					length -= (ulong) (t);
					do
					{
						*--dst = (sbyte) (*--src);
					} while ((--t) != 0);
				}
				t = (ulong) (length/sizeof (int));
				if ((t) != 0)
					do
					{
						src -= sizeof (int);
						dst -= sizeof (int);
						*(int*) ((void*) (dst)) = (int) (*(int*) ((void*) (src)));
					} while ((--t) != 0);
				t = (ulong) (length & (sizeof (int) - 1));
				if ((t) != 0)
					do
					{
						*--dst = (sbyte) (*--src);
					} while ((--t) != 0);
			}

			done:
			;
			return (dst0);
		}

		public static void Memset(void* ptr, int c0, ulong size)
		{
			byte* dst = (byte*) (ptr);
			uint c = (uint) (0);
			ulong t = (ulong) (0);
			if ((c = (uint) ((byte) (c0))) != 0)
			{
				c = (uint) ((c << 8) | c);
				if (sizeof (uint) > 2) c = (uint) ((c << 16) | c);
			}

			dst = (byte*) (ptr);
			if ((size) < (3*sizeof (uint)))
			{
				while ((size--) != 0)
				{
					*dst++ = ((byte) (c0));
				}
				return;
			}

			if ((t = (ulong) (((ulong) ((long) (dst))) & (sizeof (uint) - 1))) != 0)
			{
				t = (ulong) (sizeof (uint) - t);
				size -= (ulong) (t);
				do
				{
					*dst++ = ((byte) (c0));
				} while (--t != 0);
			}

			t = (ulong) (size/sizeof (uint));
			do
			{
				*(uint*) ((void*) (dst)) = (uint) (c);
				dst += sizeof (uint);
			} while (--t != 0);
			t = (ulong) (size & (sizeof (uint) - 1));
			if (t != 0)
			{
				do
				{
					*dst++ = ((byte) (c0));
				} while (--t != 0);
			}

		}

		public static void Zero(void* ptr, ulong size)
		{
			Memset(ptr, (int) (0), (ulong) (size));
		}

		public static int Strlen(char* str)
		{
			int siz = (int) (0);
			while (((str) != null) && (*str++ != '\0'))
			{
				siz++;
			}
			return (int) (siz);
		}

		public static int Strtoi(char* str, char** endptr)
		{
			int neg = (int) (1);
			char* p = str;
			int value = (int) (0);
			if (str == null) return (int) (0);
			while ((*p) == (' '))
			{
				p++;
			}
			if ((*p) == ('-'))
			{
				neg = (int) (-1);
				p++;
			}

			while ((((*p) != 0) && ((*p) >= ('0'))) && (*p <= '9'))
			{
				value = (int) (value*10 + (*p - '0'));
				p++;
			}
			if ((endptr) != null) *endptr = p;
			return (int) (neg*value);
		}

		public static double Strtod(char* str, char** endptr)
		{
			double m;
			double neg = (double) (1.0);
			char* p = str;
			double value = (double) (0);
			double number = (double) (0);
			if (str == null) return (double) (0);
			while ((*p) == (' '))
			{
				p++;
			}
			if ((*p) == ('-'))
			{
				neg = (double) (-1.0);
				p++;
			}

			while ((((*p) != 0) && (*p != '.')) && (*p != 'e'))
			{
				value = (double) (value*10.0 + (double) (*p - '0'));
				p++;
			}
			if ((*p) == ('.'))
			{
				p++;
				for (m = (double) (0.1); ((*p) != 0) && (*p != 'e'); p++)
				{
					value = (double) (value + (double) (*p - '0')*m);
					m *= (double) (0.1);
				}
			}

			if ((*p) == ('e'))
			{
				int i;
				int pow;
				int div;
				p++;
				if ((*p) == ('-'))
				{
					div = (int) (Nuklear.nk_true);
					p++;
				}
				else if ((*p) == ('+'))
				{
					div = (int) (Nuklear.nk_false);
					p++;
				}
				else div = (int) (Nuklear.nk_false);
				for (pow = (int) (0); *p != 0; p++)
				{
					pow = (int) (pow*10 + (*p - '0'));
				}
				for (m = (double) (1.0) , i = (int) (0); (i) < (pow); i++)
				{
					m *= (double) (10.0);
				}
				if ((div) != 0) value /= (double) (m);
				else value *= (double) (m);
			}

			number = (double) (value*neg);
			if ((endptr) != null) *endptr = p;
			return (double) (number);
		}

		public static float Strtof(char* str, char** endptr)
		{
			float float_value;
			double double_value;
			double_value = (double) (Strtod(str, endptr));
			float_value = ((float) (double_value));
			return (float) (float_value);
		}

		public static int Stricmpn(char* s1, char* s2, int n)
		{
			int c1;
			int c2;
			int d;
			do
			{
				c1 = (int) (*s1++);
				c2 = (int) (*s2++);
				if (n-- == 0) return (int) (0);
				d = (int) (c1 - c2);
				while ((d) != 0)
				{
					if ((c1 <= 'Z') && ((c1) >= ('A')))
					{
						d += (int) ('a' - 'A');
						if (d == 0) break;
					}
					if ((c2 <= 'Z') && ((c2) >= ('A')))
					{
						d -= (int) ('a' - 'A');
						if (d == 0) break;
					}
					return (int) ((((d) >= (0) ? 1 : 0) << 1) - 1);
				}
			} while ((c1) != 0);
			return (int) (0);
		}

		public static int StrMatchHere(sbyte* regexp, char* text)
		{
			if ((regexp[0]) == ('\0')) return (int) (1);
			if ((regexp[1]) == ('*')) return (int) (StrMatchStar((int) (regexp[0]), regexp + 2, text));
			if (((regexp[0]) == ('$')) && ((regexp[1]) == ('\0'))) return (int) ((*text) == ('\0') ? 1 : 0);
			if ((*text != '\0') && (((regexp[0]) == ('.')) || ((regexp[0]) == (*text))))
				return (int) (StrMatchHere(regexp + 1, text + 1));
			return (int) (0);
		}

		public static int StrMatchStar(int c, sbyte* regexp, char* text)
		{
			do
			{
				if ((StrMatchHere(regexp, text)) != 0) return (int) (1);
			} while ((*text != '\0') && (((*text++) == (c)) || ((c) == ('.'))));
			return (int) (0);
		}

		public static int StringFloatLimit(char* _string_, int prec)
		{
			int dot = (int) (0);
			char* c = _string_;
			while ((*c) != 0)
			{
				if ((*c) == ('.'))
				{
					dot = (int) (1);
					c++;
					continue;
				}
				if ((dot) == (prec + 1))
				{
					*c = (char) 0;
					break;
				}
				if ((dot) > (0)) dot++;
				c++;
			}
			return (int) (c - _string_);
		}

		public static double Pow(double x, int n)
		{
			double r = (double) (1);
			int plus = (int) ((n) >= (0) ? 1 : 0);
			n = (int) ((plus) != 0 ? n : -n);
			while ((n) > (0))
			{
				if ((n & 1) == (1)) r *= (double) (x);
				n /= (int) (2);
				x *= (double) (x);
			}
			return (double) ((plus) != 0 ? r : 1.0/r);
		}

		public static int Ifloord(double x)
		{
			x = ((double) ((int) (x) - (((x) < (0.0)) ? 1 : 0)));
			return (int) (x);
		}

		public static int Ifloorf(float x)
		{
			x = ((float) ((int) (x) - (((x) < (0.0f)) ? 1 : 0)));
			return (int) (x);
		}

		public static int Iceilf(float x)
		{
			if ((x) >= (0))
			{
				int i = (int) (x);
				return (int) (((x) > (i)) ? i + 1 : i);
			}
			else
			{
				int t = (int) (x);
				float r = (float) (x - (float) (t));
				return (int) (((r) > (0.0f)) ? t + 1 : t);
			}

		}

		public static int Log10(double n)
		{
			int neg;
			int ret;
			int exp = (int) (0);
			neg = (int) (((n) < (0)) ? 1 : 0);
			ret = (int) ((neg) != 0 ? (int) (-n) : (int) (n));
			while ((ret/10) > (0))
			{
				ret /= (int) (10);
				exp++;
			}
			if ((neg) != 0) exp = (int) (-exp);
			return (int) (exp);
		}

		public static void StrrevAscii(char* s)
		{
			int len = (int) (Strlen(s));
			int end = (int) (len/2);
			int i = (int) (0);
			char t;
			for (; (i) < (end); ++i)
			{
				t = (s[i]);
				s[i] = (s[len - 1 - i]);
				s[len - 1 - i] = t;
			}
		}

		public static char* Itoa(char* s, int n)
		{
			int i = (int) (0);
			if ((n) == (0))
			{
				s[i++] = ('0');
				s[i] = (char) (0);
				return s;
			}

			if ((n) < (0))
			{
				s[i++] = ('-');
				n = (int) (-n);
			}

			while ((n) > (0))
			{
				s[i++] = (char) (('0' + (char) (n%10)));
				n /= (int) (10);
			}
			s[i] = (char) (0);
			if ((s[0]) == ('-')) ++s;
			StrrevAscii(s);
			return s;
		}

		public static char* Dtoa(char* s, double n)
		{
			int useExp = (int) (0);
			int digit = (int) (0);
			int m = (int) (0);
			int m1 = (int) (0);
			char* c = s;
			int neg = (int) (0);
			if (s == null) return null;
			if ((n) == (0.0))
			{
				s[0] = ('0');
				s[1] = ('\0');
				return s;
			}

			neg = (int) ((n) < (0) ? 1 : 0);
			if ((neg) != 0) n = (double) (-n);
			m = (int) (Log10((double) (n)));
			useExp = (int) ((((m) >= (14)) || (((neg) != 0) && ((m) >= (9)))) || (m <= -9) ? 1 : 0);
			if ((neg) != 0) *(c++) = ('-');
			if ((useExp) != 0)
			{
				if ((m) < (0)) m -= (int) (1);
				n = (double) (n/Pow((double) (10.0), (int) (m)));
				m1 = (int) (m);
				m = (int) (0);
			}

			if ((m) < (1.0))
			{
				m = (int) (0);
			}

			while (((n) > (0.00000000000001)) || ((m) >= (0)))
			{
				double weight = (double) (Pow((double) (10.0), (int) (m)));
				if ((weight) > (0))
				{
					double t = (double) (n/weight);
					digit = (int) (Ifloord((double) (t)));
					n -= (double) ((double) (digit)*weight);
					*(c++) = (char) (('0' + (char) (digit)));
				}
				if (((m) == (0)) && ((n) > (0))) *(c++) = ('.');
				m--;
			}
			if ((useExp) != 0)
			{
				int i;
				int j;
				*(c++) = ('e');
				if ((m1) > (0))
				{
					*(c++) = ('+');
				}
				else
				{
					*(c++) = ('-');
					m1 = (int) (-m1);
				}
				m = (int) (0);
				while ((m1) > (0))
				{
					*(c++) = (char) (('0' + (char) (m1%10)));
					m1 /= (int) (10);
					m++;
				}
				c -= m;
				for (i = (int) (0) , j = (int) (m - 1); (i) < (j); i++ , j--)
				{
					c[i] ^= (c[j]);
					c[j] ^= (c[i]);
					c[i] ^= (c[j]);
				}
				c += m;
			}

			*(c) = ('\0');
			return s;
		}

		public static uint MurmurHash(void* key, int len, uint seed)
		{
			MurmurHashUnion conv = new MurmurHashUnion(null);
			byte* data = (byte*) (key);
			int nblocks = (int) (len/4);
			uint h1 = (uint) (seed);
			uint c1 = (uint) (0xcc9e2d51);
			uint c2 = (uint) (0x1b873593);
			byte* tail;
			uint* blocks;
			uint k1;
			int i;
			if (key == null) return (uint) (0);
			conv.b = (data + nblocks*4);
			blocks = conv.i;
			for (i = (int) (-nblocks); i != 0; ++i)
			{
				k1 = (uint) (blocks[i]);
				k1 *= (uint) (c1);
				k1 = (uint) ((k1) << (15) | ((k1) >> (32 - 15)));
				k1 *= (uint) (c2);
				h1 ^= (uint) (k1);
				h1 = (uint) ((h1) << (13) | ((h1) >> (32 - 13)));
				h1 = (uint) (h1*5 + 0xe6546b64);
			}
			tail = (data + nblocks*4);
			k1 = (uint) (0);
			int l = (int) (len & 3);
			switch (l)
			{
				case 1:
				case 2:
				case 3:
					if ((l) == (2))
					{
						k1 ^= ((uint) (tail[1] << 8));
					}
					else if ((l) == (3))
					{
						k1 ^= ((uint) (tail[2] << 16));
					}
					k1 ^= (uint) (tail[0]);
					k1 *= (uint) (c1);
					k1 = (uint) ((k1) << (15) | ((k1) >> (32 - 15)));
					k1 *= (uint) (c2);
					h1 ^= (uint) (k1);
					break;
				default:
					break;
			}

			h1 ^= ((uint) (len));
			h1 ^= (uint) (h1 >> 16);
			h1 *= (uint) (0x85ebca6b);
			h1 ^= (uint) (h1 >> 13);
			h1 *= (uint) (0xc2b2ae35);
			h1 ^= (uint) (h1 >> 16);
			return (uint) (h1);
		}

		public static int ParseHex(sbyte* p, int length)
		{
			int i = (int) (0);
			int len = (int) (0);
			while ((len) < (length))
			{
				i <<= 4;
				if (((p[len]) >= ('a')) && (p[len] <= 'f')) i += (int) ((p[len] - 'a') + 10);
				else if (((p[len]) >= ('A')) && (p[len] <= 'F')) i += (int) ((p[len] - 'A') + 10);
				else i += (int) (p[len] - '0');
				len++;
			}
			return (int) (i);
		}

		public static Color Rgba(int r, int g, int b, int a)
		{
			Color ret = new Color();
			ret.r = ((byte) (((r) < (255) ? (r) : (255)) < (0) ? (0) : ((r) < (255) ? (r) : (255))));
			ret.g = ((byte) (((g) < (255) ? (g) : (255)) < (0) ? (0) : ((g) < (255) ? (g) : (255))));
			ret.b = ((byte) (((b) < (255) ? (b) : (255)) < (0) ? (0) : ((b) < (255) ? (b) : (255))));
			ret.a = ((byte) (((a) < (255) ? (a) : (255)) < (0) ? (0) : ((a) < (255) ? (a) : (255))));
			return (Color) (ret);
		}

		public static Color RgbHex(sbyte* rgb)
		{
			Color col = new Color();
			sbyte* c = rgb;
			if ((*c) == ('#')) c++;
			col.r = ((byte) (ParseHex(c, (int) (2))));
			col.g = ((byte) (ParseHex(c + 2, (int) (2))));
			col.b = ((byte) (ParseHex(c + 4, (int) (2))));
			col.a = (byte) (255);
			return (Color) (col);
		}

		public static Color RgbaHex(sbyte* rgb)
		{
			Color col = new Color();
			sbyte* c = rgb;
			if ((*c) == ('#')) c++;
			col.r = ((byte) (ParseHex(c, (int) (2))));
			col.g = ((byte) (ParseHex(c + 2, (int) (2))));
			col.b = ((byte) (ParseHex(c + 4, (int) (2))));
			col.a = ((byte) (ParseHex(c + 6, (int) (2))));
			return (Color) (col);
		}

		public static Color RgbaIv(int* c)
		{
			return (Color) (Rgba((int) (c[0]), (int) (c[1]), (int) (c[2]), (int) (c[3])));
		}

		public static Color RgbaBv(byte* c)
		{
			return (Color) (Rgba((int) (c[0]), (int) (c[1]), (int) (c[2]), (int) (c[3])));
		}

		public static Color Rgb(int r, int g, int b)
		{
			Color ret = new Color();
			ret.r = ((byte) (((r) < (255) ? (r) : (255)) < (0) ? (0) : ((r) < (255) ? (r) : (255))));
			ret.g = ((byte) (((g) < (255) ? (g) : (255)) < (0) ? (0) : ((g) < (255) ? (g) : (255))));
			ret.b = ((byte) (((b) < (255) ? (b) : (255)) < (0) ? (0) : ((b) < (255) ? (b) : (255))));
			ret.a = ((byte) (255));
			return (Color) (ret);
		}

		public static Color RgbIv(int* c)
		{
			return (Color) (Rgb((int) (c[0]), (int) (c[1]), (int) (c[2])));
		}

		public static Color RgbBv(byte* c)
		{
			return (Color) (Rgb((int) (c[0]), (int) (c[1]), (int) (c[2])));
		}

		public static Color RgbaU32(uint _in_)
		{
			Color ret = new Color();
			ret.r = (byte) (_in_ & 0xFF);
			ret.g = (byte) ((_in_ >> 8) & 0xFF);
			ret.b = (byte) ((_in_ >> 16) & 0xFF);
			ret.a = ((byte) ((_in_ >> 24) & 0xFF));
			return (Color) (ret);
		}

		public static Color RgbaF(float r, float g, float b, float a)
		{
			Color ret = new Color();
			ret.r = ((byte) (((0) < ((1.0f) < (r) ? (1.0f) : (r)) ? ((1.0f) < (r) ? (1.0f) : (r)) : (0))*255.0f));
			ret.g = ((byte) (((0) < ((1.0f) < (g) ? (1.0f) : (g)) ? ((1.0f) < (g) ? (1.0f) : (g)) : (0))*255.0f));
			ret.b = ((byte) (((0) < ((1.0f) < (b) ? (1.0f) : (b)) ? ((1.0f) < (b) ? (1.0f) : (b)) : (0))*255.0f));
			ret.a = ((byte) (((0) < ((1.0f) < (a) ? (1.0f) : (a)) ? ((1.0f) < (a) ? (1.0f) : (a)) : (0))*255.0f));
			return (Color) (ret);
		}

		public static Color RgbaFv(float* c)
		{
			return (Color) (RgbaF((float) (c[0]), (float) (c[1]), (float) (c[2]), (float) (c[3])));
		}

		public static Color RgbF(float r, float g, float b)
		{
			Color ret = new Color();
			ret.r = ((byte) (((0) < ((1.0f) < (r) ? (1.0f) : (r)) ? ((1.0f) < (r) ? (1.0f) : (r)) : (0))*255.0f));
			ret.g = ((byte) (((0) < ((1.0f) < (g) ? (1.0f) : (g)) ? ((1.0f) < (g) ? (1.0f) : (g)) : (0))*255.0f));
			ret.b = ((byte) (((0) < ((1.0f) < (b) ? (1.0f) : (b)) ? ((1.0f) < (b) ? (1.0f) : (b)) : (0))*255.0f));
			ret.a = (byte) (255);
			return (Color) (ret);
		}

		public static Color RgbFv(float* c)
		{
			return (Color) (RgbF((float) (c[0]), (float) (c[1]), (float) (c[2])));
		}

		public static Color Hsv(int h, int s, int v)
		{
			return (Color) (Hsva((int) (h), (int) (s), (int) (v), (int) (255)));
		}

		public static Color HsvIv(int* c)
		{
			return (Color) (Hsv((int) (c[0]), (int) (c[1]), (int) (c[2])));
		}

		public static Color HsvBv(byte* c)
		{
			return (Color) (Hsv((int) (c[0]), (int) (c[1]), (int) (c[2])));
		}

		public static Color HsvF(float h, float s, float v)
		{
			return (Color) (HsvaF((float) (h), (float) (s), (float) (v), (float) (1.0f)));
		}

		public static Color HsvFv(float* c)
		{
			return (Color) (HsvF((float) (c[0]), (float) (c[1]), (float) (c[2])));
		}

		public static Color Hsva(int h, int s, int v, int a)
		{
			float hf = (float) (((float) (((h) < (255) ? (h) : (255)) < (0) ? (0) : ((h) < (255) ? (h) : (255))))/255.0f);
			float sf = (float) (((float) (((s) < (255) ? (s) : (255)) < (0) ? (0) : ((s) < (255) ? (s) : (255))))/255.0f);
			float vf = (float) (((float) (((v) < (255) ? (v) : (255)) < (0) ? (0) : ((v) < (255) ? (v) : (255))))/255.0f);
			float af = (float) (((float) (((a) < (255) ? (a) : (255)) < (0) ? (0) : ((a) < (255) ? (a) : (255))))/255.0f);
			return (Color) (HsvaF((float) (hf), (float) (sf), (float) (vf), (float) (af)));
		}

		public static Color HsvaIv(int* c)
		{
			return (Color) (Hsva((int) (c[0]), (int) (c[1]), (int) (c[2]), (int) (c[3])));
		}

		public static Color HsvaBv(byte* c)
		{
			return (Color) (Hsva((int) (c[0]), (int) (c[1]), (int) (c[2]), (int) (c[3])));
		}

		public static Colorf HsvaColorf(float h, float s, float v, float a)
		{
			int i;
			float p;
			float q;
			float t;
			float f;
			Colorf _out_ = new Colorf();
			if (s <= 0.0f)
			{
				_out_.r = (float) (v);
				_out_.g = (float) (v);
				_out_.b = (float) (v);
				_out_.a = (float) (a);
				return (Colorf) (_out_);
			}

			h = (float) (h/(60.0f/360.0f));
			i = ((int) (h));
			f = (float) (h - (float) (i));
			p = (float) (v*(1.0f - s));
			q = (float) (v*(1.0f - (s*f)));
			t = (float) (v*(1.0f - s*(1.0f - f)));
			switch (i)
			{
				case 0:
				default:
					_out_.r = (float) (v);
					_out_.g = (float) (t);
					_out_.b = (float) (p);
					break;
				case 1:
					_out_.r = (float) (q);
					_out_.g = (float) (v);
					_out_.b = (float) (p);
					break;
				case 2:
					_out_.r = (float) (p);
					_out_.g = (float) (v);
					_out_.b = (float) (t);
					break;
				case 3:
					_out_.r = (float) (p);
					_out_.g = (float) (q);
					_out_.b = (float) (v);
					break;
				case 4:
					_out_.r = (float) (t);
					_out_.g = (float) (p);
					_out_.b = (float) (v);
					break;
				case 5:
					_out_.r = (float) (v);
					_out_.g = (float) (p);
					_out_.b = (float) (q);
					break;
			}

			_out_.a = (float) (a);
			return (Colorf) (_out_);
		}

		public static Colorf HsvaColorfv(float* c)
		{
			return (Colorf) (HsvaColorf((float) (c[0]), (float) (c[1]), (float) (c[2]), (float) (c[3])));
		}

		public static Color HsvaF(float h, float s, float v, float a)
		{
			Colorf c = (Colorf) (HsvaColorf((float) (h), (float) (s), (float) (v), (float) (a)));
			return (Color) (RgbaF((float) (c.r), (float) (c.g), (float) (c.b), (float) (c.a)));
		}

		public static Color HsvaFv(float* c)
		{
			return (Color) (HsvaF((float) (c[0]), (float) (c[1]), (float) (c[2]), (float) (c[3])));
		}

		public static Handle HandlePtr(void* ptr)
		{
			Handle handle = new Handle();
			handle.ptr = ptr;
			return (Handle) (handle);
		}

		public static Handle HandleId(int id)
		{
			Handle handle = new Handle();
			Zero(&handle, (ulong) (sizeof (Handle)));
			handle.id = (int) (id);
			return (Handle) (handle);
		}

		public static Image ImagePtr(void* ptr)
		{
			Image s = new Image();

			s.handle.ptr = ptr;
			s.w = (ushort) (0);
			s.h = (ushort) (0);
			s.region[0] = (ushort) (0);
			s.region[1] = (ushort) (0);
			s.region[2] = (ushort) (0);
			s.region[3] = (ushort) (0);
			return (Image) (s);
		}

		public static Image ImageId(int id)
		{
			Image s = new Image();

			s.handle.id = (int) (id);
			s.w = (ushort) (0);
			s.h = (ushort) (0);
			s.region[0] = (ushort) (0);
			s.region[1] = (ushort) (0);
			s.region[2] = (ushort) (0);
			s.region[3] = (ushort) (0);
			return (Image) (s);
		}

		public static void* Malloc(void* old, ulong size)
		{
			return CRuntime.malloc((ulong) (size));
		}

		public static void Mfree(void* ptr)
		{
			CRuntime.free(ptr);
		}

		public static void* BufferAlign(void* unaligned, ulong align, ulong* alignment, int type)
		{
			void* memory = null;
			switch (type)
			{
				default:
				case Nuklear.NK_BUFFER_MAX:
				case Nuklear.NK_BUFFER_FRONT:
					if ((align) != 0)
					{
						memory = ((void*) ((long) (((ulong) ((long) ((byte*) (unaligned) + (align - 1)))) & ~(align - 1))));
						*alignment = ((ulong) ((byte*) (memory) - (byte*) (unaligned)));
					}
					else
					{
						memory = unaligned;
						*alignment = (ulong) (0);
					}
					break;
				case Nuklear.NK_BUFFER_BACK:
					if ((align) != 0)
					{
						memory = ((void*) ((long) (((ulong) ((long) ((byte*) (unaligned)))) & ~(align - 1))));
						*alignment = ((ulong) ((byte*) (unaligned) - (byte*) (memory)));
					}
					else
					{
						memory = unaligned;
						*alignment = (ulong) (0);
					}
					break;
			}

			return memory;
		}

		public static void DrawVertexColor(void* attr, float* vals, int format)
		{
			float* val = stackalloc float[4];
			if (((format) < (Nuklear.NK_FORMAT_COLOR_BEGIN)) || ((format) > (Nuklear.NK_FORMAT_COLOR_END))) return;
			val[0] = (float) ((0) < ((1.0f) < (vals[0]) ? (1.0f) : (vals[0])) ? ((1.0f) < (vals[0]) ? (1.0f) : (vals[0])) : (0));
			val[1] = (float) ((0) < ((1.0f) < (vals[1]) ? (1.0f) : (vals[1])) ? ((1.0f) < (vals[1]) ? (1.0f) : (vals[1])) : (0));
			val[2] = (float) ((0) < ((1.0f) < (vals[2]) ? (1.0f) : (vals[2])) ? ((1.0f) < (vals[2]) ? (1.0f) : (vals[2])) : (0));
			val[3] = (float) ((0) < ((1.0f) < (vals[3]) ? (1.0f) : (vals[3])) ? ((1.0f) < (vals[3]) ? (1.0f) : (vals[3])) : (0));
			switch (format)
			{
				default:
					;
					break;
				case Nuklear.NK_FORMAT_R8G8B8A8:
				case Nuklear.NK_FORMAT_R8G8B8:
				{
					Color col = (Color) (RgbaFv(val));
					Memcopy(attr, &col.r, (ulong) (sizeof (Color)));
				}
					break;
				case Nuklear.NK_FORMAT_B8G8R8A8:
				{
					Color col = (Color) (RgbaFv(val));
					Color bgra = (Color) (Rgba((int) (col.b), (int) (col.g), (int) (col.r), (int) (col.a)));
					Memcopy(attr, &bgra, (ulong) (sizeof (Color)));
				}
					break;
				case Nuklear.NK_FORMAT_R16G15B16:
				{
					ushort* col = stackalloc ushort[3];
					col[0] = ((ushort) (val[0]*(float) (65535)));
					col[1] = ((ushort) (val[1]*(float) (65535)));
					col[2] = ((ushort) (val[2]*(float) (65535)));
					Memcopy(attr, col, (ulong) (sizeof (Color)));
				}
					break;
				case Nuklear.NK_FORMAT_R16G15B16A16:
				{
					ushort* col = stackalloc ushort[4];
					col[0] = ((ushort) (val[0]*(float) (65535)));
					col[1] = ((ushort) (val[1]*(float) (65535)));
					col[2] = ((ushort) (val[2]*(float) (65535)));
					col[3] = ((ushort) (val[3]*(float) (65535)));
					Memcopy(attr, col, (ulong) (sizeof (Color)));
				}
					break;
				case Nuklear.NK_FORMAT_R32G32B32:
				{
					uint* col = stackalloc uint[3];
					col[0] = ((uint) (val[0]*(float) (4294967295u)));
					col[1] = ((uint) (val[1]*(float) (4294967295u)));
					col[2] = ((uint) (val[2]*(float) (4294967295u)));
					Memcopy(attr, col, (ulong) (sizeof (Color)));
				}
					break;
				case Nuklear.NK_FORMAT_R32G32B32A32:
				{
					uint* col = stackalloc uint[4];
					col[0] = ((uint) (val[0]*(float) (4294967295u)));
					col[1] = ((uint) (val[1]*(float) (4294967295u)));
					col[2] = ((uint) (val[2]*(float) (4294967295u)));
					col[3] = ((uint) (val[3]*(float) (4294967295u)));
					Memcopy(attr, col, (ulong) (sizeof (Color)));
				}
					break;
				case Nuklear.NK_FORMAT_R32G32B32A32_FLOAT:
					Memcopy(attr, val, (ulong) (sizeof (float)*4));
					break;
				case Nuklear.NK_FORMAT_R32G32B32A32_DOUBLE:
				{
					double* col = stackalloc double[4];
					col[0] = ((double) (val[0]));
					col[1] = ((double) (val[1]));
					col[2] = ((double) (val[2]));
					col[3] = ((double) (val[3]));
					Memcopy(attr, col, (ulong) (sizeof (Color)));
				}
					break;
				case Nuklear.NK_FORMAT_RGB32:
				case Nuklear.NK_FORMAT_RGBA32:
				{
					Color col = (Color) (RgbaFv(val));
					uint color = (uint) (col.U32());
					Memcopy(attr, &color, (ulong) (sizeof (uint)));
				}
					break;
			}

		}

		public static void DrawVertexElement(void* dst, float* values, int value_count, int format)
		{
			int value_index;
			void* attribute = dst;
			if (((format) >= (Nuklear.NK_FORMAT_COLOR_BEGIN)) && (format <= Nuklear.NK_FORMAT_COLOR_END)) return;
			for (value_index = (int) (0); (value_index) < (value_count); ++value_index)
			{
				switch (format)
				{
					default:
						;
						break;
					case Nuklear.NK_FORMAT_SCHAR:
					{
						sbyte value =
							(sbyte)
								(((values[value_index]) < ((float) (127)) ? (values[value_index]) : ((float) (127))) < ((float) (-127))
									? ((float) (-127))
									: ((values[value_index]) < ((float) (127)) ? (values[value_index]) : ((float) (127))));
						Memcopy(attribute, &value, (ulong) (sizeof (double)));
						attribute = (void*) (((sbyte*) (attribute) + sizeof (char)));
					}
						break;
					case Nuklear.NK_FORMAT_SSHORT:
					{
						short value =
							(short)
								(((values[value_index]) < ((float) (32767)) ? (values[value_index]) : ((float) (32767))) < ((float) (-32767))
									? ((float) (-32767))
									: ((values[value_index]) < ((float) (32767)) ? (values[value_index]) : ((float) (32767))));
						Memcopy(attribute, &value, (ulong) (sizeof (double)));
						attribute = (void*) ((sbyte*) (attribute) + sizeof (short));
					}
						break;
					case Nuklear.NK_FORMAT_SINT:
					{
						int value =
							(int)
								(((values[value_index]) < ((float) (2147483647)) ? (values[value_index]) : ((float) (2147483647))) <
								 ((float) (-2147483647))
									? ((float) (-2147483647))
									: ((values[value_index]) < ((float) (2147483647)) ? (values[value_index]) : ((float) (2147483647))));
						Memcopy(attribute, &value, (ulong) (sizeof (double)));
						attribute = (void*) ((sbyte*) (attribute) + sizeof (int));
					}
						break;
					case Nuklear.NK_FORMAT_UCHAR:
					{
						byte value =
							(byte)
								(((values[value_index]) < ((float) (256)) ? (values[value_index]) : ((float) (256))) < ((float) (0))
									? ((float) (0))
									: ((values[value_index]) < ((float) (256)) ? (values[value_index]) : ((float) (256))));
						Memcopy(attribute, &value, (ulong) (sizeof (double)));
						attribute = (void*) (((sbyte*) (attribute) + sizeof (byte)));
					}
						break;
					case Nuklear.NK_FORMAT_USHORT:
					{
						ushort value =
							(ushort)
								(((values[value_index]) < ((float) (65535)) ? (values[value_index]) : ((float) (65535))) < ((float) (0))
									? ((float) (0))
									: ((values[value_index]) < ((float) (65535)) ? (values[value_index]) : ((float) (65535))));
						Memcopy(attribute, &value, (ulong) (sizeof (double)));
						attribute = (void*) ((sbyte*) (attribute) + sizeof (short));
					}
						break;
					case Nuklear.NK_FORMAT_UINT:
					{
						uint value =
							(uint)
								(((values[value_index]) < ((float) (4294967295u)) ? (values[value_index]) : ((float) (4294967295u))) <
								 ((float) (0))
									? ((float) (0))
									: ((values[value_index]) < ((float) (4294967295u)) ? (values[value_index]) : ((float) (4294967295u))));
						Memcopy(attribute, &value, (ulong) (sizeof (double)));
						attribute = (void*) ((sbyte*) (attribute) + sizeof (uint));
					}
						break;
					case Nuklear.NK_FORMAT_FLOAT:
						Memcopy(attribute, &values[value_index], (ulong) (sizeof (float)));
						attribute = (void*) (((sbyte*) (attribute) + sizeof (float)));
						break;
					case Nuklear.NK_FORMAT_DOUBLE:
					{
						double value = (double) (values[value_index]);
						Memcopy(attribute, &value, (ulong) (sizeof (double)));
						attribute = (void*) (((sbyte*) (attribute) + sizeof (double)));
					}
						break;
				}
			}
		}

		public static int RectHeightCompare(void* a, void* b)
		{
			RpRect* p = (RpRect*) (a);
			RpRect* q = (RpRect*) (b);
			if ((p->h) > (q->h)) return (int) (-1);
			if ((p->h) < (q->h)) return (int) (1);
			return (int) (((p->w) > (q->w)) ? -1 : ((p->w) < (q->w)) ? 1 : 0);
		}

		public static int RectOriginalOrder(void* a, void* b)
		{
			RpRect* p = (RpRect*) (a);
			RpRect* q = (RpRect*) (b);
			return (int) (((p->was_packed) < (q->was_packed)) ? -1 : ((p->was_packed) > (q->was_packed)) ? 1 : 0);
		}

		public static ushort TtUSHORT(byte* p)
		{
			return (ushort) (p[0]*256 + p[1]);
		}

		public static short TtSHORT(byte* p)
		{
			return (short) (p[0]*256 + p[1]);
		}

		public static uint TtULONG(byte* p)
		{
			return (uint) ((p[0] << 24) + (p[1] << 16) + (p[2] << 8) + p[3]);
		}

		public static uint TtFindTable(byte* data, uint fontstart, string tag)
		{
			int num_tables = (int) (TtUSHORT(data + fontstart + 4));
			uint tabledir = (uint) (fontstart + 12);
			int i;
			for (i = (int) (0); (i) < (num_tables); ++i)
			{
				uint loc = (uint) (tabledir + (uint) (16*i));
				if (((((((data + loc + 0)[0]) == (tag[0])) && (((data + loc + 0)[1]) == (tag[1]))) &&
				      (((data + loc + 0)[2]) == (tag[2]))) && (((data + loc + 0)[3]) == (tag[3]))))
					return (uint) (TtULONG(data + loc + 8));
			}
			return (uint) (0);
		}

		public static void TtHPrefilter(byte* pixels, int w, int h, int stride_in_bytes, int kernel_width)
		{
			byte* buffer = stackalloc byte[8];
			int safe_w = (int) (w - kernel_width);
			int j;
			for (j = (int) (0); (j) < (h); ++j)
			{
				int i;
				uint total;
				Memset(buffer, (int) (0), (ulong) (kernel_width));
				total = (uint) (0);
				switch (kernel_width)
				{
					case 2:
						for (i = (int) (0); i <= safe_w; ++i)
						{
							total += ((uint) (pixels[i] - buffer[i & (8 - 1)]));
							buffer[(i + kernel_width) & (8 - 1)] = (byte) (pixels[i]);
							pixels[i] = ((byte) (total/2));
						}
						break;
					case 3:
						for (i = (int) (0); i <= safe_w; ++i)
						{
							total += ((uint) (pixels[i] - buffer[i & (8 - 1)]));
							buffer[(i + kernel_width) & (8 - 1)] = (byte) (pixels[i]);
							pixels[i] = ((byte) (total/3));
						}
						break;
					case 4:
						for (i = (int) (0); i <= safe_w; ++i)
						{
							total += (uint) ((uint) (pixels[i]) - buffer[i & (8 - 1)]);
							buffer[(i + kernel_width) & (8 - 1)] = (byte) (pixels[i]);
							pixels[i] = ((byte) (total/4));
						}
						break;
					case 5:
						for (i = (int) (0); i <= safe_w; ++i)
						{
							total += ((uint) (pixels[i] - buffer[i & (8 - 1)]));
							buffer[(i + kernel_width) & (8 - 1)] = (byte) (pixels[i]);
							pixels[i] = ((byte) (total/5));
						}
						break;
					default:
						for (i = (int) (0); i <= safe_w; ++i)
						{
							total += ((uint) (pixels[i] - buffer[i & (8 - 1)]));
							buffer[(i + kernel_width) & (8 - 1)] = (byte) (pixels[i]);
							pixels[i] = ((byte) (total/(uint) (kernel_width)));
						}
						break;
				}
				for (; (i) < (w); ++i)
				{
					total -= ((uint) (buffer[i & (8 - 1)]));
					pixels[i] = ((byte) (total/(uint) (kernel_width)));
				}
				pixels += stride_in_bytes;
			}
		}

		public static void TtVPrefilter(byte* pixels, int w, int h, int stride_in_bytes, int kernel_width)
		{
			byte* buffer = stackalloc byte[8];
			int safe_h = (int) (h - kernel_width);
			int j;
			for (j = (int) (0); (j) < (w); ++j)
			{
				int i;
				uint total;
				Memset(buffer, (int) (0), (ulong) (kernel_width));
				total = (uint) (0);
				switch (kernel_width)
				{
					case 2:
						for (i = (int) (0); i <= safe_h; ++i)
						{
							total += ((uint) (pixels[i*stride_in_bytes] - buffer[i & (8 - 1)]));
							buffer[(i + kernel_width) & (8 - 1)] = (byte) (pixels[i*stride_in_bytes]);
							pixels[i*stride_in_bytes] = ((byte) (total/2));
						}
						break;
					case 3:
						for (i = (int) (0); i <= safe_h; ++i)
						{
							total += ((uint) (pixels[i*stride_in_bytes] - buffer[i & (8 - 1)]));
							buffer[(i + kernel_width) & (8 - 1)] = (byte) (pixels[i*stride_in_bytes]);
							pixels[i*stride_in_bytes] = ((byte) (total/3));
						}
						break;
					case 4:
						for (i = (int) (0); i <= safe_h; ++i)
						{
							total += ((uint) (pixels[i*stride_in_bytes] - buffer[i & (8 - 1)]));
							buffer[(i + kernel_width) & (8 - 1)] = (byte) (pixels[i*stride_in_bytes]);
							pixels[i*stride_in_bytes] = ((byte) (total/4));
						}
						break;
					case 5:
						for (i = (int) (0); i <= safe_h; ++i)
						{
							total += ((uint) (pixels[i*stride_in_bytes] - buffer[i & (8 - 1)]));
							buffer[(i + kernel_width) & (8 - 1)] = (byte) (pixels[i*stride_in_bytes]);
							pixels[i*stride_in_bytes] = ((byte) (total/5));
						}
						break;
					default:
						for (i = (int) (0); i <= safe_h; ++i)
						{
							total += ((uint) (pixels[i*stride_in_bytes] - buffer[i & (8 - 1)]));
							buffer[(i + kernel_width) & (8 - 1)] = (byte) (pixels[i*stride_in_bytes]);
							pixels[i*stride_in_bytes] = ((byte) (total/(uint) (kernel_width)));
						}
						break;
				}
				for (; (i) < (h); ++i)
				{
					total -= ((uint) (buffer[i & (8 - 1)]));
					pixels[i*stride_in_bytes] = ((byte) (total/(uint) (kernel_width)));
				}
				pixels += 1;
			}
		}

		public static float TtOversampleShift(int oversample)
		{
			if (oversample == 0) return (float) (0.0f);
			return (float) ((float) (-(oversample - 1))/(2.0f*(float) (oversample)));
		}

		public static int RangeCount(uint* range)
		{
			uint* iter = range;
			if (range == null) return (int) (0);
			while (*(iter++) != 0)
			{
			}
			return (int) (((iter) == (range)) ? 0 : (int) ((iter - range)/2));
		}

		public static int RangeGlyphCount(uint* range, int count)
		{
			int i = (int) (0);
			int total_glyphs = (int) (0);
			for (i = (int) (0); (i) < (count); ++i)
			{
				int diff;
				uint f = (uint) (range[(i*2) + 0]);
				uint t = (uint) (range[(i*2) + 1]);
				diff = ((int) ((t - f) + 1));
				total_glyphs += (int) (diff);
			}
			return (int) (total_glyphs);
		}

		public static uint* FontDefaultGlyphRanges()
		{
			return Nuklear.default_ranges;
		}

		public static uint* FontChineseGlyphRanges()
		{
			return Nuklear.chinese_ranges;
		}

		public static uint* FontCyrillicGlyphRanges()
		{
			return Nuklear.cyrillic_ranges;
		}

		public static uint* FontKoreanGlyphRanges()
		{
			return Nuklear.korean_ranges;
		}

		public static FontBaker* FontBakerz(void* memory, int glyph_count, int count)
		{
			FontBaker* baker;
			if (memory == null) return null;
			baker =
				(FontBaker*)
					((void*)
						((long) (((ulong) ((long) ((byte*) (memory) + (Nuklear.nk_baker_align - 1)))) & ~(Nuklear.nk_baker_align - 1))));
			baker->build =
				(FontBakeData*)
					((void*)
						((long) (((ulong) ((long) ((byte*) (baker + 1) + (Nuklear.nk_build_align - 1)))) & ~(Nuklear.nk_build_align - 1))));
			baker->packed_chars =
				(TtPackedchar*)
					((void*)
						((long)
							(((ulong) ((long) ((byte*) (baker->build + count) + (Nuklear.nk_char_align - 1)))) & ~(Nuklear.nk_char_align - 1))));
			baker->rects =
				(RpRect*)
					((void*)
						((long)
							(((ulong) ((long) ((byte*) (baker->packed_chars + glyph_count) + (Nuklear.nk_rect_align - 1)))) &
							 ~(Nuklear.nk_rect_align - 1))));
			baker->ranges =
				(TtPackRange*)
					((void*)
						((long)
							(((ulong) ((long) ((byte*) (baker->rects + glyph_count) + (Nuklear.nk_range_align - 1)))) &
							 ~(Nuklear.nk_range_align - 1))));

			return baker;
		}

		public static void FontBakeConvert(void* out_memory, int img_width, int img_height, void* in_memory)
		{
			int n = (int) (0);
			uint* dst;
			byte* src;
			if ((((out_memory == null) || (in_memory == null)) || (img_height == 0)) || (img_width == 0)) return;
			dst = (uint*) (out_memory);
			src = (byte*) (in_memory);
			for (n = (int) (img_width*img_height); (n) > (0); n--)
			{
				*dst++ = (uint) (((uint) (*src++) << 24) | 0x00FFFFFF);
			}
		}

		public static uint DecompressLength(byte* input)
		{
			return (uint) ((input[8] << 24) + (input[9] << 16) + (input[10] << 8) + input[11]);
		}

		public static void Match(byte* data, uint length)
		{
			if ((Nuklear.nk__dout + length) > (Nuklear.nk__barrier))
			{
				Nuklear.nk__dout += length;
				return;
			}

			if ((data) < (Nuklear.nk__barrier4))
			{
				Nuklear.nk__dout = Nuklear.nk__barrier + 1;
				return;
			}

			while ((length--) != 0)
			{
				*Nuklear.nk__dout++ = (byte) (*data++);
			}
		}

		public static void Lit(byte* data, uint length)
		{
			if ((Nuklear.nk__dout + length) > (Nuklear.nk__barrier))
			{
				Nuklear.nk__dout += length;
				return;
			}

			if ((data) < (Nuklear.nk__barrier2))
			{
				Nuklear.nk__dout = Nuklear.nk__barrier + 1;
				return;
			}

			Memcopy(Nuklear.nk__dout, data, (ulong) (length));
			Nuklear.nk__dout += length;
		}

		public static byte* DecompressToken(byte* i)
		{
			if ((*i) >= (0x20))
			{
				if ((*i) >= (0x80))
				{
					Match(Nuklear.nk__dout - i[1] - 1, (uint) ((uint) (i[0]) - 0x80 + 1));
					i += 2;
				}
				else if ((*i) >= (0x40))
				{
					Match(Nuklear.nk__dout - (((i[0] << 8) + i[(0) + 1]) - 0x4000 + 1), (uint) ((uint) (i[2]) + 1));
					i += 3;
				}
				else
				{
					Lit(i + 1, (uint) ((uint) (i[0]) - 0x20 + 1));
					i += 1 + (i[0] - 0x20 + 1);
				}
			}
			else
			{
				if ((*i) >= (0x18))
				{
					Match(Nuklear.nk__dout - (uint) (((i[0] << 16) + ((i[(0) + 1] << 8) + i[((0) + 1) + 1])) - 0x180000 + 1),
						(uint) ((uint) (i[3]) + 1));
					i += 4;
				}
				else if ((*i) >= (0x10))
				{
					Match(Nuklear.nk__dout - (uint) (((i[0] << 16) + ((i[(0) + 1] << 8) + i[((0) + 1) + 1])) - 0x100000 + 1),
						(uint) ((uint) ((i[3] << 8) + i[(3) + 1]) + 1));
					i += 5;
				}
				else if ((*i) >= (0x08))
				{
					Lit(i + 2, (uint) ((uint) ((i[0] << 8) + i[(0) + 1]) - 0x0800 + 1));
					i += 2 + (((i[0] << 8) + i[(0) + 1]) - 0x0800 + 1);
				}
				else if ((*i) == (0x07))
				{
					Lit(i + 3, (uint) ((uint) ((i[1] << 8) + i[(1) + 1]) + 1));
					i += 3 + (((i[1] << 8) + i[(1) + 1]) + 1);
				}
				else if ((*i) == (0x06))
				{
					Match(Nuklear.nk__dout - (uint) (((i[1] << 16) + ((i[(1) + 1] << 8) + i[((1) + 1) + 1])) + 1), (uint) (i[4] + 1u));
					i += 5;
				}
				else if ((*i) == (0x04))
				{
					Match(Nuklear.nk__dout - (uint) (((i[1] << 16) + ((i[(1) + 1] << 8) + i[((1) + 1) + 1])) + 1),
						(uint) ((uint) ((i[4] << 8) + i[(4) + 1]) + 1u));
					i += 6;
				}
			}

			return i;
		}

		public static uint Adler32(uint adler32, byte* buffer, uint buflen)
		{
			int ADLER_MOD = (int) (65521);
			int s1 = (int) (adler32 & 0xffff);
			int s2 = (int) (adler32 >> 16);
			int blocklen;
			int i;
			blocklen = (int) (buflen%5552);
			while ((buflen) != 0)
			{
				for (i = (int) (0); (i + 7) < (blocklen); i += (int) (8))
				{
					s1 += (int) (buffer[0]);
					s2 += (int) (s1);
					s1 += (int) (buffer[1]);
					s2 += (int) (s1);
					s1 += (int) (buffer[2]);
					s2 += (int) (s1);
					s1 += (int) (buffer[3]);
					s2 += (int) (s1);
					s1 += (int) (buffer[4]);
					s2 += (int) (s1);
					s1 += (int) (buffer[5]);
					s2 += (int) (s1);
					s1 += (int) (buffer[6]);
					s2 += (int) (s1);
					s1 += (int) (buffer[7]);
					s2 += (int) (s1);
					buffer += 8;
				}
				for (; (i) < (blocklen); ++i)
				{
					s1 += (int) (*buffer++);
					s2 += (int) (s1);
				}
				s1 %= (int) (ADLER_MOD);
				s2 %= (int) (ADLER_MOD);
				buflen -= ((uint) (blocklen));
				blocklen = (int) (5552);
			}
			return (uint) ((uint) (s2 << 16) + (uint) (s1));
		}

		public static uint Decompress(byte* output, byte* i, uint length)
		{
			uint olen;
			if (((i[0] << 24) + ((i[(0) + 1] << 16) + ((i[((0) + 1) + 1] << 8) + i[(((0) + 1) + 1) + 1]))) != 0x57bC0000)
				return (uint) (0);
			if (((i[4] << 24) + ((i[(4) + 1] << 16) + ((i[((4) + 1) + 1] << 8) + i[(((4) + 1) + 1) + 1]))) != 0)
				return (uint) (0);
			olen = (uint) (DecompressLength(i));
			Nuklear.nk__barrier2 = i;
			Nuklear.nk__barrier3 = i + length;
			Nuklear.nk__barrier = output + olen;
			Nuklear.nk__barrier4 = output;
			i += 16;
			Nuklear.nk__dout = output;
			for (;;)
			{
				byte* old_i = i;
				i = DecompressToken(i);
				if ((i) == (old_i))
				{
					if (((*i) == (0x05)) && ((i[1]) == (0xfa)))
					{
						if (Nuklear.nk__dout != output + olen) return (uint) (0);
						if (Adler32((uint) (1), output, (uint) (olen)) !=
						    (uint) ((i[2] << 24) + ((i[(2) + 1] << 16) + ((i[((2) + 1) + 1] << 8) + i[(((2) + 1) + 1) + 1]))))
							return (uint) (0);
						return (uint) (olen);
					}
					else
					{
						return (uint) (0);
					}
				}
				if ((Nuklear.nk__dout) > (output + olen)) return (uint) (0);
			}
		}

		public static uint Decode85Byte(sbyte c)
		{
			return (uint) (((c) >= ('\\')) ? c - 36 : c - 35);
		}

		public static void Decode85(byte* dst, byte* src)
		{
			while ((*src) != 0)
			{
				uint tmp =
					(uint)
						(Decode85Byte((sbyte) (src[0])) +
						 85*
						 (Decode85Byte((sbyte) (src[1])) +
						  85*(Decode85Byte((sbyte) (src[2])) + 85*(Decode85Byte((sbyte) (src[3])) + 85*Decode85Byte((sbyte) (src[4]))))));
				dst[0] = ((byte) ((tmp >> 0) & 0xFF));
				dst[1] = ((byte) ((tmp >> 8) & 0xFF));
				dst[2] = ((byte) ((tmp >> 16) & 0xFF));
				dst[3] = ((byte) ((tmp >> 24) & 0xFF));
				src += 5;
				dst += 4;
			}
		}

		public static FontConfig FontConfigz(float pixel_height)
		{
			FontConfig cfg = new FontConfig();

			cfg.ttf_blob = null;
			cfg.ttf_size = (ulong) (0);
			cfg.ttf_data_owned_by_atlas = (byte) (0);
			cfg.size = (float) (pixel_height);
			cfg.oversample_h = (byte) (3);
			cfg.oversample_v = (byte) (1);
			cfg.pixel_snap = (byte) (0);
			cfg.coord_type = (int) (Nuklear.NK_COORD_UV);
			cfg.spacing = (Vec2) (Vec2z((float) (0), (float) (0)));
			cfg.range = FontDefaultGlyphRanges();
			cfg.merge_mode = (byte) (0);
			cfg.fallback_glyph = '?';
			cfg.font = null;
			cfg.n = null;
			return (FontConfig) (cfg);
		}

		public static StyleItem StyleItemHide()
		{
			StyleItem i = new StyleItem();
			i.type = (int) (Nuklear.NK_STYLE_ITEM_COLOR);
			i.data.color = (Color) (Rgba((int) (0), (int) (0), (int) (0), (int) (0)));
			return (StyleItem) (i);
		}

		public static int PanelHasHeader(uint flags, char* title)
		{
			int active = (int) (0);
			active = (int) (flags & (Nuklear.NK_WINDOW_CLOSABLE | Nuklear.NK_WINDOW_MINIMIZABLE));
			active = (int) (((active) != 0) || ((flags & Nuklear.NK_WINDOW_TITLE) != 0) ? 1 : 0);
			active = (int) ((((active) != 0) && ((flags & Nuklear.NK_WINDOW_HIDDEN) == 0)) && ((title) != null) ? 1 : 0);
			return (int) (active);
		}

		public static int PanelIsSub(int type)
		{
			return (int) ((type & Nuklear.NK_PANEL_SET_SUB) != 0 ? 1 : 0);
		}

		public static int PanelIsNonblock(int type)
		{
			return (int) ((type & Nuklear.NK_PANEL_SET_NONBLOCK) != 0 ? 1 : 0);
		}

		public static PropertyVariant PropertyVariantInt(int value, int min_value, int max_value, int step)
		{
			PropertyVariant result = new PropertyVariant();
			result.kind = (int) (Nuklear.NK_PROPERTY_INT);
			result.value.i = (int) (value);
			result.min_value.i = (int) (min_value);
			result.max_value.i = (int) (max_value);
			result.step.i = (int) (step);
			return (PropertyVariant) (result);
		}

		public static PropertyVariant PropertyVariantFloat(float value, float min_value, float max_value, float step)
		{
			PropertyVariant result = new PropertyVariant();
			result.kind = (int) (Nuklear.NK_PROPERTY_FLOAT);
			result.value.f = (float) (value);
			result.min_value.f = (float) (min_value);
			result.max_value.f = (float) (max_value);
			result.step.f = (float) (step);
			return (PropertyVariant) (result);
		}

		public static PropertyVariant PropertyVariantDouble(double value, double min_value, double max_value, double step)
		{
			PropertyVariant result = new PropertyVariant();
			result.kind = (int) (Nuklear.NK_PROPERTY_DOUBLE);
			result.value.d = (double) (value);
			result.min_value.d = (double) (min_value);
			result.max_value.d = (double) (max_value);
			result.step.d = (double) (step);
			return (PropertyVariant) (result);
		}
	}
}