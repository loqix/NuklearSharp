// Generated by Sichem at 2/4/2018 7:49:44 PM

using System;
using System.Runtime.InteropServices;

namespace NuklearSharp
{
	unsafe partial class Nuklear
	{
		public static float nk_sqrt(float x)
		{
			return (float) (x*nk_inv_sqrt((float) (x)));
		}

		public static float nk_sin(float x)
		{
			float a0 = (float) (+1.91059300966915117e-31f);
			float a1 = (float) (+1.00086760103908896f);
			float a2 = (float) (-1.21276126894734565e-2f);
			float a3 = (float) (-1.38078780785773762e-1f);
			float a4 = (float) (-2.67353392911981221e-2f);
			float a5 = (float) (+2.08026600266304389e-2f);
			float a6 = (float) (-3.03996055049204407e-3f);
			float a7 = (float) (+1.38235642404333740e-4f);
			return (float) (a0 + x*(a1 + x*(a2 + x*(a3 + x*(a4 + x*(a5 + x*(a6 + x*a7)))))));
		}

		public static float nk_cos(float x)
		{
			float a0 = (float) (+1.00238601909309722f);
			float a1 = (float) (-3.81919947353040024e-2f);
			float a2 = (float) (-3.94382342128062756e-1f);
			float a3 = (float) (-1.18134036025221444e-1f);
			float a4 = (float) (+1.07123798512170878e-1f);
			float a5 = (float) (-1.86637164165180873e-2f);
			float a6 = (float) (+9.90140908664079833e-4f);
			float a7 = (float) (-5.23022132118824778e-14f);
			return (float) (a0 + x*(a1 + x*(a2 + x*(a3 + x*(a4 + x*(a5 + x*(a6 + x*a7)))))));
		}

		public static uint nk_round_up_pow2(uint v)
		{
			v--;
			v |= (uint) (v >> 1);
			v |= (uint) (v >> 2);
			v |= (uint) (v >> 4);
			v |= (uint) (v >> 8);
			v |= (uint) (v >> 16);
			v++;
			return (uint) (v);
		}

		public static nk_rect nk_get_null_rect()
		{
			return (nk_rect) (nk_null_rect);
		}

		public static nk_rect nk_recti_(int x, int y, int w, int h)
		{
			nk_rect r = new nk_rect();
			r.x = ((float) (x));
			r.y = ((float) (y));
			r.w = ((float) (w));
			r.h = ((float) (h));
			return (nk_rect) (r);
		}

		public static nk_rect nk_recta(nk_vec2 pos, nk_vec2 size)
		{
			return (nk_rect) (nk_rect_((float) (pos.x), (float) (pos.y), (float) (size.x), (float) (size.y)));
		}

		public static nk_rect nk_rectv(float* r)
		{
			return (nk_rect) (nk_rect_((float) (r[0]), (float) (r[1]), (float) (r[2]), (float) (r[3])));
		}

		public static nk_rect nk_rectiv(int* r)
		{
			return (nk_rect) (nk_recti_((int) (r[0]), (int) (r[1]), (int) (r[2]), (int) (r[3])));
		}

		public static nk_rect nk_shrink_rect_(nk_rect r, float amount)
		{
			nk_rect res = new nk_rect();
			r.w = (float) ((r.w) < (2*amount) ? (2*amount) : (r.w));
			r.h = (float) ((r.h) < (2*amount) ? (2*amount) : (r.h));
			res.x = (float) (r.x + amount);
			res.y = (float) (r.y + amount);
			res.w = (float) (r.w - 2*amount);
			res.h = (float) (r.h - 2*amount);
			return (nk_rect) (res);
		}

		public static nk_rect nk_pad_rect(nk_rect r, nk_vec2 pad)
		{
			r.w = (float) ((r.w) < (2*pad.x) ? (2*pad.x) : (r.w));
			r.h = (float) ((r.h) < (2*pad.y) ? (2*pad.y) : (r.h));
			r.x += (float) (pad.x);
			r.y += (float) (pad.y);
			r.w -= (float) (2*pad.x);
			r.h -= (float) (2*pad.y);
			return (nk_rect) (r);
		}

		public static nk_vec2 nk_vec2_(float x, float y)
		{
			nk_vec2 ret = new nk_vec2();
			ret.x = (float) (x);
			ret.y = (float) (y);
			return (nk_vec2) (ret);
		}

		public static nk_vec2 nk_vec2i_(int x, int y)
		{
			nk_vec2 ret = new nk_vec2();
			ret.x = ((float) (x));
			ret.y = ((float) (y));
			return (nk_vec2) (ret);
		}

		public static nk_vec2 nk_vec2v(float* v)
		{
			return (nk_vec2) (nk_vec2_((float) (v[0]), (float) (v[1])));
		}

		public static nk_vec2 nk_vec2iv(int* v)
		{
			return (nk_vec2) (nk_vec2i_((int) (v[0]), (int) (v[1])));
		}

		public static int nk_is_lower(int c)
		{
			return (int) ((((c) >= ('a')) && (c <= 'z')) || (((c) >= (0xE0)) && (c <= 0xFF)) ? 1 : 0);
		}

		public static int nk_is_upper(int c)
		{
			return (int) ((((c) >= ('A')) && (c <= 'Z')) || (((c) >= (0xC0)) && (c <= 0xDF)) ? 1 : 0);
		}

		public static int nk_to_upper(int c)
		{
			return (int) ((((c) >= ('a')) && (c <= 'z')) ? (c - ('a' - 'A')) : c);
		}

		public static int nk_to_lower(int c)
		{
			return (int) ((((c) >= ('A')) && (c <= 'Z')) ? (c - ('a' + 'A')) : c);
		}

		public static void* nk_memcopy(void* dst0, void* src0, ulong length)
		{
			ulong t;
			sbyte* dst = (sbyte*) (dst0);
			sbyte* src = (sbyte*) (src0);
			if (((length) == (0)) || ((dst) == (src))) goto done;
			if ((dst) < (src))
			{
				t = ((ulong) (src));
				if (((t | (ulong) (dst)) & (sizeof (int) - 1)) != 0)
				{
					if ((((t ^ (ulong) (dst)) & (sizeof (int) - 1)) != 0) || ((length) < (sizeof (int)))) t = (ulong) (length);
					else t = (ulong) (sizeof (int) - (t & (sizeof (int) - 1)));
					length -= (ulong) (t);
					do
					{
						*dst++ = (sbyte) (*src++);
					} while ((--t) != 0);
				}
				t = (ulong) (length/sizeof (int));
				if ((t) != 0)
					do
					{
						*(int*) ((void*) (dst)) = (int) (*(int*) ((void*) (src)));
						src += sizeof (int);
						dst += sizeof (int);
					} while ((--t) != 0);
				t = (ulong) (length & (sizeof (int) - 1));
				if ((t) != 0)
					do
					{
						*dst++ = (sbyte) (*src++);
					} while ((--t) != 0);
			}
			else
			{
				src += length;
				dst += length;
				t = ((ulong) (src));
				if (((t | (ulong) (dst)) & (sizeof (int) - 1)) != 0)
				{
					if ((((t ^ (ulong) (dst)) & (sizeof (int) - 1)) != 0) || (length <= sizeof (int))) t = (ulong) (length);
					else t &= (ulong) (sizeof (int) - 1);
					length -= (ulong) (t);
					do
					{
						*--dst = (sbyte) (*--src);
					} while ((--t) != 0);
				}
				t = (ulong) (length/sizeof (int));
				if ((t) != 0)
					do
					{
						src -= sizeof (int);
						dst -= sizeof (int);
						*(int*) ((void*) (dst)) = (int) (*(int*) ((void*) (src)));
					} while ((--t) != 0);
				t = (ulong) (length & (sizeof (int) - 1));
				if ((t) != 0)
					do
					{
						*--dst = (sbyte) (*--src);
					} while ((--t) != 0);
			}

			done:
			;
			return (dst0);
		}

		public static void nk_memset(void* ptr, int c0, ulong size)
		{
			byte* dst = (byte*) (ptr);
			uint c = (uint) (0);
			ulong t = (ulong) (0);
			if ((c = (uint) ((byte) (c0))) != 0)
			{
				c = (uint) ((c << 8) | c);
				if (sizeof (uint) > 2) c = (uint) ((c << 16) | c);
			}

			dst = (byte*) (ptr);
			if ((size) < (3*sizeof (uint)))
			{
				while ((size--) != 0)
				{
					*dst++ = ((byte) (c0));
				}
				return;
			}

			if ((t = (ulong) (((ulong) ((long) (dst))) & (sizeof (uint) - 1))) != 0)
			{
				t = (ulong) (sizeof (uint) - t);
				size -= (ulong) (t);
				do
				{
					*dst++ = ((byte) (c0));
				} while (--t != 0);
			}

			t = (ulong) (size/sizeof (uint));
			do
			{
				*(uint*) ((void*) (dst)) = (uint) (c);
				dst += sizeof (uint);
			} while (--t != 0);
			t = (ulong) (size & (sizeof (uint) - 1));
			if (t != 0)
			{
				do
				{
					*dst++ = ((byte) (c0));
				} while (--t != 0);
			}

		}

		public static void nk_zero(void* ptr, ulong size)
		{
			nk_memset(ptr, (int) (0), (ulong) (size));
		}

		public static int nk_strlen(byte* str)
		{
			int siz = (int) (0);
			while (((str) != null) && (*str++ != '\0'))
			{
				siz++;
			}
			return (int) (siz);
		}

		public static int nk_strlen(char* str)
		{
			int siz = (int) (0);
			while (((str) != null) && (*str++ != '\0'))
			{
				siz++;
			}
			return (int) (siz);
		}

		public static int nk_strtoi(char* str, char** endptr)
		{
			int neg = (int) (1);
			char* p = str;
			int value = (int) (0);
			if (str == null) return (int) (0);
			while ((*p) == (' '))
			{
				p++;
			}
			if ((*p) == ('-'))
			{
				neg = (int) (-1);
				p++;
			}

			while ((((*p) != 0) && ((*p) >= ('0'))) && (*p <= '9'))
			{
				value = (int) (value*10 + (*p - '0'));
				p++;
			}
			if ((endptr) != null) *endptr = p;
			return (int) (neg*value);
		}

		public static double nk_strtod(char* str, char** endptr)
		{
			double m;
			double neg = (double) (1.0);
			char* p = str;
			double value = (double) (0);
			double number = (double) (0);
			if (str == null) return (double) (0);
			while ((*p) == (' '))
			{
				p++;
			}
			if ((*p) == ('-'))
			{
				neg = (double) (-1.0);
				p++;
			}

			while ((((*p) != 0) && (*p != '.')) && (*p != 'e'))
			{
				value = (double) (value*10.0 + (double) (*p - '0'));
				p++;
			}
			if ((*p) == ('.'))
			{
				p++;
				for (m = (double) (0.1); ((*p) != 0) && (*p != 'e'); p++)
				{
					value = (double) (value + (double) (*p - '0')*m);
					m *= (double) (0.1);
				}
			}

			if ((*p) == ('e'))
			{
				int i;
				int pow;
				int div;
				p++;
				if ((*p) == ('-'))
				{
					div = (int) (nk_true);
					p++;
				}
				else if ((*p) == ('+'))
				{
					div = (int) (nk_false);
					p++;
				}
				else div = (int) (nk_false);
				for (pow = (int) (0); *p != 0; p++)
				{
					pow = (int) (pow*10 + (*p - '0'));
				}
				for (m = (double) (1.0) , i = (int) (0); (i) < (pow); i++)
				{
					m *= (double) (10.0);
				}
				if ((div) != 0) value /= (double) (m);
				else value *= (double) (m);
			}

			number = (double) (value*neg);
			if ((endptr) != null) *endptr = p;
			return (double) (number);
		}

		public static float nk_strtof(char* str, char** endptr)
		{
			float float_value;
			double double_value;
			double_value = (double) (nk_strtod(str, endptr));
			float_value = ((float) (double_value));
			return (float) (float_value);
		}

		public static int nk_stricmpn(char* s1, char* s2, int n)
		{
			int c1;
			int c2;
			int d;
			do
			{
				c1 = (int) (*s1++);
				c2 = (int) (*s2++);
				if (n-- == 0) return (int) (0);
				d = (int) (c1 - c2);
				while ((d) != 0)
				{
					if ((c1 <= 'Z') && ((c1) >= ('A')))
					{
						d += (int) ('a' - 'A');
						if (d == 0) break;
					}
					if ((c2 <= 'Z') && ((c2) >= ('A')))
					{
						d -= (int) ('a' - 'A');
						if (d == 0) break;
					}
					return (int) ((((d) >= (0) ? 1 : 0) << 1) - 1);
				}
			} while ((c1) != 0);
			return (int) (0);
		}

		public static int nk_str_match_here(sbyte* regexp, char* text)
		{
			if ((regexp[0]) == ('\0')) return (int) (1);
			if ((regexp[1]) == ('*')) return (int) (nk_str_match_star((int) (regexp[0]), regexp + 2, text));
			if (((regexp[0]) == ('$')) && ((regexp[1]) == ('\0'))) return (int) ((*text) == ('\0') ? 1 : 0);
			if ((*text != '\0') && (((regexp[0]) == ('.')) || ((regexp[0]) == (*text))))
				return (int) (nk_str_match_here(regexp + 1, text + 1));
			return (int) (0);
		}

		public static int nk_str_match_star(int c, sbyte* regexp, char* text)
		{
			do
			{
				if ((nk_str_match_here(regexp, text)) != 0) return (int) (1);
			} while ((*text != '\0') && (((*text++) == (c)) || ((c) == ('.'))));
			return (int) (0);
		}

		public static int nk_string_float_limit(char* _string_, int prec)
		{
			int dot = (int) (0);
			char* c = _string_;
			while ((*c) != 0)
			{
				if ((*c) == ('.'))
				{
					dot = (int) (1);
					c++;
					continue;
				}
				if ((dot) == (prec + 1))
				{
					*c = (char) 0;
					break;
				}
				if ((dot) > (0)) dot++;
				c++;
			}
			return (int) (c - _string_);
		}

		public static double nk_pow(double x, int n)
		{
			double r = (double) (1);
			int plus = (int) ((n) >= (0) ? 1 : 0);
			n = (int) ((plus) != 0 ? n : -n);
			while ((n) > (0))
			{
				if ((n & 1) == (1)) r *= (double) (x);
				n /= (int) (2);
				x *= (double) (x);
			}
			return (double) ((plus) != 0 ? r : 1.0/r);
		}

		public static int nk_ifloord(double x)
		{
			x = ((double) ((int) (x) - (((x) < (0.0)) ? 1 : 0)));
			return (int) (x);
		}

		public static int nk_ifloorf(float x)
		{
			x = ((float) ((int) (x) - (((x) < (0.0f)) ? 1 : 0)));
			return (int) (x);
		}

		public static int nk_iceilf(float x)
		{
			if ((x) >= (0))
			{
				int i = (int) (x);
				return (int) (((x) > (i)) ? i + 1 : i);
			}
			else
			{
				int t = (int) (x);
				float r = (float) (x - (float) (t));
				return (int) (((r) > (0.0f)) ? t + 1 : t);
			}

		}

		public static int nk_log10(double n)
		{
			int neg;
			int ret;
			int exp = (int) (0);
			neg = (int) (((n) < (0)) ? 1 : 0);
			ret = (int) ((neg) != 0 ? (int) (-n) : (int) (n));
			while ((ret/10) > (0))
			{
				ret /= (int) (10);
				exp++;
			}
			if ((neg) != 0) exp = (int) (-exp);
			return (int) (exp);
		}

		public static void nk_strrev_ascii(char* s)
		{
			int len = (int) (nk_strlen(s));
			int end = (int) (len/2);
			int i = (int) (0);
			char t;
			for (; (i) < (end); ++i)
			{
				t = (s[i]);
				s[i] = (s[len - 1 - i]);
				s[len - 1 - i] = t;
			}
		}

		public static char* nk_itoa(char* s, int n)
		{
			int i = (int) (0);
			if ((n) == (0))
			{
				s[i++] = ('0');
				s[i] = (char) (0);
				return s;
			}

			if ((n) < (0))
			{
				s[i++] = ('-');
				n = (int) (-n);
			}

			while ((n) > (0))
			{
				s[i++] = (char) (('0' + (char) (n%10)));
				n /= (int) (10);
			}
			s[i] = (char) (0);
			if ((s[0]) == ('-')) ++s;
			nk_strrev_ascii(s);
			return s;
		}

		public static char* nk_dtoa(char* s, double n)
		{
			int useExp = (int) (0);
			int digit = (int) (0);
			int m = (int) (0);
			int m1 = (int) (0);
			char* c = s;
			int neg = (int) (0);
			if (s == null) return null;
			if ((n) == (0.0))
			{
				s[0] = ('0');
				s[1] = ('\0');
				return s;
			}

			neg = (int) ((n) < (0) ? 1 : 0);
			if ((neg) != 0) n = (double) (-n);
			m = (int) (nk_log10((double) (n)));
			useExp = (int) ((((m) >= (14)) || (((neg) != 0) && ((m) >= (9)))) || (m <= -9) ? 1 : 0);
			if ((neg) != 0) *(c++) = ('-');
			if ((useExp) != 0)
			{
				if ((m) < (0)) m -= (int) (1);
				n = (double) (n/nk_pow((double) (10.0), (int) (m)));
				m1 = (int) (m);
				m = (int) (0);
			}

			if ((m) < (1.0))
			{
				m = (int) (0);
			}

			while (((n) > (0.00000000000001)) || ((m) >= (0)))
			{
				double weight = (double) (nk_pow((double) (10.0), (int) (m)));
				if ((weight) > (0))
				{
					double t = (double) (n/weight);
					digit = (int) (nk_ifloord((double) (t)));
					n -= (double) ((double) (digit)*weight);
					*(c++) = (char) (('0' + (char) (digit)));
				}
				if (((m) == (0)) && ((n) > (0))) *(c++) = ('.');
				m--;
			}
			if ((useExp) != 0)
			{
				int i;
				int j;
				*(c++) = ('e');
				if ((m1) > (0))
				{
					*(c++) = ('+');
				}
				else
				{
					*(c++) = ('-');
					m1 = (int) (-m1);
				}
				m = (int) (0);
				while ((m1) > (0))
				{
					*(c++) = (char) (('0' + (char) (m1%10)));
					m1 /= (int) (10);
					m++;
				}
				c -= m;
				for (i = (int) (0) , j = (int) (m - 1); (i) < (j); i++ , j--)
				{
					c[i] ^= (c[j]);
					c[j] ^= (c[i]);
					c[i] ^= (c[j]);
				}
				c += m;
			}

			*(c) = ('\0');
			return s;
		}

		public static uint nk_murmur_hash(void* key, int len, uint seed)
		{
			nk_murmur_hash_union conv = new nk_murmur_hash_union(null);
			byte* data = (byte*) (key);
			int nblocks = (int) (len/4);
			uint h1 = (uint) (seed);
			uint c1 = (uint) (0xcc9e2d51);
			uint c2 = (uint) (0x1b873593);
			byte* tail;
			uint* blocks;
			uint k1;
			int i;
			if (key == null) return (uint) (0);
			conv.b = (data + nblocks*4);
			blocks = conv.i;
			for (i = (int) (-nblocks); i != 0; ++i)
			{
				k1 = (uint) (blocks[i]);
				k1 *= (uint) (c1);
				k1 = (uint) ((k1) << (15) | ((k1) >> (32 - 15)));
				k1 *= (uint) (c2);
				h1 ^= (uint) (k1);
				h1 = (uint) ((h1) << (13) | ((h1) >> (32 - 13)));
				h1 = (uint) (h1*5 + 0xe6546b64);
			}
			tail = (data + nblocks*4);
			k1 = (uint) (0);
			int l = (int) (len & 3);
			switch (l)
			{
				case 1:
				case 2:
				case 3:
					if ((l) == (2))
					{
						k1 ^= ((uint) (tail[1] << 8));
					}
					else if ((l) == (3))
					{
						k1 ^= ((uint) (tail[2] << 16));
					}
					k1 ^= (uint) (tail[0]);
					k1 *= (uint) (c1);
					k1 = (uint) ((k1) << (15) | ((k1) >> (32 - 15)));
					k1 *= (uint) (c2);
					h1 ^= (uint) (k1);
					break;
				default:
					break;
			}

			h1 ^= ((uint) (len));
			h1 ^= (uint) (h1 >> 16);
			h1 *= (uint) (0x85ebca6b);
			h1 ^= (uint) (h1 >> 13);
			h1 *= (uint) (0xc2b2ae35);
			h1 ^= (uint) (h1 >> 16);
			return (uint) (h1);
		}

		public static int nk_parse_hex(sbyte* p, int length)
		{
			int i = (int) (0);
			int len = (int) (0);
			while ((len) < (length))
			{
				i <<= 4;
				if (((p[len]) >= ('a')) && (p[len] <= 'f')) i += (int) ((p[len] - 'a') + 10);
				else if (((p[len]) >= ('A')) && (p[len] <= 'F')) i += (int) ((p[len] - 'A') + 10);
				else i += (int) (p[len] - '0');
				len++;
			}
			return (int) (i);
		}

		public static nk_color nk_rgba(int r, int g, int b, int a)
		{
			nk_color ret = new nk_color();
			ret.r = ((byte) (((r) < (255) ? (r) : (255)) < (0) ? (0) : ((r) < (255) ? (r) : (255))));
			ret.g = ((byte) (((g) < (255) ? (g) : (255)) < (0) ? (0) : ((g) < (255) ? (g) : (255))));
			ret.b = ((byte) (((b) < (255) ? (b) : (255)) < (0) ? (0) : ((b) < (255) ? (b) : (255))));
			ret.a = ((byte) (((a) < (255) ? (a) : (255)) < (0) ? (0) : ((a) < (255) ? (a) : (255))));
			return (nk_color) (ret);
		}

		public static nk_color nk_rgb_hex(sbyte* rgb)
		{
			nk_color col = new nk_color();
			sbyte* c = rgb;
			if ((*c) == ('#')) c++;
			col.r = ((byte) (nk_parse_hex(c, (int) (2))));
			col.g = ((byte) (nk_parse_hex(c + 2, (int) (2))));
			col.b = ((byte) (nk_parse_hex(c + 4, (int) (2))));
			col.a = (byte) (255);
			return (nk_color) (col);
		}

		public static nk_color nk_rgba_hex(sbyte* rgb)
		{
			nk_color col = new nk_color();
			sbyte* c = rgb;
			if ((*c) == ('#')) c++;
			col.r = ((byte) (nk_parse_hex(c, (int) (2))));
			col.g = ((byte) (nk_parse_hex(c + 2, (int) (2))));
			col.b = ((byte) (nk_parse_hex(c + 4, (int) (2))));
			col.a = ((byte) (nk_parse_hex(c + 6, (int) (2))));
			return (nk_color) (col);
		}

		public static void nk_color_hex_rgba(char* output, nk_color col)
		{
			output[0] = ((char) (((col.r & 0xF0) >> 4) <= 9 ? '0' + ((col.r & 0xF0) >> 4) : 'A' - 10 + ((col.r & 0xF0) >> 4)));
			output[1] = ((char) ((col.r & 0x0F) <= 9 ? '0' + (col.r & 0x0F) : 'A' - 10 + (col.r & 0x0F)));
			output[2] = ((char) (((col.g & 0xF0) >> 4) <= 9 ? '0' + ((col.g & 0xF0) >> 4) : 'A' - 10 + ((col.g & 0xF0) >> 4)));
			output[3] = ((char) ((col.g & 0x0F) <= 9 ? '0' + (col.g & 0x0F) : 'A' - 10 + (col.g & 0x0F)));
			output[4] = ((char) (((col.b & 0xF0) >> 4) <= 9 ? '0' + ((col.b & 0xF0) >> 4) : 'A' - 10 + ((col.b & 0xF0) >> 4)));
			output[5] = ((char) ((col.b & 0x0F) <= 9 ? '0' + (col.b & 0x0F) : 'A' - 10 + (col.b & 0x0F)));
			output[6] = ((char) (((col.a & 0xF0) >> 4) <= 9 ? '0' + ((col.a & 0xF0) >> 4) : 'A' - 10 + ((col.a & 0xF0) >> 4)));
			output[7] = ((char) ((col.a & 0x0F) <= 9 ? '0' + (col.a & 0x0F) : 'A' - 10 + (col.a & 0x0F)));
			output[8] = ('\0');
		}

		public static void nk_color_hex_rgb(char* output, nk_color col)
		{
			output[0] = ((char) (((col.r & 0xF0) >> 4) <= 9 ? '0' + ((col.r & 0xF0) >> 4) : 'A' - 10 + ((col.r & 0xF0) >> 4)));
			output[1] = ((char) ((col.r & 0x0F) <= 9 ? '0' + (col.r & 0x0F) : 'A' - 10 + (col.r & 0x0F)));
			output[2] = ((char) (((col.g & 0xF0) >> 4) <= 9 ? '0' + ((col.g & 0xF0) >> 4) : 'A' - 10 + ((col.g & 0xF0) >> 4)));
			output[3] = ((char) ((col.g & 0x0F) <= 9 ? '0' + (col.g & 0x0F) : 'A' - 10 + (col.g & 0x0F)));
			output[4] = ((char) (((col.b & 0xF0) >> 4) <= 9 ? '0' + ((col.b & 0xF0) >> 4) : 'A' - 10 + ((col.b & 0xF0) >> 4)));
			output[5] = ((char) ((col.b & 0x0F) <= 9 ? '0' + (col.b & 0x0F) : 'A' - 10 + (col.b & 0x0F)));
			output[6] = ('\0');
		}

		public static nk_color nk_rgba_iv(int* c)
		{
			return (nk_color) (nk_rgba((int) (c[0]), (int) (c[1]), (int) (c[2]), (int) (c[3])));
		}

		public static nk_color nk_rgba_bv(byte* c)
		{
			return (nk_color) (nk_rgba((int) (c[0]), (int) (c[1]), (int) (c[2]), (int) (c[3])));
		}

		public static nk_color nk_rgb(int r, int g, int b)
		{
			nk_color ret = new nk_color();
			ret.r = ((byte) (((r) < (255) ? (r) : (255)) < (0) ? (0) : ((r) < (255) ? (r) : (255))));
			ret.g = ((byte) (((g) < (255) ? (g) : (255)) < (0) ? (0) : ((g) < (255) ? (g) : (255))));
			ret.b = ((byte) (((b) < (255) ? (b) : (255)) < (0) ? (0) : ((b) < (255) ? (b) : (255))));
			ret.a = ((byte) (255));
			return (nk_color) (ret);
		}

		public static nk_color nk_rgb_iv(int* c)
		{
			return (nk_color) (nk_rgb((int) (c[0]), (int) (c[1]), (int) (c[2])));
		}

		public static nk_color nk_rgb_bv(byte* c)
		{
			return (nk_color) (nk_rgb((int) (c[0]), (int) (c[1]), (int) (c[2])));
		}

		public static nk_color nk_rgba_u32(uint _in_)
		{
			nk_color ret = new nk_color();
			ret.r = (byte) (_in_ & 0xFF);
			ret.g = (byte) ((_in_ >> 8) & 0xFF);
			ret.b = (byte) ((_in_ >> 16) & 0xFF);
			ret.a = ((byte) ((_in_ >> 24) & 0xFF));
			return (nk_color) (ret);
		}

		public static nk_color nk_rgba_f(float r, float g, float b, float a)
		{
			nk_color ret = new nk_color();
			ret.r = ((byte) (((0) < ((1.0f) < (r) ? (1.0f) : (r)) ? ((1.0f) < (r) ? (1.0f) : (r)) : (0))*255.0f));
			ret.g = ((byte) (((0) < ((1.0f) < (g) ? (1.0f) : (g)) ? ((1.0f) < (g) ? (1.0f) : (g)) : (0))*255.0f));
			ret.b = ((byte) (((0) < ((1.0f) < (b) ? (1.0f) : (b)) ? ((1.0f) < (b) ? (1.0f) : (b)) : (0))*255.0f));
			ret.a = ((byte) (((0) < ((1.0f) < (a) ? (1.0f) : (a)) ? ((1.0f) < (a) ? (1.0f) : (a)) : (0))*255.0f));
			return (nk_color) (ret);
		}

		public static nk_color nk_rgba_fv(float* c)
		{
			return (nk_color) (nk_rgba_f((float) (c[0]), (float) (c[1]), (float) (c[2]), (float) (c[3])));
		}

		public static nk_color nk_rgba_cf(nk_colorf c)
		{
			return (nk_color) (nk_rgba_f((float) (c.r), (float) (c.g), (float) (c.b), (float) (c.a)));
		}

		public static nk_color nk_rgb_f(float r, float g, float b)
		{
			nk_color ret = new nk_color();
			ret.r = ((byte) (((0) < ((1.0f) < (r) ? (1.0f) : (r)) ? ((1.0f) < (r) ? (1.0f) : (r)) : (0))*255.0f));
			ret.g = ((byte) (((0) < ((1.0f) < (g) ? (1.0f) : (g)) ? ((1.0f) < (g) ? (1.0f) : (g)) : (0))*255.0f));
			ret.b = ((byte) (((0) < ((1.0f) < (b) ? (1.0f) : (b)) ? ((1.0f) < (b) ? (1.0f) : (b)) : (0))*255.0f));
			ret.a = (byte) (255);
			return (nk_color) (ret);
		}

		public static nk_color nk_rgb_fv(float* c)
		{
			return (nk_color) (nk_rgb_f((float) (c[0]), (float) (c[1]), (float) (c[2])));
		}

		public static nk_color nk_rgb_cf(nk_colorf c)
		{
			return (nk_color) (nk_rgb_f((float) (c.r), (float) (c.g), (float) (c.b)));
		}

		public static nk_color nk_hsv(int h, int s, int v)
		{
			return (nk_color) (nk_hsva((int) (h), (int) (s), (int) (v), (int) (255)));
		}

		public static nk_color nk_hsv_iv(int* c)
		{
			return (nk_color) (nk_hsv((int) (c[0]), (int) (c[1]), (int) (c[2])));
		}

		public static nk_color nk_hsv_bv(byte* c)
		{
			return (nk_color) (nk_hsv((int) (c[0]), (int) (c[1]), (int) (c[2])));
		}

		public static nk_color nk_hsv_f(float h, float s, float v)
		{
			return (nk_color) (nk_hsva_f((float) (h), (float) (s), (float) (v), (float) (1.0f)));
		}

		public static nk_color nk_hsv_fv(float* c)
		{
			return (nk_color) (nk_hsv_f((float) (c[0]), (float) (c[1]), (float) (c[2])));
		}

		public static nk_color nk_hsva(int h, int s, int v, int a)
		{
			float hf = (float) (((float) (((h) < (255) ? (h) : (255)) < (0) ? (0) : ((h) < (255) ? (h) : (255))))/255.0f);
			float sf = (float) (((float) (((s) < (255) ? (s) : (255)) < (0) ? (0) : ((s) < (255) ? (s) : (255))))/255.0f);
			float vf = (float) (((float) (((v) < (255) ? (v) : (255)) < (0) ? (0) : ((v) < (255) ? (v) : (255))))/255.0f);
			float af = (float) (((float) (((a) < (255) ? (a) : (255)) < (0) ? (0) : ((a) < (255) ? (a) : (255))))/255.0f);
			return (nk_color) (nk_hsva_f((float) (hf), (float) (sf), (float) (vf), (float) (af)));
		}

		public static nk_color nk_hsva_iv(int* c)
		{
			return (nk_color) (nk_hsva((int) (c[0]), (int) (c[1]), (int) (c[2]), (int) (c[3])));
		}

		public static nk_color nk_hsva_bv(byte* c)
		{
			return (nk_color) (nk_hsva((int) (c[0]), (int) (c[1]), (int) (c[2]), (int) (c[3])));
		}

		public static nk_colorf nk_hsva_colorf(float h, float s, float v, float a)
		{
			int i;
			float p;
			float q;
			float t;
			float f;
			nk_colorf _out_ = new nk_colorf();
			if (s <= 0.0f)
			{
				_out_.r = (float) (v);
				_out_.g = (float) (v);
				_out_.b = (float) (v);
				_out_.a = (float) (a);
				return (nk_colorf) (_out_);
			}

			h = (float) (h/(60.0f/360.0f));
			i = ((int) (h));
			f = (float) (h - (float) (i));
			p = (float) (v*(1.0f - s));
			q = (float) (v*(1.0f - (s*f)));
			t = (float) (v*(1.0f - s*(1.0f - f)));
			switch (i)
			{
				case 0:
				default:
					_out_.r = (float) (v);
					_out_.g = (float) (t);
					_out_.b = (float) (p);
					break;
				case 1:
					_out_.r = (float) (q);
					_out_.g = (float) (v);
					_out_.b = (float) (p);
					break;
				case 2:
					_out_.r = (float) (p);
					_out_.g = (float) (v);
					_out_.b = (float) (t);
					break;
				case 3:
					_out_.r = (float) (p);
					_out_.g = (float) (q);
					_out_.b = (float) (v);
					break;
				case 4:
					_out_.r = (float) (t);
					_out_.g = (float) (p);
					_out_.b = (float) (v);
					break;
				case 5:
					_out_.r = (float) (v);
					_out_.g = (float) (p);
					_out_.b = (float) (q);
					break;
			}

			_out_.a = (float) (a);
			return (nk_colorf) (_out_);
		}

		public static nk_colorf nk_hsva_colorfv(float* c)
		{
			return (nk_colorf) (nk_hsva_colorf((float) (c[0]), (float) (c[1]), (float) (c[2]), (float) (c[3])));
		}

		public static nk_color nk_hsva_f(float h, float s, float v, float a)
		{
			nk_colorf c = (nk_colorf) (nk_hsva_colorf((float) (h), (float) (s), (float) (v), (float) (a)));
			return (nk_color) (nk_rgba_f((float) (c.r), (float) (c.g), (float) (c.b), (float) (c.a)));
		}

		public static nk_color nk_hsva_fv(float* c)
		{
			return (nk_color) (nk_hsva_f((float) (c[0]), (float) (c[1]), (float) (c[2]), (float) (c[3])));
		}

		public static uint nk_color_u32(nk_color _in_)
		{
			uint _out_ = (uint) (_in_.r);
			_out_ |= (uint) ((uint) (_in_.g) << 8);
			_out_ |= (uint) ((uint) (_in_.b) << 16);
			_out_ |= (uint) ((uint) (_in_.a) << 24);
			return (uint) (_out_);
		}

		public static void nk_color_f(float* r, float* g, float* b, float* a, nk_color _in_)
		{
			float s = (float) (1.0f/255.0f);
			*r = (float) ((float) (_in_.r)*s);
			*g = (float) ((float) (_in_.g)*s);
			*b = (float) ((float) (_in_.b)*s);
			*a = (float) ((float) (_in_.a)*s);
		}

		public static void nk_color_fv(float* c, nk_color _in_)
		{
			nk_color_f(&c[0], &c[1], &c[2], &c[3], (nk_color) (_in_));
		}

		public static nk_colorf nk_color_cf(nk_color _in_)
		{
			nk_colorf o = new nk_colorf();
			nk_color_f(&o.r, &o.g, &o.b, &o.a, (nk_color) (_in_));
			return (nk_colorf) (o);
		}

		public static void nk_color_d(double* r, double* g, double* b, double* a, nk_color _in_)
		{
			double s = (double) (1.0/255.0);
			*r = (double) ((double) (_in_.r)*s);
			*g = (double) ((double) (_in_.g)*s);
			*b = (double) ((double) (_in_.b)*s);
			*a = (double) ((double) (_in_.a)*s);
		}

		public static void nk_color_dv(double* c, nk_color _in_)
		{
			nk_color_d(&c[0], &c[1], &c[2], &c[3], (nk_color) (_in_));
		}

		public static void nk_color_hsv_f(float* out_h, float* out_s, float* out_v, nk_color _in_)
		{
			float a;
			nk_color_hsva_f(out_h, out_s, out_v, &a, (nk_color) (_in_));
		}

		public static void nk_color_hsv_fv(float* _out_, nk_color _in_)
		{
			float a;
			nk_color_hsva_f(&_out_[0], &_out_[1], &_out_[2], &a, (nk_color) (_in_));
		}

		public static void nk_colorf_hsva_f(float* out_h, float* out_s, float* out_v, float* out_a, nk_colorf _in_)
		{
			float chroma;
			float K = (float) (0.0f);
			if ((_in_.g) < (_in_.b))
			{
				float t = (float) (_in_.g);
				_in_.g = (float) (_in_.b);
				_in_.b = (float) (t);
				K = (float) (-1.0f);
			}

			if ((_in_.r) < (_in_.g))
			{
				float t = (float) (_in_.r);
				_in_.r = (float) (_in_.g);
				_in_.g = (float) (t);
				K = (float) (-2.0f/6.0f - K);
			}

			chroma = (float) (_in_.r - (((_in_.g) < (_in_.b)) ? _in_.g : _in_.b));
			*out_h =
				(float)
					(((K + (_in_.g - _in_.b)/(6.0f*chroma + 1e-20f)) < (0))
						? -(K + (_in_.g - _in_.b)/(6.0f*chroma + 1e-20f))
						: (K + (_in_.g - _in_.b)/(6.0f*chroma + 1e-20f)));
			*out_s = (float) (chroma/(_in_.r + 1e-20f));
			*out_v = (float) (_in_.r);
			*out_a = (float) (_in_.a);
		}

		public static void nk_colorf_hsva_fv(float* hsva, nk_colorf _in_)
		{
			nk_colorf_hsva_f(&hsva[0], &hsva[1], &hsva[2], &hsva[3], (nk_colorf) (_in_));
		}

		public static void nk_color_hsva_f(float* out_h, float* out_s, float* out_v, float* out_a, nk_color _in_)
		{
			nk_colorf col = new nk_colorf();
			nk_color_f(&col.r, &col.g, &col.b, &col.a, (nk_color) (_in_));
			nk_colorf_hsva_f(out_h, out_s, out_v, out_a, (nk_colorf) (col));
		}

		public static void nk_color_hsva_fv(float* _out_, nk_color _in_)
		{
			nk_color_hsva_f(&_out_[0], &_out_[1], &_out_[2], &_out_[3], (nk_color) (_in_));
		}

		public static void nk_color_hsva_i(int* out_h, int* out_s, int* out_v, int* out_a, nk_color _in_)
		{
			float h;
			float s;
			float v;
			float a;
			nk_color_hsva_f(&h, &s, &v, &a, (nk_color) (_in_));
			*out_h = (int) ((byte) (h*255.0f));
			*out_s = (int) ((byte) (s*255.0f));
			*out_v = (int) ((byte) (v*255.0f));
			*out_a = (int) ((byte) (a*255.0f));
		}

		public static void nk_color_hsva_iv(int* _out_, nk_color _in_)
		{
			nk_color_hsva_i(&_out_[0], &_out_[1], &_out_[2], &_out_[3], (nk_color) (_in_));
		}

		public static void nk_color_hsva_bv(byte* _out_, nk_color _in_)
		{
			int* tmp = stackalloc int[4];
			nk_color_hsva_i(&tmp[0], &tmp[1], &tmp[2], &tmp[3], (nk_color) (_in_));
			_out_[0] = ((byte) (tmp[0]));
			_out_[1] = ((byte) (tmp[1]));
			_out_[2] = ((byte) (tmp[2]));
			_out_[3] = ((byte) (tmp[3]));
		}

		public static void nk_color_hsva_b(byte* h, byte* s, byte* v, byte* a, nk_color _in_)
		{
			int* tmp = stackalloc int[4];
			nk_color_hsva_i(&tmp[0], &tmp[1], &tmp[2], &tmp[3], (nk_color) (_in_));
			*h = ((byte) (tmp[0]));
			*s = ((byte) (tmp[1]));
			*v = ((byte) (tmp[2]));
			*a = ((byte) (tmp[3]));
		}

		public static void nk_color_hsv_i(int* out_h, int* out_s, int* out_v, nk_color _in_)
		{
			int a;
			nk_color_hsva_i(out_h, out_s, out_v, &a, (nk_color) (_in_));
		}

		public static void nk_color_hsv_b(byte* out_h, byte* out_s, byte* out_v, nk_color _in_)
		{
			int* tmp = stackalloc int[4];
			nk_color_hsva_i(&tmp[0], &tmp[1], &tmp[2], &tmp[3], (nk_color) (_in_));
			*out_h = ((byte) (tmp[0]));
			*out_s = ((byte) (tmp[1]));
			*out_v = ((byte) (tmp[2]));
		}

		public static void nk_color_hsv_iv(int* _out_, nk_color _in_)
		{
			nk_color_hsv_i(&_out_[0], &_out_[1], &_out_[2], (nk_color) (_in_));
		}

		public static void nk_color_hsv_bv(byte* _out_, nk_color _in_)
		{
			int* tmp = stackalloc int[4];
			nk_color_hsv_i(&tmp[0], &tmp[1], &tmp[2], (nk_color) (_in_));
			_out_[0] = ((byte) (tmp[0]));
			_out_[1] = ((byte) (tmp[1]));
			_out_[2] = ((byte) (tmp[2]));
		}

		public static nk_handle nk_handle_ptr(void* ptr)
		{
			nk_handle handle = new nk_handle();
			handle.ptr = ptr;
			return (nk_handle) (handle);
		}

		public static nk_handle nk_handle_id(int id)
		{
			nk_handle handle = new nk_handle();
			nk_zero(&handle, (ulong) (sizeof (nk_handle)));
			handle.id = (int) (id);
			return (nk_handle) (handle);
		}

		public static nk_image nk_subimage_ptr(void* ptr, ushort w, ushort h, nk_rect r)
		{
			nk_image s = new nk_image();

			s.handle.ptr = ptr;
			s.w = (ushort) (w);
			s.h = (ushort) (h);
			s.region[0] = ((ushort) (r.x));
			s.region[1] = ((ushort) (r.y));
			s.region[2] = ((ushort) (r.w));
			s.region[3] = ((ushort) (r.h));
			return (nk_image) (s);
		}

		public static nk_image nk_subimage_id(int id, ushort w, ushort h, nk_rect r)
		{
			nk_image s = new nk_image();

			s.handle.id = (int) (id);
			s.w = (ushort) (w);
			s.h = (ushort) (h);
			s.region[0] = ((ushort) (r.x));
			s.region[1] = ((ushort) (r.y));
			s.region[2] = ((ushort) (r.w));
			s.region[3] = ((ushort) (r.h));
			return (nk_image) (s);
		}

		public static nk_image nk_subimage_handle(nk_handle handle, ushort w, ushort h, nk_rect r)
		{
			nk_image s = new nk_image();

			s.handle = (nk_handle) (handle);
			s.w = (ushort) (w);
			s.h = (ushort) (h);
			s.region[0] = ((ushort) (r.x));
			s.region[1] = ((ushort) (r.y));
			s.region[2] = ((ushort) (r.w));
			s.region[3] = ((ushort) (r.h));
			return (nk_image) (s);
		}

		public static nk_image nk_image_handle(nk_handle handle)
		{
			nk_image s = new nk_image();

			s.handle = (nk_handle) (handle);
			s.w = (ushort) (0);
			s.h = (ushort) (0);
			s.region[0] = (ushort) (0);
			s.region[1] = (ushort) (0);
			s.region[2] = (ushort) (0);
			s.region[3] = (ushort) (0);
			return (nk_image) (s);
		}

		public static nk_image nk_image_ptr(void* ptr)
		{
			nk_image s = new nk_image();

			s.handle.ptr = ptr;
			s.w = (ushort) (0);
			s.h = (ushort) (0);
			s.region[0] = (ushort) (0);
			s.region[1] = (ushort) (0);
			s.region[2] = (ushort) (0);
			s.region[3] = (ushort) (0);
			return (nk_image) (s);
		}

		public static nk_image nk_image_id(int id)
		{
			nk_image s = new nk_image();

			s.handle.id = (int) (id);
			s.w = (ushort) (0);
			s.h = (ushort) (0);
			s.region[0] = (ushort) (0);
			s.region[1] = (ushort) (0);
			s.region[2] = (ushort) (0);
			s.region[3] = (ushort) (0);
			return (nk_image) (s);
		}

		public static int nk_image_is_subimage(nk_image img)
		{
			return (int) ((((img.w) == (0)) && ((img.h) == (0))) ? 1 : 0);
		}

		public static void nk_unify(ref nk_rect clip, ref nk_rect a, float x0, float y0, float x1, float y1)
		{
			clip.x = (float) ((a.x) < (x0) ? (x0) : (a.x));
			clip.y = (float) ((a.y) < (y0) ? (y0) : (a.y));
			clip.w = (float) (((a.x + a.w) < (x1) ? (a.x + a.w) : (x1)) - clip.x);
			clip.h = (float) (((a.y + a.h) < (y1) ? (a.y + a.h) : (y1)) - clip.y);
			clip.w = (float) ((0) < (clip.w) ? (clip.w) : (0));
			clip.h = (float) ((0) < (clip.h) ? (clip.h) : (0));
		}

		public static void nk_triangle_from_direction(nk_vec2* result, nk_rect r, float pad_x, float pad_y, int direction)
		{
			float w_half;
			float h_half;
			r.w = (float) ((2*pad_x) < (r.w) ? (r.w) : (2*pad_x));
			r.h = (float) ((2*pad_y) < (r.h) ? (r.h) : (2*pad_y));
			r.w = (float) (r.w - 2*pad_x);
			r.h = (float) (r.h - 2*pad_y);
			r.x = (float) (r.x + pad_x);
			r.y = (float) (r.y + pad_y);
			w_half = (float) (r.w/2.0f);
			h_half = (float) (r.h/2.0f);
			if ((direction) == (NK_UP))
			{
				result[0] = (nk_vec2) (nk_vec2_((float) (r.x + w_half), (float) (r.y)));
				result[1] = (nk_vec2) (nk_vec2_((float) (r.x + r.w), (float) (r.y + r.h)));
				result[2] = (nk_vec2) (nk_vec2_((float) (r.x), (float) (r.y + r.h)));
			}
			else if ((direction) == (NK_RIGHT))
			{
				result[0] = (nk_vec2) (nk_vec2_((float) (r.x), (float) (r.y)));
				result[1] = (nk_vec2) (nk_vec2_((float) (r.x + r.w), (float) (r.y + h_half)));
				result[2] = (nk_vec2) (nk_vec2_((float) (r.x), (float) (r.y + r.h)));
			}
			else if ((direction) == (NK_DOWN))
			{
				result[0] = (nk_vec2) (nk_vec2_((float) (r.x), (float) (r.y)));
				result[1] = (nk_vec2) (nk_vec2_((float) (r.x + r.w), (float) (r.y)));
				result[2] = (nk_vec2) (nk_vec2_((float) (r.x + w_half), (float) (r.y + r.h)));
			}
			else
			{
				result[0] = (nk_vec2) (nk_vec2_((float) (r.x), (float) (r.y + h_half)));
				result[1] = (nk_vec2) (nk_vec2_((float) (r.x + r.w), (float) (r.y)));
				result[2] = (nk_vec2) (nk_vec2_((float) (r.x + r.w), (float) (r.y + r.h)));
			}

		}

		public static int nk_text_clamp(nk_user_font font, char* text, int text_len, float space, int* glyphs,
			float* text_width, uint* sep_list, int sep_count)
		{
			int i = (int) (0);
			int glyph_len = (int) (0);
			float last_width = (float) (0);
			char unicode = (char) 0;
			float width = (float) (0);
			int len = (int) (0);
			int g = (int) (0);
			float s;
			int sep_len = (int) (0);
			int sep_g = (int) (0);
			float sep_width = (float) (0);
			sep_count = (int) ((sep_count) < (0) ? (0) : (sep_count));
			glyph_len = (int) (nk_utf_decode(text, &unicode, (int) (text_len)));
			while ((((glyph_len) != 0) && ((width) < (space))) && ((len) < (text_len)))
			{
				len += (int) (glyph_len);
				s = (float) (font.width((nk_handle) (font.userdata), (float) (font.height), text, (int) (len)));
				for (i = (int) (0); (i) < (sep_count); ++i)
				{
					if (unicode != sep_list[i]) continue;
					sep_width = (float) (last_width = (float) (width));
					sep_g = (int) (g + 1);
					sep_len = (int) (len);
					break;
				}
				if ((i) == (sep_count))
				{
					last_width = (float) (sep_width = (float) (width));
					sep_g = (int) (g + 1);
				}
				width = (float) (s);
				glyph_len = (int) (nk_utf_decode(text + len, &unicode, (int) (text_len - len)));
				g++;
			}
			if ((len) >= (text_len))
			{
				*glyphs = (int) (g);
				*text_width = (float) (last_width);
				return (int) (len);
			}
			else
			{
				*glyphs = (int) (sep_g);
				*text_width = (float) (sep_width);
				return (int) ((sep_len == 0) ? len : sep_len);
			}

		}

		public static nk_vec2 nk_text_calculate_text_bounds(nk_user_font font, char* begin, int byte_len, float row_height,
			char** remaining, nk_vec2* out_offset, int* glyphs, int op)
		{
			float line_height = (float) (row_height);
			nk_vec2 text_size = (nk_vec2) (nk_vec2_((float) (0), (float) (0)));
			float line_width = (float) (0.0f);
			float glyph_width;
			int glyph_len = (int) (0);
			char unicode = (char) 0;
			int text_len = (int) (0);
			if (((begin == null) || (byte_len <= 0)) || (font == null))
				return (nk_vec2) (nk_vec2_((float) (0), (float) (row_height)));
			glyph_len = (int) (nk_utf_decode(begin, &unicode, (int) (byte_len)));
			if (glyph_len == 0) return (nk_vec2) (text_size);
			glyph_width = (float) (font.width((nk_handle) (font.userdata), (float) (font.height), begin, (int) (glyph_len)));
			*glyphs = (int) (0);
			while (((text_len) < (byte_len)) && ((glyph_len) != 0))
			{
				if ((unicode) == ('\n'))
				{
					text_size.x = (float) ((text_size.x) < (line_width) ? (line_width) : (text_size.x));
					text_size.y += (float) (line_height);
					line_width = (float) (0);
					*glyphs += (int) (1);
					if ((op) == (NK_STOP_ON_NEW_LINE)) break;
					text_len++;
					glyph_len = (int) (nk_utf_decode(begin + text_len, &unicode, (int) (byte_len - text_len)));
					continue;
				}
				if ((unicode) == ('\r'))
				{
					text_len++;
					*glyphs += (int) (1);
					glyph_len = (int) (nk_utf_decode(begin + text_len, &unicode, (int) (byte_len - text_len)));
					continue;
				}
				*glyphs = (int) (*glyphs + 1);
				text_len += (int) (glyph_len);
				line_width += (float) (glyph_width);
				glyph_len = (int) (nk_utf_decode(begin + text_len, &unicode, (int) (byte_len - text_len)));
				glyph_width =
					(float) (font.width((nk_handle) (font.userdata), (float) (font.height), begin + text_len, (int) (glyph_len)));
				continue;
			}
			if ((text_size.x) < (line_width)) text_size.x = (float) (line_width);
			if ((out_offset) != null)
				*out_offset = (nk_vec2) (nk_vec2_((float) (line_width), (float) (text_size.y + line_height)));
			if (((line_width) > (0)) || ((text_size.y) == (0.0f))) text_size.y += (float) (line_height);
			if ((remaining) != null) *remaining = begin + text_len;
			return (nk_vec2) (text_size);
		}

		public static void* nk_malloc(nk_handle unused, void* old, ulong size)
		{
			return CRuntime.malloc((ulong) (size));
		}

		public static void nk_mfree(nk_handle unused, void* ptr)
		{
			CRuntime.free(ptr);
		}

		public static void nk_buffer_init(nk_buffer b, ulong initial_size)
		{
			if (((b == null)) || (initial_size == 0)) return;

			b.type = (int) (NK_BUFFER_DYNAMIC);
			b.memory.ptr = CRuntime.malloc((ulong) (initial_size));
			b.memory.size = (ulong) (initial_size);
			b.size = (ulong) (initial_size);
			b.grow_factor = (float) (2.0f);

		}

		public static void nk_buffer_init_fixed(nk_buffer b, void* m, ulong size)
		{
			if (((b == null) || (m == null)) || (size == 0)) return;

			b.type = (int) (NK_BUFFER_FIXED);
			b.memory.ptr = m;
			b.memory.size = (ulong) (size);
			b.size = (ulong) (size);
		}

		public static void* nk_buffer_align(void* unaligned, ulong align, ulong* alignment, int type)
		{
			void* memory = null;
			switch (type)
			{
				default:
				case NK_BUFFER_MAX:
				case NK_BUFFER_FRONT:
					if ((align) != 0)
					{
						memory = ((void*) ((long) (((ulong) ((long) ((byte*) (unaligned) + (align - 1)))) & ~(align - 1))));
						*alignment = ((ulong) ((byte*) (memory) - (byte*) (unaligned)));
					}
					else
					{
						memory = unaligned;
						*alignment = (ulong) (0);
					}
					break;
				case NK_BUFFER_BACK:
					if ((align) != 0)
					{
						memory = ((void*) ((long) (((ulong) ((long) ((byte*) (unaligned)))) & ~(align - 1))));
						*alignment = ((ulong) ((byte*) (unaligned) - (byte*) (memory)));
					}
					else
					{
						memory = unaligned;
						*alignment = (ulong) (0);
					}
					break;
			}

			return memory;
		}

		public static void* nk_buffer_realloc(nk_buffer b, ulong capacity, ref ulong size)
		{
			void* temp;
			ulong buffer_size;
			if ((((b == null) || (size == null)))) return null;
			buffer_size = (ulong) (b.memory.size);
			temp = CRuntime.malloc((ulong) (capacity));
			if (temp == null) return null;
			size = (ulong) (capacity);
			if (temp != b.memory.ptr)
			{
				nk_memcopy(temp, b.memory.ptr, (ulong) (buffer_size));
				CRuntime.free(b.memory.ptr);
			}

			if ((b.size) == (buffer_size))
			{
				b.size = (ulong) (capacity);
				return temp;
			}
			else
			{
				void* dst;
				void* src;
				ulong back_size;
				back_size = (ulong) (buffer_size - b.size);
				dst = ((void*) ((byte*) (temp) + (capacity - back_size)));
				src = ((void*) ((byte*) (temp) + (b.size)));
				nk_memcopy(dst, src, (ulong) (back_size));
				b.size = (ulong) (capacity - back_size);
			}

			return temp;
		}

		public static void* nk_buffer_alloc(nk_buffer b, int type, ulong size, ulong align)
		{
			int full;
			ulong alignment;
			void* unaligned;
			void* memory;
			if ((b == null) || (size == 0)) return null;
			b.needed += (ulong) (size);
			if ((type) == (NK_BUFFER_FRONT)) unaligned = ((void*) ((byte*) (b.memory.ptr) + (b.allocated)));
			else unaligned = ((void*) ((byte*) (b.memory.ptr) + (b.size - size)));
			memory = nk_buffer_align(unaligned, (ulong) (align), &alignment, (int) (type));
			if ((type) == (NK_BUFFER_FRONT)) full = (int) ((b.allocated + size + alignment) > (b.size) ? 1 : 0);
			else
				full = (int) ((b.size - ((b.size) < (size + alignment) ? (b.size) : (size + alignment))) <= b.allocated ? 1 : 0);
			if ((full) != 0)
			{
				ulong capacity;
				if (b.type != NK_BUFFER_DYNAMIC) return null;
				if (((b.type != NK_BUFFER_DYNAMIC))) return null;
				capacity = ((ulong) ((float) (b.memory.size)*b.grow_factor));
				capacity =
					(ulong)
						((capacity) < (nk_round_up_pow2((uint) (b.allocated + size)))
							? (nk_round_up_pow2((uint) (b.allocated + size)))
							: (capacity));
				b.memory.ptr = nk_buffer_realloc(b, (ulong) (capacity), ref b.memory.size);
				if (b.memory.ptr == null) return null;
				if ((type) == (NK_BUFFER_FRONT)) unaligned = ((void*) ((byte*) (b.memory.ptr) + (b.allocated)));
				else unaligned = ((void*) ((byte*) (b.memory.ptr) + (b.size - size)));
				memory = nk_buffer_align(unaligned, (ulong) (align), &alignment, (int) (type));
			}

			if ((type) == (NK_BUFFER_FRONT)) b.allocated += (ulong) (size + alignment);
			else b.size -= (ulong) (size + alignment);
			b.needed += (ulong) (alignment);
			b.calls++;
			return memory;
		}

		public static void nk_buffer_push(nk_buffer b, int type, void* memory, ulong size, ulong align)
		{
			void* mem = nk_buffer_alloc(b, (int) (type), (ulong) (size), (ulong) (align));
			if (mem == null) return;
			nk_memcopy(mem, memory, (ulong) (size));
		}

		public static void nk_buffer_mark(nk_buffer buffer, int type)
		{
			if (buffer == null) return;
			buffer.marker[type].active = (int) (nk_true);
			if ((type) == (NK_BUFFER_BACK)) buffer.marker[type].offset = (ulong) (buffer.size);
			else buffer.marker[type].offset = (ulong) (buffer.allocated);
		}

		public static void nk_buffer_reset(nk_buffer buffer, int type)
		{
			if (buffer == null) return;
			if ((type) == (NK_BUFFER_BACK))
			{
				buffer.needed -= (ulong) (buffer.memory.size - buffer.marker[type].offset);
				if ((buffer.marker[type].active) != 0) buffer.size = (ulong) (buffer.marker[type].offset);
				else buffer.size = (ulong) (buffer.memory.size);
				buffer.marker[type].active = (int) (nk_false);
			}
			else
			{
				buffer.needed -= (ulong) (buffer.allocated - buffer.marker[type].offset);
				if ((buffer.marker[type].active) != 0) buffer.allocated = (ulong) (buffer.marker[type].offset);
				else buffer.allocated = (ulong) (0);
				buffer.marker[type].active = (int) (nk_false);
			}

		}

		public static void nk_buffer_clear(nk_buffer b)
		{
			if (b == null) return;
			b.allocated = (ulong) (0);
			b.size = (ulong) (b.memory.size);
			b.calls = (ulong) (0);
			b.needed = (ulong) (0);
		}

		public static void nk_buffer_free(nk_buffer b)
		{
			if ((b == null) || (b.memory.ptr == null)) return;
			if ((b.type) == (NK_BUFFER_FIXED)) return;

			CRuntime.free(b.memory.ptr);
		}

		public static void nk_buffer_info(nk_memory_status s, nk_buffer b)
		{
			if ((s == null) || (b == null)) return;
			s.allocated = (ulong) (b.allocated);
			s.size = (ulong) (b.memory.size);
			s.needed = (ulong) (b.needed);
			s.memory = b.memory.ptr;
			s.calls = (ulong) (b.calls);
		}

		public static void* nk_buffer_memory(nk_buffer buffer)
		{
			if (buffer == null) return null;
			return buffer.memory.ptr;
		}

		public static void* nk_buffer_memory_const(nk_buffer buffer)
		{
			if (buffer == null) return null;
			return buffer.memory.ptr;
		}

		public static ulong nk_buffer_total(nk_buffer buffer)
		{
			if (buffer == null) return (ulong) (0);
			return (ulong) (buffer.memory.size);
		}

		public static void nk_str_init_fixed(nk_str str, void* memory, ulong size)
		{
			nk_buffer_init_fixed(str.buffer, memory, (ulong) (size));
			str.len = (int) (0);
		}

		public static int nk_str_append_text_char(nk_str s, char* str, int len)
		{
			sbyte* mem;
			if (((s == null) || (str == null)) || (len == 0)) return (int) (0);
			mem =
				(sbyte*) (nk_buffer_alloc(s.buffer, (int) (NK_BUFFER_FRONT), (ulong) ((ulong) (len)*sizeof (char)), (ulong) (0)));
			if (mem == null) return (int) (0);
			nk_memcopy(mem, str, (ulong) ((ulong) (len)*sizeof (char)));
			s.len += (int) (nk_utf_len(str, (int) (len)));
			return (int) (len);
		}

		public static int nk_str_append_str_char(nk_str s, char* str)
		{
			return (int) (nk_str_append_text_char(s, str, (int) (nk_strlen(str))));
		}

		public static int nk_str_append_text_utf8(nk_str str, char* text, int len)
		{
			int i = (int) (0);
			int byte_len = (int) (0);
			char unicode;
			if (((str == null) || (text == null)) || (len == 0)) return (int) (0);
			for (i = (int) (0); (i) < (len); ++i)
			{
				byte_len += (int) (nk_utf_decode(text + byte_len, &unicode, (int) (4)));
			}
			nk_str_append_text_char(str, text, (int) (byte_len));
			return (int) (len);
		}

		public static int nk_str_append_str_utf8(nk_str str, char* text)
		{
			int runes = (int) (0);
			int byte_len = (int) (0);
			int num_runes = (int) (0);
			int glyph_len = (int) (0);
			char unicode;
			if ((str == null) || (text == null)) return (int) (0);
			glyph_len = (int) (byte_len = (int) (nk_utf_decode(text + byte_len, &unicode, (int) (4))));
			while ((unicode != '\0') && ((glyph_len) != 0))
			{
				glyph_len = (int) (nk_utf_decode(text + byte_len, &unicode, (int) (4)));
				byte_len += (int) (glyph_len);
				num_runes++;
			}
			nk_str_append_text_char(str, text, (int) (byte_len));
			return (int) (runes);
		}

		public static int nk_str_insert_at_char(nk_str s, int pos, char* str, int len)
		{
			int i;
			void* mem;
			sbyte* src;
			sbyte* dst;
			int copylen;
			if ((((s == null) || (str == null)) || (len == 0)) || (((ulong) (pos)) > (s.buffer.allocated))) return (int) (0);
			if (((s.buffer.allocated + (ulong) (len)) >= (s.buffer.memory.size)) && ((s.buffer.type) == (NK_BUFFER_FIXED)))
				return (int) (0);
			copylen = (int) ((int) (s.buffer.allocated) - pos);
			if (copylen == 0)
			{
				nk_str_append_text_char(s, str, (int) (len));
				return (int) (1);
			}

			mem = nk_buffer_alloc(s.buffer, (int) (NK_BUFFER_FRONT), (ulong) ((ulong) (len)*sizeof (char)), (ulong) (0));
			if (mem == null) return (int) (0);
			dst = ((sbyte*) ((void*) ((byte*) (s.buffer.memory.ptr) + (pos + len + (copylen - 1)))));
			src = ((sbyte*) ((void*) ((byte*) (s.buffer.memory.ptr) + (pos + (copylen - 1)))));
			for (i = (int) (0); (i) < (copylen); ++i)
			{
				*dst-- = (sbyte) (*src--);
			}
			mem = ((void*) ((byte*) (s.buffer.memory.ptr) + (pos)));
			nk_memcopy(mem, str, (ulong) ((ulong) (len)*sizeof (char)));
			s.len = (int) (nk_utf_len((char*) (s.buffer.memory.ptr), (int) (s.buffer.allocated)));
			return (int) (1);
		}

		public static int nk_str_insert_at_rune(nk_str str, int pos, char* cstr, int len)
		{
			int glyph_len = 0;
			char unicode;
			char* begin;
			char* buffer;
			if (((str == null) || (cstr == null)) || (len == 0)) return (int) (0);
			begin = nk_str_at_rune(str, (int) (pos), &unicode, ref glyph_len);
			if (str.len == 0) return (int) (nk_str_append_text_char(str, cstr, (int) (len)));
			buffer = nk_str_get_const(str);
			if (begin == null) return (int) (0);
			return (int) (nk_str_insert_at_char(str, (int) (begin - buffer), cstr, (int) (len)));
		}

		public static int nk_str_insert_text_char(nk_str str, int pos, char* text, int len)
		{
			return (int) (nk_str_insert_text_utf8(str, (int) (pos), text, (int) (len)));
		}

		public static int nk_str_insert_str_char(nk_str str, int pos, char* text)
		{
			return (int) (nk_str_insert_text_utf8(str, (int) (pos), text, (int) (nk_strlen(text))));
		}

		public static int nk_str_insert_text_utf8(nk_str str, int pos, char* text, int len)
		{
			int i = (int) (0);
			int byte_len = (int) (0);
			char unicode;
			if (((str == null) || (text == null)) || (len == 0)) return (int) (0);
			for (i = (int) (0); (i) < (len); ++i)
			{
				byte_len += (int) (nk_utf_decode(text + byte_len, &unicode, (int) (4)));
			}
			nk_str_insert_at_rune(str, (int) (pos), text, (int) (byte_len));
			return (int) (len);
		}

		public static int nk_str_insert_str_utf8(nk_str str, int pos, char* text)
		{
			int runes = (int) (0);
			int byte_len = (int) (0);
			int num_runes = (int) (0);
			int glyph_len = (int) (0);
			char unicode;
			if ((str == null) || (text == null)) return (int) (0);
			glyph_len = (int) (byte_len = (int) (nk_utf_decode(text + byte_len, &unicode, (int) (4))));
			while ((unicode != '\0') && ((glyph_len) != 0))
			{
				glyph_len = (int) (nk_utf_decode(text + byte_len, &unicode, (int) (4)));
				byte_len += (int) (glyph_len);
				num_runes++;
			}
			nk_str_insert_at_rune(str, (int) (pos), text, (int) (byte_len));
			return (int) (runes);
		}

		public static int nk_str_insert_text_runes(nk_str str, int pos, char* runes, int len)
		{
			int i = (int) (0);
			int byte_len = (int) (0);
			char* glyph = stackalloc char[4];
			if (((str == null) || (runes == null)) || (len == 0)) return (int) (0);
			for (i = (int) (0); (i) < (len); ++i)
			{
				byte_len = (int) (nk_utf_encode(runes[i], glyph, (int) (4)));
				if (byte_len == 0) break;
				nk_str_insert_at_rune(str, (int) (pos + i), glyph, (int) (byte_len));
			}
			return (int) (len);
		}

		public static int nk_str_insert_str_runes(nk_str str, int pos, char* runes)
		{
			int i = (int) (0);
			char* glyph = stackalloc char[4];
			int byte_len;
			if ((str == null) || (runes == null)) return (int) (0);
			while (runes[i] != '\0')
			{
				byte_len = (int) (nk_utf_encode(runes[i], glyph, (int) (4)));
				nk_str_insert_at_rune(str, (int) (pos + i), glyph, (int) (byte_len));
				i++;
			}
			return (int) (i);
		}

		public static void nk_str_remove_chars(nk_str s, int len)
		{
			if (((s == null) || ((len) < (0))) || (((ulong) (len)) > (s.buffer.allocated))) return;
			s.buffer.allocated -= ((ulong) (len));
			s.len = (int) (nk_utf_len((char*) (s.buffer.memory.ptr), (int) (s.buffer.allocated)));
		}

		public static void nk_str_remove_runes(nk_str str, int len)
		{
			int index;
			char* begin;
			char* end;
			char unicode;
			if ((str == null) || ((len) < (0))) return;
			if ((len) >= (str.len))
			{
				str.len = (int) (0);
				return;
			}

			index = (int) (str.len - len);
			begin = nk_str_at_rune(str, (int) (index), &unicode, ref len);
			end = (char*) (str.buffer.memory.ptr) + str.buffer.allocated;
			nk_str_remove_chars(str, (int) ((int) (end - begin) + 1));
		}

		public static void nk_str_delete_chars(nk_str s, int pos, int len)
		{
			if ((((s == null) || (len == 0)) || (((ulong) (pos)) > (s.buffer.allocated))) ||
			    (((ulong) (pos + len)) > (s.buffer.allocated))) return;
			if (((ulong) (pos + len)) < (s.buffer.allocated))
			{
				sbyte* dst = ((sbyte*) ((void*) ((byte*) (s.buffer.memory.ptr) + (pos))));
				sbyte* src = ((sbyte*) ((void*) ((byte*) (s.buffer.memory.ptr) + (pos + len))));
				nk_memcopy(dst, src, (ulong) (s.buffer.allocated - (ulong) (pos + len)));
				s.buffer.allocated -= ((ulong) (len));
			}
			else nk_str_remove_chars(s, (int) (len));
			s.len = (int) (nk_utf_len((char*) (s.buffer.memory.ptr), (int) (s.buffer.allocated)));
		}

		public static void nk_str_delete_runes(nk_str s, int pos, int len)
		{
			char* temp;
			char unicode;
			char* begin;
			char* end;
			int unused = 0;
			if ((s.len) < (pos + len))
				len =
					(int)
						(((s.len - pos) < (s.len) ? (s.len - pos) : (s.len)) < (0)
							? (0)
							: ((s.len - pos) < (s.len) ? (s.len - pos) : (s.len)));
			if (len == 0) return;
			temp = (char*) (s.buffer.memory.ptr);
			begin = nk_str_at_rune(s, (int) (pos), &unicode, ref unused);
			if (begin == null) return;
			s.buffer.memory.ptr = begin;
			end = nk_str_at_rune(s, (int) (len), &unicode, ref unused);
			s.buffer.memory.ptr = temp;
			if (end == null) return;
			nk_str_delete_chars(s, (int) (begin - temp), (int) (end - begin));
		}

		public static char* nk_str_at_char(nk_str s, int pos)
		{
			if ((s == null) || ((pos) > ((int) (s.buffer.allocated)))) return null;
			return ((char*) ((void*) ((byte*) (s.buffer.memory.ptr) + (pos))));
		}

		public static char* nk_str_at_rune(nk_str str, int pos, char* unicode, ref int len)
		{
			int i = (int) (0);
			int src_len = (int) (0);
			int glyph_len = (int) (0);
			char* text;
			int text_len;
			if (((str == null) || (unicode == null)) || (len == null)) return null;
			if ((pos) < (0))
			{
				*unicode = (char) (0);
				len = (int) (0);
				return null;
			}

			text = (char*) (str.buffer.memory.ptr);
			text_len = ((int) (str.buffer.allocated));
			glyph_len = (int) (nk_utf_decode(text, unicode, (int) (text_len)));
			while ((glyph_len) != 0)
			{
				if ((i) == (pos))
				{
					len = (int) (glyph_len);
					break;
				}
				i++;
				src_len = (int) (src_len + glyph_len);
				glyph_len = (int) (nk_utf_decode(text + src_len, unicode, (int) (text_len - src_len)));
			}
			if (i != pos) return null;
			return text + src_len;
		}

		public static char* nk_str_at_char_const(nk_str s, int pos)
		{
			if ((s == null) || ((pos) > ((int) (s.buffer.allocated)))) return null;
			return ((char*) ((void*) ((byte*) (s.buffer.memory.ptr) + (pos))));
		}

		public static char* nk_str_at_const(nk_str str, int pos, char* unicode, ref int len)
		{
			int i = (int) (0);
			int src_len = (int) (0);
			int glyph_len = (int) (0);
			char* text;
			int text_len;
			if (((str == null) || (unicode == null)) || (len == null)) return null;
			if ((pos) < (0))
			{
				*unicode = (char) (0);
				len = (int) (0);
				return null;
			}

			text = (char*) (str.buffer.memory.ptr);
			text_len = ((int) (str.buffer.allocated));
			glyph_len = (int) (nk_utf_decode(text, unicode, (int) (text_len)));
			while ((glyph_len) != 0)
			{
				if ((i) == (pos))
				{
					len = (int) (glyph_len);
					break;
				}
				i++;
				src_len = (int) (src_len + glyph_len);
				glyph_len = (int) (nk_utf_decode(text + src_len, unicode, (int) (text_len - src_len)));
			}
			if (i != pos) return null;
			return text + src_len;
		}

		public static char nk_str_rune_at(nk_str str, int pos)
		{
			int len = 0;
			char unicode = (char) 0;
			nk_str_at_const(str, (int) (pos), &unicode, ref len);
			return unicode;
		}

		public static char* nk_str_get(nk_str s)
		{
			if (((s == null) || (s.len == 0)) || (s.buffer.allocated == 0)) return null;
			return (char*) (s.buffer.memory.ptr);
		}

		public static char* nk_str_get_const(nk_str s)
		{
			if (((s == null) || (s.len == 0)) || (s.buffer.allocated == 0)) return null;
			return (char*) (s.buffer.memory.ptr);
		}

		public static int nk_str_len(nk_str s)
		{
			if (((s == null) || (s.len == 0)) || (s.buffer.allocated == 0)) return (int) (0);
			return (int) (s.len);
		}

		public static int nk_str_len_char(nk_str s)
		{
			if (((s == null) || (s.len == 0)) || (s.buffer.allocated == 0)) return (int) (0);
			return (int) (s.buffer.allocated);
		}

		public static void nk_str_clear(nk_str str)
		{
			nk_buffer_clear(str.buffer);
			str.len = (int) (0);
		}

		public static void nk_str_free(nk_str str)
		{
			nk_buffer_free(str.buffer);
			str.len = (int) (0);
		}

		public static void nk_push_scissor(nk_command_buffer b, nk_rect r)
		{
			nk_command_scissor cmd;
			if (b == null) return;
			b.clip.x = (float) (r.x);
			b.clip.y = (float) (r.y);
			b.clip.w = (float) (r.w);
			b.clip.h = (float) (r.h);
			cmd = (nk_command_scissor) (nk_command_buffer_push(b, (int) (NK_COMMAND_SCISSOR)));
			if (cmd == null) return;
			cmd.x = ((short) (r.x));
			cmd.y = ((short) (r.y));
			cmd.w = ((ushort) ((0) < (r.w) ? (r.w) : (0)));
			cmd.h = ((ushort) ((0) < (r.h) ? (r.h) : (0)));
		}

		public static void nk_stroke_line(nk_command_buffer b, float x0, float y0, float x1, float y1, float line_thickness,
			nk_color c)
		{
			nk_command_line cmd;
			if ((b == null) || (line_thickness <= 0)) return;
			cmd = (nk_command_line) (nk_command_buffer_push(b, (int) (NK_COMMAND_LINE)));
			if (cmd == null) return;
			cmd.line_thickness = ((ushort) (line_thickness));
			cmd.begin.x = ((short) (x0));
			cmd.begin.y = ((short) (y0));
			cmd.end.x = ((short) (x1));
			cmd.end.y = ((short) (y1));
			cmd.color = (nk_color) (c);
		}

		public static void nk_stroke_curve(nk_command_buffer b, float ax, float ay, float ctrl0x, float ctrl0y, float ctrl1x,
			float ctrl1y, float bx, float by, float line_thickness, nk_color col)
		{
			nk_command_curve cmd;
			if (((b == null) || ((col.a) == (0))) || (line_thickness <= 0)) return;
			cmd = (nk_command_curve) (nk_command_buffer_push(b, (int) (NK_COMMAND_CURVE)));
			if (cmd == null) return;
			cmd.line_thickness = ((ushort) (line_thickness));
			cmd.begin.x = ((short) (ax));
			cmd.begin.y = ((short) (ay));
			cmd.ctrl_0.x = ((short) (ctrl0x));
			cmd.ctrl_0.y = ((short) (ctrl0y));
			cmd.ctrl_1.x = ((short) (ctrl1x));
			cmd.ctrl_1.y = ((short) (ctrl1y));
			cmd.end.x = ((short) (bx));
			cmd.end.y = ((short) (by));
			cmd.color = (nk_color) (col);
		}

		public static void nk_stroke_rect(nk_command_buffer b, nk_rect rect, float rounding, float line_thickness, nk_color c)
		{
			nk_command_rect cmd;
			if (((((b == null) || ((c.a) == (0))) || ((rect.w) == (0))) || ((rect.h) == (0))) || (line_thickness <= 0)) return;
			if ((b.use_clipping) != 0)
			{
				if (
					!(!(((((b.clip.x) > (rect.x + rect.w)) || ((b.clip.x + b.clip.w) < (rect.x))) || ((b.clip.y) > (rect.y + rect.h))) ||
					    ((b.clip.y + b.clip.h) < (rect.y))))) return;
			}

			cmd = (nk_command_rect) (nk_command_buffer_push(b, (int) (NK_COMMAND_RECT)));
			if (cmd == null) return;
			cmd.rounding = ((ushort) (rounding));
			cmd.line_thickness = ((ushort) (line_thickness));
			cmd.x = ((short) (rect.x));
			cmd.y = ((short) (rect.y));
			cmd.w = ((ushort) ((0) < (rect.w) ? (rect.w) : (0)));
			cmd.h = ((ushort) ((0) < (rect.h) ? (rect.h) : (0)));
			cmd.color = (nk_color) (c);
		}

		public static void nk_fill_rect(nk_command_buffer b, nk_rect rect, float rounding, nk_color c)
		{
			nk_command_rect_filled cmd;
			if ((((b == null) || ((c.a) == (0))) || ((rect.w) == (0))) || ((rect.h) == (0))) return;
			if ((b.use_clipping) != 0)
			{
				if (
					!(!(((((b.clip.x) > (rect.x + rect.w)) || ((b.clip.x + b.clip.w) < (rect.x))) || ((b.clip.y) > (rect.y + rect.h))) ||
					    ((b.clip.y + b.clip.h) < (rect.y))))) return;
			}

			cmd = (nk_command_rect_filled) (nk_command_buffer_push(b, (int) (NK_COMMAND_RECT_FILLED)));
			if (cmd == null) return;
			cmd.rounding = ((ushort) (rounding));
			cmd.x = ((short) (rect.x));
			cmd.y = ((short) (rect.y));
			cmd.w = ((ushort) ((0) < (rect.w) ? (rect.w) : (0)));
			cmd.h = ((ushort) ((0) < (rect.h) ? (rect.h) : (0)));
			cmd.color = (nk_color) (c);
		}

		public static void nk_fill_rect_multi_color(nk_command_buffer b, nk_rect rect, nk_color left, nk_color top,
			nk_color right, nk_color bottom)
		{
			nk_command_rect_multi_color cmd;
			if (((b == null) || ((rect.w) == (0))) || ((rect.h) == (0))) return;
			if ((b.use_clipping) != 0)
			{
				if (
					!(!(((((b.clip.x) > (rect.x + rect.w)) || ((b.clip.x + b.clip.w) < (rect.x))) || ((b.clip.y) > (rect.y + rect.h))) ||
					    ((b.clip.y + b.clip.h) < (rect.y))))) return;
			}

			cmd = (nk_command_rect_multi_color) (nk_command_buffer_push(b, (int) (NK_COMMAND_RECT_MULTI_COLOR)));
			if (cmd == null) return;
			cmd.x = ((short) (rect.x));
			cmd.y = ((short) (rect.y));
			cmd.w = ((ushort) ((0) < (rect.w) ? (rect.w) : (0)));
			cmd.h = ((ushort) ((0) < (rect.h) ? (rect.h) : (0)));
			cmd.left = (nk_color) (left);
			cmd.top = (nk_color) (top);
			cmd.right = (nk_color) (right);
			cmd.bottom = (nk_color) (bottom);
		}

		public static void nk_stroke_circle(nk_command_buffer b, nk_rect r, float line_thickness, nk_color c)
		{
			nk_command_circle cmd;
			if ((((b == null) || ((r.w) == (0))) || ((r.h) == (0))) || (line_thickness <= 0)) return;
			if ((b.use_clipping) != 0)
			{
				if (
					!(!(((((b.clip.x) > (r.x + r.w)) || ((b.clip.x + b.clip.w) < (r.x))) || ((b.clip.y) > (r.y + r.h))) ||
					    ((b.clip.y + b.clip.h) < (r.y))))) return;
			}

			cmd = (nk_command_circle) (nk_command_buffer_push(b, (int) (NK_COMMAND_CIRCLE)));
			if (cmd == null) return;
			cmd.line_thickness = ((ushort) (line_thickness));
			cmd.x = ((short) (r.x));
			cmd.y = ((short) (r.y));
			cmd.w = ((ushort) ((r.w) < (0) ? (0) : (r.w)));
			cmd.h = ((ushort) ((r.h) < (0) ? (0) : (r.h)));
			cmd.color = (nk_color) (c);
		}

		public static void nk_fill_circle(nk_command_buffer b, nk_rect r, nk_color c)
		{
			nk_command_circle_filled cmd;
			if ((((b == null) || ((c.a) == (0))) || ((r.w) == (0))) || ((r.h) == (0))) return;
			if ((b.use_clipping) != 0)
			{
				if (
					!(!(((((b.clip.x) > (r.x + r.w)) || ((b.clip.x + b.clip.w) < (r.x))) || ((b.clip.y) > (r.y + r.h))) ||
					    ((b.clip.y + b.clip.h) < (r.y))))) return;
			}

			cmd = (nk_command_circle_filled) (nk_command_buffer_push(b, (int) (NK_COMMAND_CIRCLE_FILLED)));
			if (cmd == null) return;
			cmd.x = ((short) (r.x));
			cmd.y = ((short) (r.y));
			cmd.w = ((ushort) ((r.w) < (0) ? (0) : (r.w)));
			cmd.h = ((ushort) ((r.h) < (0) ? (0) : (r.h)));
			cmd.color = (nk_color) (c);
		}

		public static void nk_stroke_arc(nk_command_buffer b, float cx, float cy, float radius, float a_min, float a_max,
			float line_thickness, nk_color c)
		{
			nk_command_arc cmd;
			if (((b == null) || ((c.a) == (0))) || (line_thickness <= 0)) return;
			cmd = (nk_command_arc) (nk_command_buffer_push(b, (int) (NK_COMMAND_ARC)));
			if (cmd == null) return;
			cmd.line_thickness = ((ushort) (line_thickness));
			cmd.cx = ((short) (cx));
			cmd.cy = ((short) (cy));
			cmd.r = ((ushort) (radius));
			cmd.a[0] = (float) (a_min);
			cmd.a[1] = (float) (a_max);
			cmd.color = (nk_color) (c);
		}

		public static void nk_fill_arc(nk_command_buffer b, float cx, float cy, float radius, float a_min, float a_max,
			nk_color c)
		{
			nk_command_arc_filled cmd;
			if ((b == null) || ((c.a) == (0))) return;
			cmd = (nk_command_arc_filled) (nk_command_buffer_push(b, (int) (NK_COMMAND_ARC_FILLED)));
			if (cmd == null) return;
			cmd.cx = ((short) (cx));
			cmd.cy = ((short) (cy));
			cmd.r = ((ushort) (radius));
			cmd.a[0] = (float) (a_min);
			cmd.a[1] = (float) (a_max);
			cmd.color = (nk_color) (c);
		}

		public static void nk_stroke_triangle(nk_command_buffer b, float x0, float y0, float x1, float y1, float x2, float y2,
			float line_thickness, nk_color c)
		{
			nk_command_triangle cmd;
			if (((b == null) || ((c.a) == (0))) || (line_thickness <= 0)) return;
			if ((b.use_clipping) != 0)
			{
				if (
					((!((((b.clip.x) <= (x0)) && ((x0) < (b.clip.x + b.clip.w))) &&
					    (((b.clip.y) <= (y0)) && ((y0) < (b.clip.y + b.clip.h))))) &&
					 (!((((b.clip.x) <= (x1)) && ((x1) < (b.clip.x + b.clip.w))) &&
					    (((b.clip.y) <= (y1)) && ((y1) < (b.clip.y + b.clip.h)))))) &&
					(!((((b.clip.x) <= (x2)) && ((x2) < (b.clip.x + b.clip.w))) &&
					   (((b.clip.y) <= (y2)) && ((y2) < (b.clip.y + b.clip.h)))))) return;
			}

			cmd = (nk_command_triangle) (nk_command_buffer_push(b, (int) (NK_COMMAND_TRIANGLE)));
			if (cmd == null) return;
			cmd.line_thickness = ((ushort) (line_thickness));
			cmd.a.x = ((short) (x0));
			cmd.a.y = ((short) (y0));
			cmd.b.x = ((short) (x1));
			cmd.b.y = ((short) (y1));
			cmd.c.x = ((short) (x2));
			cmd.c.y = ((short) (y2));
			cmd.color = (nk_color) (c);
		}

		public static void nk_fill_triangle(nk_command_buffer b, float x0, float y0, float x1, float y1, float x2, float y2,
			nk_color c)
		{
			nk_command_triangle_filled cmd;
			if ((b == null) || ((c.a) == (0))) return;
			if (b == null) return;
			if ((b.use_clipping) != 0)
			{
				if (
					((!((((b.clip.x) <= (x0)) && ((x0) < (b.clip.x + b.clip.w))) &&
					    (((b.clip.y) <= (y0)) && ((y0) < (b.clip.y + b.clip.h))))) &&
					 (!((((b.clip.x) <= (x1)) && ((x1) < (b.clip.x + b.clip.w))) &&
					    (((b.clip.y) <= (y1)) && ((y1) < (b.clip.y + b.clip.h)))))) &&
					(!((((b.clip.x) <= (x2)) && ((x2) < (b.clip.x + b.clip.w))) &&
					   (((b.clip.y) <= (y2)) && ((y2) < (b.clip.y + b.clip.h)))))) return;
			}

			cmd = (nk_command_triangle_filled) (nk_command_buffer_push(b, (int) (NK_COMMAND_TRIANGLE_FILLED)));
			if (cmd == null) return;
			cmd.a.x = ((short) (x0));
			cmd.a.y = ((short) (y0));
			cmd.b.x = ((short) (x1));
			cmd.b.y = ((short) (y1));
			cmd.c.x = ((short) (x2));
			cmd.c.y = ((short) (y2));
			cmd.color = (nk_color) (c);
		}

		public static void nk_draw_image(nk_command_buffer b, nk_rect r, nk_image img, nk_color col)
		{
			nk_command_image cmd;
			if (b == null) return;
			if ((b.use_clipping) != 0)
			{
				if ((((b.clip.w) == (0)) || ((b.clip.h) == (0))) ||
				    (!(!(((((b.clip.x) > (r.x + r.w)) || ((b.clip.x + b.clip.w) < (r.x))) || ((b.clip.y) > (r.y + r.h))) ||
				         ((b.clip.y + b.clip.h) < (r.y)))))) return;
			}

			cmd = (nk_command_image) (nk_command_buffer_push(b, (int) (NK_COMMAND_IMAGE)));
			if (cmd == null) return;
			cmd.x = ((short) (r.x));
			cmd.y = ((short) (r.y));
			cmd.w = ((ushort) ((0) < (r.w) ? (r.w) : (0)));
			cmd.h = ((ushort) ((0) < (r.h) ? (r.h) : (0)));
			cmd.img = (nk_image) (img);
			cmd.col = (nk_color) (col);
		}

		public static void nk_push_custom(nk_command_buffer b, nk_rect r, NkCommandCustomCallback cb, nk_handle usr)
		{
			nk_command_custom cmd;
			if (b == null) return;
			if ((b.use_clipping) != 0)
			{
				if ((((b.clip.w) == (0)) || ((b.clip.h) == (0))) ||
				    (!(!(((((b.clip.x) > (r.x + r.w)) || ((b.clip.x + b.clip.w) < (r.x))) || ((b.clip.y) > (r.y + r.h))) ||
				         ((b.clip.y + b.clip.h) < (r.y)))))) return;
			}

			cmd = (nk_command_custom) (nk_command_buffer_push(b, (int) (NK_COMMAND_CUSTOM)));
			if (cmd == null) return;
			cmd.x = ((short) (r.x));
			cmd.y = ((short) (r.y));
			cmd.w = ((ushort) ((0) < (r.w) ? (r.w) : (0)));
			cmd.h = ((ushort) ((0) < (r.h) ? (r.h) : (0)));
			cmd.callback_data = (nk_handle) (usr);
			cmd.callback = cb;
		}

		public static void nk_draw_text(nk_command_buffer b, nk_rect r, char* _string_, int length, nk_user_font font,
			nk_color bg, nk_color fg)
		{
			float text_width = (float) (0);
			nk_command_text cmd;
			if ((((b == null) || (_string_ == null)) || (length == 0)) || (((bg.a) == (0)) && ((fg.a) == (0)))) return;
			if ((b.use_clipping) != 0)
			{
				if ((((b.clip.w) == (0)) || ((b.clip.h) == (0))) ||
				    (!(!(((((b.clip.x) > (r.x + r.w)) || ((b.clip.x + b.clip.w) < (r.x))) || ((b.clip.y) > (r.y + r.h))) ||
				         ((b.clip.y + b.clip.h) < (r.y)))))) return;
			}

			text_width = (float) (font.width((nk_handle) (font.userdata), (float) (font.height), _string_, (int) (length)));
			if ((text_width) > (r.w))
			{
				int glyphs = (int) (0);
				float txt_width = (float) (text_width);
				length = (int) (nk_text_clamp(font, _string_, (int) (length), (float) (r.w), &glyphs, &txt_width, null, (int) (0)));
			}

			if (length == 0) return;
			cmd = (nk_command_text) (nk_command_buffer_push(b, (int) (NK_COMMAND_TEXT)));
			if (cmd == null) return;
			cmd.x = ((short) (r.x));
			cmd.y = ((short) (r.y));
			cmd.w = ((ushort) (r.w));
			cmd.h = ((ushort) (r.h));
			cmd.background = (nk_color) (bg);
			cmd.foreground = (nk_color) (fg);
			cmd.font = font;
			cmd.length = (int) (length);
			cmd.height = (float) (font.height);
			cmd._string_ = new PinnedArray<char>(length);
			CRuntime.memcpy((void*) cmd._string_, _string_, length*sizeof (char));
			cmd._string_[length] = ('\0');
		}

		public static void nk_draw_list_init(nk_draw_list list)
		{
			ulong i = (ulong) (0);
			if (list == null) return;

			for (i = (ulong) (0); (i) < (ulong) list.circle_vtx.Length; ++i)
			{
				float a = (float) (((float) (i)/(float) (ulong) list.circle_vtx.Length)*2*3.141592654f);
				list.circle_vtx[i].x = (float) (nk_cos((float) (a)));
				list.circle_vtx[i].y = (float) (nk_sin((float) (a)));
			}
		}

		public static void nk_draw_list_setup(nk_draw_list canvas, nk_convert_config config, nk_buffer cmds,
			nk_buffer vertices, nk_buffer elements, int line_aa, int shape_aa)
		{
			if (((((canvas == null) || (config == null)) || (cmds == null)) || (vertices == null)) || (elements == null)) return;
			canvas.buffer = cmds;
			canvas.config = (nk_convert_config) (config);
			canvas.elements = elements;
			canvas.vertices = vertices;
			canvas.line_AA = (int) (line_aa);
			canvas.shape_AA = (int) (shape_aa);
			canvas.clip_rect = (nk_rect) (nk_null_rect);
		}

		public static nk_draw_command* nk__draw_list_begin(nk_draw_list canvas, nk_buffer buffer)
		{
			byte* memory;
			ulong offset;
			nk_draw_command* cmd;
			if (((buffer == null) || (buffer.size == 0)) || (canvas.cmd_count == 0)) return null;
			memory = (byte*) (buffer.memory.ptr);
			offset = (ulong) (buffer.memory.size - canvas.cmd_offset);
			cmd = ((nk_draw_command*) ((void*) ((memory) + (offset))));
			return cmd;
		}

		public static nk_draw_command* nk__draw_list_end(nk_draw_list canvas, nk_buffer buffer)
		{
			ulong size;
			ulong offset;
			byte* memory;
			nk_draw_command* end;
			if ((buffer == null) || (canvas == null)) return null;
			memory = (byte*) (buffer.memory.ptr);
			size = (ulong) (buffer.memory.size);
			offset = (ulong) (size - canvas.cmd_offset);
			end = ((nk_draw_command*) ((void*) ((memory) + (offset))));
			end -= (canvas.cmd_count - 1);
			return end;
		}

		public static nk_draw_command* nk__draw_list_next(nk_draw_command* cmd, nk_buffer buffer, nk_draw_list canvas)
		{
			nk_draw_command* end;
			if (((cmd == null) || (buffer == null)) || (canvas == null)) return null;
			end = nk__draw_list_end(canvas, buffer);
			if (cmd <= end) return null;
			return (cmd - 1);
		}

		public static void nk_draw_list_clear(nk_draw_list list)
		{
			if (list == null) return;
			if ((list.buffer) != null) nk_buffer_clear(list.buffer);
			if ((list.vertices) != null) nk_buffer_clear(list.vertices);
			if ((list.elements) != null) nk_buffer_clear(list.elements);
			list.element_count = (uint) (0);
			list.vertex_count = (uint) (0);
			list.cmd_offset = (ulong) (0);
			list.cmd_count = (uint) (0);
			list.path_count = (uint) (0);
			list.vertices = null;
			list.elements = null;
			list.clip_rect = (nk_rect) (nk_null_rect);
		}

		public static nk_vec2* nk_draw_list_alloc_path(nk_draw_list list, int count)
		{
			nk_vec2* points;
			ulong point_align = (ulong) (4);
			ulong point_size = (ulong) (sizeof (nk_vec2));
			points =
				(nk_vec2*)
					(nk_buffer_alloc(list.buffer, (int) (NK_BUFFER_FRONT), (ulong) (point_size*(ulong) (count)), (ulong) (point_align)));
			if (points == null) return null;
			if (list.path_offset == 0)
			{
				void* memory = nk_buffer_memory(list.buffer);
				list.path_offset = ((uint) ((byte*) (points) - (byte*) (memory)));
			}

			list.path_count += ((uint) (count));
			return points;
		}

		public static nk_vec2 nk_draw_list_path_last(nk_draw_list list)
		{
			void* memory;
			nk_vec2* point;
			memory = nk_buffer_memory(list.buffer);
			point = ((nk_vec2*) ((void*) ((byte*) (memory) + (list.path_offset))));
			point += (list.path_count - 1);
			return (nk_vec2) (*point);
		}

		public static nk_draw_command* nk_draw_list_push_command(nk_draw_list list, nk_rect clip, nk_handle texture)
		{
			ulong cmd_align = (ulong) (4);
			ulong cmd_size = (ulong) (sizeof (nk_draw_command));
			nk_draw_command* cmd;
			cmd =
				(nk_draw_command*) (nk_buffer_alloc(list.buffer, (int) (NK_BUFFER_BACK), (ulong) (cmd_size), (ulong) (cmd_align)));
			if (cmd == null) return null;
			if (list.cmd_count == 0)
			{
				byte* memory = (byte*) (nk_buffer_memory(list.buffer));
				ulong total = (ulong) (nk_buffer_total(list.buffer));
				memory = ((byte*) ((void*) ((memory) + (total))));
				list.cmd_offset = ((ulong) (memory - (byte*) (cmd)));
			}

			cmd->elem_count = (uint) (0);
			cmd->clip_rect = (nk_rect) (clip);
			cmd->texture = (nk_handle) (texture);
			cmd->userdata = (nk_handle) (list.userdata);
			list.cmd_count++;
			list.clip_rect = (nk_rect) (clip);
			return cmd;
		}

		public static nk_draw_command* nk_draw_list_command_last(nk_draw_list list)
		{
			void* memory;
			ulong size;
			nk_draw_command* cmd;
			memory = nk_buffer_memory(list.buffer);
			size = (ulong) (nk_buffer_total(list.buffer));
			cmd = ((nk_draw_command*) ((void*) ((byte*) (memory) + (size - list.cmd_offset))));
			return (cmd - (list.cmd_count - 1));
		}

		public static void nk_draw_list_add_clip(nk_draw_list list, nk_rect rect)
		{
			if (list == null) return;
			if (list.cmd_count == 0)
			{
				nk_draw_list_push_command(list, (nk_rect) (rect), (nk_handle) (list.config._null_.texture));
			}
			else
			{
				nk_draw_command* prev = nk_draw_list_command_last(list);
				if ((prev->elem_count) == (0)) prev->clip_rect = (nk_rect) (rect);
				nk_draw_list_push_command(list, (nk_rect) (rect), (nk_handle) (prev->texture));
			}

		}

		public static void nk_draw_list_push_image(nk_draw_list list, nk_handle texture)
		{
			if (list == null) return;
			if (list.cmd_count == 0)
			{
				nk_draw_list_push_command(list, (nk_rect) (nk_null_rect), (nk_handle) (texture));
			}
			else
			{
				nk_draw_command* prev = nk_draw_list_command_last(list);
				if ((prev->elem_count) == (0))
				{
					prev->texture = (nk_handle) (texture);
					prev->userdata = (nk_handle) (list.userdata);
				}
				else if ((prev->texture.id != texture.id) || (prev->userdata.id != list.userdata.id))
					nk_draw_list_push_command(list, (nk_rect) (prev->clip_rect), (nk_handle) (texture));
			}

		}

		public static void nk_draw_list_push_userdata(nk_draw_list list, nk_handle userdata)
		{
			list.userdata = (nk_handle) (userdata);
		}

		public static void* nk_draw_list_alloc_vertices(nk_draw_list list, ulong count)
		{
			void* vtx;
			if (list == null) return null;
			vtx = nk_buffer_alloc(list.vertices, (int) (NK_BUFFER_FRONT), (ulong) (list.config.vertex_size*count),
				(ulong) (list.config.vertex_alignment));
			if (vtx == null) return null;
			list.vertex_count += ((uint) (count));
			return vtx;
		}

		public static ushort* nk_draw_list_alloc_elements(nk_draw_list list, ulong count)
		{
			ushort* ids;
			nk_draw_command* cmd;
			ulong elem_align = (ulong) (2);
			ulong elem_size = (ulong) (sizeof (ushort));
			if (list == null) return null;
			ids =
				(ushort*) (nk_buffer_alloc(list.elements, (int) (NK_BUFFER_FRONT), (ulong) (elem_size*count), (ulong) (elem_align)));
			if (ids == null) return null;
			cmd = nk_draw_list_command_last(list);
			list.element_count += ((uint) (count));
			cmd->elem_count += ((uint) (count));
			return ids;
		}

		public static void nk_draw_vertex_color(void* attr, float* vals, int format)
		{
			float* val = stackalloc float[4];
			if (((format) < (NK_FORMAT_COLOR_BEGIN)) || ((format) > (NK_FORMAT_COLOR_END))) return;
			val[0] = (float) ((0) < ((1.0f) < (vals[0]) ? (1.0f) : (vals[0])) ? ((1.0f) < (vals[0]) ? (1.0f) : (vals[0])) : (0));
			val[1] = (float) ((0) < ((1.0f) < (vals[1]) ? (1.0f) : (vals[1])) ? ((1.0f) < (vals[1]) ? (1.0f) : (vals[1])) : (0));
			val[2] = (float) ((0) < ((1.0f) < (vals[2]) ? (1.0f) : (vals[2])) ? ((1.0f) < (vals[2]) ? (1.0f) : (vals[2])) : (0));
			val[3] = (float) ((0) < ((1.0f) < (vals[3]) ? (1.0f) : (vals[3])) ? ((1.0f) < (vals[3]) ? (1.0f) : (vals[3])) : (0));
			switch (format)
			{
				default:
					;
					break;
				case NK_FORMAT_R8G8B8A8:
				case NK_FORMAT_R8G8B8:
				{
					nk_color col = (nk_color) (nk_rgba_fv(val));
					nk_memcopy(attr, &col.r, (ulong) (sizeof (nk_color)));
				}
					break;
				case NK_FORMAT_B8G8R8A8:
				{
					nk_color col = (nk_color) (nk_rgba_fv(val));
					nk_color bgra = (nk_color) (nk_rgba((int) (col.b), (int) (col.g), (int) (col.r), (int) (col.a)));
					nk_memcopy(attr, &bgra, (ulong) (sizeof (nk_color)));
				}
					break;
				case NK_FORMAT_R16G15B16:
				{
					ushort* col = stackalloc ushort[3];
					col[0] = ((ushort) (val[0]*(float) (65535)));
					col[1] = ((ushort) (val[1]*(float) (65535)));
					col[2] = ((ushort) (val[2]*(float) (65535)));
					nk_memcopy(attr, col, (ulong) (sizeof (nk_color)));
				}
					break;
				case NK_FORMAT_R16G15B16A16:
				{
					ushort* col = stackalloc ushort[4];
					col[0] = ((ushort) (val[0]*(float) (65535)));
					col[1] = ((ushort) (val[1]*(float) (65535)));
					col[2] = ((ushort) (val[2]*(float) (65535)));
					col[3] = ((ushort) (val[3]*(float) (65535)));
					nk_memcopy(attr, col, (ulong) (sizeof (nk_color)));
				}
					break;
				case NK_FORMAT_R32G32B32:
				{
					uint* col = stackalloc uint[3];
					col[0] = ((uint) (val[0]*(float) (4294967295u)));
					col[1] = ((uint) (val[1]*(float) (4294967295u)));
					col[2] = ((uint) (val[2]*(float) (4294967295u)));
					nk_memcopy(attr, col, (ulong) (sizeof (nk_color)));
				}
					break;
				case NK_FORMAT_R32G32B32A32:
				{
					uint* col = stackalloc uint[4];
					col[0] = ((uint) (val[0]*(float) (4294967295u)));
					col[1] = ((uint) (val[1]*(float) (4294967295u)));
					col[2] = ((uint) (val[2]*(float) (4294967295u)));
					col[3] = ((uint) (val[3]*(float) (4294967295u)));
					nk_memcopy(attr, col, (ulong) (sizeof (nk_color)));
				}
					break;
				case NK_FORMAT_R32G32B32A32_FLOAT:
					nk_memcopy(attr, val, (ulong) (sizeof (float)*4));
					break;
				case NK_FORMAT_R32G32B32A32_DOUBLE:
				{
					double* col = stackalloc double[4];
					col[0] = ((double) (val[0]));
					col[1] = ((double) (val[1]));
					col[2] = ((double) (val[2]));
					col[3] = ((double) (val[3]));
					nk_memcopy(attr, col, (ulong) (sizeof (nk_color)));
				}
					break;
				case NK_FORMAT_RGB32:
				case NK_FORMAT_RGBA32:
				{
					nk_color col = (nk_color) (nk_rgba_fv(val));
					uint color = (uint) (nk_color_u32((nk_color) (col)));
					nk_memcopy(attr, &color, (ulong) (sizeof (uint)));
				}
					break;
			}

		}

		public static void nk_draw_vertex_element(void* dst, float* values, int value_count, int format)
		{
			int value_index;
			void* attribute = dst;
			if (((format) >= (NK_FORMAT_COLOR_BEGIN)) && (format <= NK_FORMAT_COLOR_END)) return;
			for (value_index = (int) (0); (value_index) < (value_count); ++value_index)
			{
				switch (format)
				{
					default:
						;
						break;
					case NK_FORMAT_SCHAR:
					{
						sbyte value =
							(sbyte)
								(((values[value_index]) < ((float) (127)) ? (values[value_index]) : ((float) (127))) < ((float) (-127))
									? ((float) (-127))
									: ((values[value_index]) < ((float) (127)) ? (values[value_index]) : ((float) (127))));
						nk_memcopy(attribute, &value, (ulong) (sizeof (double)));
						attribute = (void*) (((sbyte*) (attribute) + sizeof (char)));
					}
						break;
					case NK_FORMAT_SSHORT:
					{
						short value =
							(short)
								(((values[value_index]) < ((float) (32767)) ? (values[value_index]) : ((float) (32767))) < ((float) (-32767))
									? ((float) (-32767))
									: ((values[value_index]) < ((float) (32767)) ? (values[value_index]) : ((float) (32767))));
						nk_memcopy(attribute, &value, (ulong) (sizeof (double)));
						attribute = (void*) ((sbyte*) (attribute) + sizeof (short));
					}
						break;
					case NK_FORMAT_SINT:
					{
						int value =
							(int)
								(((values[value_index]) < ((float) (2147483647)) ? (values[value_index]) : ((float) (2147483647))) <
								 ((float) (-2147483647))
									? ((float) (-2147483647))
									: ((values[value_index]) < ((float) (2147483647)) ? (values[value_index]) : ((float) (2147483647))));
						nk_memcopy(attribute, &value, (ulong) (sizeof (double)));
						attribute = (void*) ((sbyte*) (attribute) + sizeof (int));
					}
						break;
					case NK_FORMAT_UCHAR:
					{
						byte value =
							(byte)
								(((values[value_index]) < ((float) (256)) ? (values[value_index]) : ((float) (256))) < ((float) (0))
									? ((float) (0))
									: ((values[value_index]) < ((float) (256)) ? (values[value_index]) : ((float) (256))));
						nk_memcopy(attribute, &value, (ulong) (sizeof (double)));
						attribute = (void*) (((sbyte*) (attribute) + sizeof (byte)));
					}
						break;
					case NK_FORMAT_USHORT:
					{
						ushort value =
							(ushort)
								(((values[value_index]) < ((float) (65535)) ? (values[value_index]) : ((float) (65535))) < ((float) (0))
									? ((float) (0))
									: ((values[value_index]) < ((float) (65535)) ? (values[value_index]) : ((float) (65535))));
						nk_memcopy(attribute, &value, (ulong) (sizeof (double)));
						attribute = (void*) ((sbyte*) (attribute) + sizeof (short));
					}
						break;
					case NK_FORMAT_UINT:
					{
						uint value =
							(uint)
								(((values[value_index]) < ((float) (4294967295u)) ? (values[value_index]) : ((float) (4294967295u))) <
								 ((float) (0))
									? ((float) (0))
									: ((values[value_index]) < ((float) (4294967295u)) ? (values[value_index]) : ((float) (4294967295u))));
						nk_memcopy(attribute, &value, (ulong) (sizeof (double)));
						attribute = (void*) ((sbyte*) (attribute) + sizeof (uint));
					}
						break;
					case NK_FORMAT_FLOAT:
						nk_memcopy(attribute, &values[value_index], (ulong) (sizeof (float)));
						attribute = (void*) (((sbyte*) (attribute) + sizeof (float)));
						break;
					case NK_FORMAT_DOUBLE:
					{
						double value = (double) (values[value_index]);
						nk_memcopy(attribute, &value, (ulong) (sizeof (double)));
						attribute = (void*) (((sbyte*) (attribute) + sizeof (double)));
					}
						break;
				}
			}
		}

		public static void* nk_draw_vertex(void* dst, nk_convert_config config, nk_vec2 pos, nk_vec2 uv, nk_colorf color)
		{
			void* result = (void*) ((sbyte*) (dst) + config.vertex_size);
			fixed (nk_draw_vertex_layout_element* elem_iter2 = config.vertex_layout)
			{
				nk_draw_vertex_layout_element* elem_iter = elem_iter2;
				while (nk_draw_vertex_layout_element_is_end_of_layout(elem_iter) == 0)
				{
					void* address = (void*) ((sbyte*) (dst) + elem_iter->offset);
					switch (elem_iter->attribute)
					{
						case NK_VERTEX_ATTRIBUTE_COUNT:
						default:
							;
							break;
						case NK_VERTEX_POSITION:
							nk_draw_vertex_element(address, &pos.x, (int) (2), (int) (elem_iter->format));
							break;
						case NK_VERTEX_TEXCOORD:
							nk_draw_vertex_element(address, &uv.x, (int) (2), (int) (elem_iter->format));
							break;
						case NK_VERTEX_COLOR:
							nk_draw_vertex_color(address, &color.r, (int) (elem_iter->format));
							break;
					}
					elem_iter++;
				}
			}
			return result;
		}

		public static void nk_draw_list_stroke_poly_line(nk_draw_list list, nk_vec2* points, uint points_count, nk_color color,
			int closed, float thickness, int aliasing)
		{
			ulong count;
			int thick_line;
			nk_colorf col = new nk_colorf();
			nk_colorf col_trans = new nk_colorf();
			if ((list == null) || ((points_count) < (2))) return;
			color.a = ((byte) ((float) (color.a)*list.config.global_alpha));
			count = (ulong) (points_count);
			if (closed == 0) count = (ulong) (points_count - 1);
			thick_line = (int) ((thickness) > (1.0f) ? 1 : 0);
			nk_draw_list_push_userdata(list, (nk_handle) (list.userdata));
			color.a = ((byte) ((float) (color.a)*list.config.global_alpha));
			nk_color_fv(&col.r, (nk_color) (color));
			col_trans = (nk_colorf) (col);
			col_trans.a = (float) (0);
			if ((aliasing) == (NK_ANTI_ALIASING_ON))
			{
				float AA_SIZE = (float) (1.0f);
				ulong pnt_align = (ulong) (4);
				ulong pnt_size = (ulong) (sizeof (nk_vec2));
				ulong i1 = (ulong) (0);
				ulong vertex_offset;
				ulong index = (ulong) (list.vertex_count);
				ulong idx_count = (ulong) ((thick_line) != 0 ? (count*18) : (count*12));
				ulong vtx_count = (ulong) ((thick_line) != 0 ? (points_count*4) : (points_count*3));
				void* vtx = nk_draw_list_alloc_vertices(list, (ulong) (vtx_count));
				ushort* ids = nk_draw_list_alloc_elements(list, (ulong) (idx_count));
				ulong size;
				nk_vec2* normals;
				nk_vec2* temp;
				if ((vtx == null) || (ids == null)) return;
				vertex_offset = ((ulong) ((byte*) (vtx) - (byte*) (list.vertices.memory.ptr)));
				nk_buffer_mark(list.vertices, (int) (NK_BUFFER_FRONT));
				size = (ulong) (pnt_size*(ulong) ((thick_line) != 0 ? 5 : 3)*points_count);
				normals = (nk_vec2*) (nk_buffer_alloc(list.vertices, (int) (NK_BUFFER_FRONT), (ulong) (size), (ulong) (pnt_align)));
				if (normals == null) return;
				temp = normals + points_count;
				vtx = (void*) ((byte*) (list.vertices.memory.ptr) + vertex_offset);
				for (i1 = (ulong) (0); (i1) < (count); ++i1)
				{
					ulong i2 = (ulong) (((i1 + 1) == (points_count)) ? 0 : (i1 + 1));
					nk_vec2 diff =
						(nk_vec2) (nk_vec2_((float) ((points[i2]).x - (points[i1]).x), (float) ((points[i2]).y - (points[i1]).y)));
					float len;
					len = (float) ((diff).x*(diff).x + (diff).y*(diff).y);
					if (len != 0.0f) len = (float) (nk_inv_sqrt((float) (len)));
					else len = (float) (1.0f);
					diff = (nk_vec2) (nk_vec2_((float) ((diff).x*(len)), (float) ((diff).y*(len))));
					normals[i1].x = (float) (diff.y);
					normals[i1].y = (float) (-diff.x);
				}
				if (closed == 0) normals[points_count - 1] = (nk_vec2) (normals[points_count - 2]);
				if (thick_line == 0)
				{
					ulong idx1;
					ulong i;
					if (closed == 0)
					{
						nk_vec2 d = new nk_vec2();
						temp[0] =
							(nk_vec2)
								(nk_vec2_(
									(float) ((points[0]).x + (nk_vec2_((float) ((normals[0]).x*(AA_SIZE)), (float) ((normals[0]).y*(AA_SIZE)))).x),
									(float) ((points[0]).y + (nk_vec2_((float) ((normals[0]).x*(AA_SIZE)), (float) ((normals[0]).y*(AA_SIZE)))).y)));
						temp[1] =
							(nk_vec2)
								(nk_vec2_(
									(float) ((points[0]).x - (nk_vec2_((float) ((normals[0]).x*(AA_SIZE)), (float) ((normals[0]).y*(AA_SIZE)))).x),
									(float) ((points[0]).y - (nk_vec2_((float) ((normals[0]).x*(AA_SIZE)), (float) ((normals[0]).y*(AA_SIZE)))).y)));
						d =
							(nk_vec2)
								(nk_vec2_((float) ((normals[points_count - 1]).x*(AA_SIZE)), (float) ((normals[points_count - 1]).y*(AA_SIZE))));
						temp[(points_count - 1)*2 + 0] =
							(nk_vec2)
								(nk_vec2_((float) ((points[points_count - 1]).x + (d).x), (float) ((points[points_count - 1]).y + (d).y)));
						temp[(points_count - 1)*2 + 1] =
							(nk_vec2)
								(nk_vec2_((float) ((points[points_count - 1]).x - (d).x), (float) ((points[points_count - 1]).y - (d).y)));
					}
					idx1 = (ulong) (index);
					for (i1 = (ulong) (0); (i1) < (count); i1++)
					{
						nk_vec2 dm = new nk_vec2();
						float dmr2;
						ulong i2 = (ulong) (((i1 + 1) == (points_count)) ? 0 : (i1 + 1));
						ulong idx2 = (ulong) (((i1 + 1) == (points_count)) ? index : (idx1 + 3));
						dm =
							(nk_vec2)
								(nk_vec2_(
									(float)
										((nk_vec2_((float) ((normals[i1]).x + (normals[i2]).x), (float) ((normals[i1]).y + (normals[i2]).y))).x*(0.5f)),
									(float)
										((nk_vec2_((float) ((normals[i1]).x + (normals[i2]).x), (float) ((normals[i1]).y + (normals[i2]).y))).y*(0.5f))));
						dmr2 = (float) (dm.x*dm.x + dm.y*dm.y);
						if ((dmr2) > (0.000001f))
						{
							float scale = (float) (1.0f/dmr2);
							scale = (float) ((100.0f) < (scale) ? (100.0f) : (scale));
							dm = (nk_vec2) (nk_vec2_((float) ((dm).x*(scale)), (float) ((dm).y*(scale))));
						}
						dm = (nk_vec2) (nk_vec2_((float) ((dm).x*(AA_SIZE)), (float) ((dm).y*(AA_SIZE))));
						temp[i2*2 + 0] = (nk_vec2) (nk_vec2_((float) ((points[i2]).x + (dm).x), (float) ((points[i2]).y + (dm).y)));
						temp[i2*2 + 1] = (nk_vec2) (nk_vec2_((float) ((points[i2]).x - (dm).x), (float) ((points[i2]).y - (dm).y)));
						ids[0] = ((ushort) (idx2 + 0));
						ids[1] = ((ushort) (idx1 + 0));
						ids[2] = ((ushort) (idx1 + 2));
						ids[3] = ((ushort) (idx1 + 2));
						ids[4] = ((ushort) (idx2 + 2));
						ids[5] = ((ushort) (idx2 + 0));
						ids[6] = ((ushort) (idx2 + 1));
						ids[7] = ((ushort) (idx1 + 1));
						ids[8] = ((ushort) (idx1 + 0));
						ids[9] = ((ushort) (idx1 + 0));
						ids[10] = ((ushort) (idx2 + 0));
						ids[11] = ((ushort) (idx2 + 1));
						ids += 12;
						idx1 = (ulong) (idx2);
					}
					for (i = (ulong) (0); (i) < (points_count); ++i)
					{
						nk_vec2 uv = (nk_vec2) (list.config._null_.uv);
						vtx = nk_draw_vertex(vtx, list.config, (nk_vec2) (points[i]), (nk_vec2) (uv), (nk_colorf) (col));
						vtx = nk_draw_vertex(vtx, list.config, (nk_vec2) (temp[i*2 + 0]), (nk_vec2) (uv), (nk_colorf) (col_trans));
						vtx = nk_draw_vertex(vtx, list.config, (nk_vec2) (temp[i*2 + 1]), (nk_vec2) (uv), (nk_colorf) (col_trans));
					}
				}
				else
				{
					ulong idx1;
					ulong i;
					float half_inner_thickness = (float) ((thickness - AA_SIZE)*0.5f);
					if (closed == 0)
					{
						nk_vec2 d1 =
							(nk_vec2)
								(nk_vec2_((float) ((normals[0]).x*(half_inner_thickness + AA_SIZE)),
									(float) ((normals[0]).y*(half_inner_thickness + AA_SIZE))));
						nk_vec2 d2 =
							(nk_vec2)
								(nk_vec2_((float) ((normals[0]).x*(half_inner_thickness)), (float) ((normals[0]).y*(half_inner_thickness))));
						temp[0] = (nk_vec2) (nk_vec2_((float) ((points[0]).x + (d1).x), (float) ((points[0]).y + (d1).y)));
						temp[1] = (nk_vec2) (nk_vec2_((float) ((points[0]).x + (d2).x), (float) ((points[0]).y + (d2).y)));
						temp[2] = (nk_vec2) (nk_vec2_((float) ((points[0]).x - (d2).x), (float) ((points[0]).y - (d2).y)));
						temp[3] = (nk_vec2) (nk_vec2_((float) ((points[0]).x - (d1).x), (float) ((points[0]).y - (d1).y)));
						d1 =
							(nk_vec2)
								(nk_vec2_((float) ((normals[points_count - 1]).x*(half_inner_thickness + AA_SIZE)),
									(float) ((normals[points_count - 1]).y*(half_inner_thickness + AA_SIZE))));
						d2 =
							(nk_vec2)
								(nk_vec2_((float) ((normals[points_count - 1]).x*(half_inner_thickness)),
									(float) ((normals[points_count - 1]).y*(half_inner_thickness))));
						temp[(points_count - 1)*4 + 0] =
							(nk_vec2)
								(nk_vec2_((float) ((points[points_count - 1]).x + (d1).x), (float) ((points[points_count - 1]).y + (d1).y)));
						temp[(points_count - 1)*4 + 1] =
							(nk_vec2)
								(nk_vec2_((float) ((points[points_count - 1]).x + (d2).x), (float) ((points[points_count - 1]).y + (d2).y)));
						temp[(points_count - 1)*4 + 2] =
							(nk_vec2)
								(nk_vec2_((float) ((points[points_count - 1]).x - (d2).x), (float) ((points[points_count - 1]).y - (d2).y)));
						temp[(points_count - 1)*4 + 3] =
							(nk_vec2)
								(nk_vec2_((float) ((points[points_count - 1]).x - (d1).x), (float) ((points[points_count - 1]).y - (d1).y)));
					}
					idx1 = (ulong) (index);
					for (i1 = (ulong) (0); (i1) < (count); ++i1)
					{
						nk_vec2 dm_out = new nk_vec2();
						nk_vec2 dm_in = new nk_vec2();
						ulong i2 = (ulong) (((i1 + 1) == (points_count)) ? 0 : (i1 + 1));
						ulong idx2 = (ulong) (((i1 + 1) == (points_count)) ? index : (idx1 + 4));
						nk_vec2 dm =
							(nk_vec2)
								(nk_vec2_(
									(float)
										((nk_vec2_((float) ((normals[i1]).x + (normals[i2]).x), (float) ((normals[i1]).y + (normals[i2]).y))).x*(0.5f)),
									(float)
										((nk_vec2_((float) ((normals[i1]).x + (normals[i2]).x), (float) ((normals[i1]).y + (normals[i2]).y))).y*(0.5f))));
						float dmr2 = (float) (dm.x*dm.x + dm.y*dm.y);
						if ((dmr2) > (0.000001f))
						{
							float scale = (float) (1.0f/dmr2);
							scale = (float) ((100.0f) < (scale) ? (100.0f) : (scale));
							dm = (nk_vec2) (nk_vec2_((float) ((dm).x*(scale)), (float) ((dm).y*(scale))));
						}
						dm_out =
							(nk_vec2)
								(nk_vec2_((float) ((dm).x*((half_inner_thickness) + AA_SIZE)),
									(float) ((dm).y*((half_inner_thickness) + AA_SIZE))));
						dm_in = (nk_vec2) (nk_vec2_((float) ((dm).x*(half_inner_thickness)), (float) ((dm).y*(half_inner_thickness))));
						temp[i2*4 + 0] =
							(nk_vec2) (nk_vec2_((float) ((points[i2]).x + (dm_out).x), (float) ((points[i2]).y + (dm_out).y)));
						temp[i2*4 + 1] = (nk_vec2) (nk_vec2_((float) ((points[i2]).x + (dm_in).x), (float) ((points[i2]).y + (dm_in).y)));
						temp[i2*4 + 2] = (nk_vec2) (nk_vec2_((float) ((points[i2]).x - (dm_in).x), (float) ((points[i2]).y - (dm_in).y)));
						temp[i2*4 + 3] =
							(nk_vec2) (nk_vec2_((float) ((points[i2]).x - (dm_out).x), (float) ((points[i2]).y - (dm_out).y)));
						ids[0] = ((ushort) (idx2 + 1));
						ids[1] = ((ushort) (idx1 + 1));
						ids[2] = ((ushort) (idx1 + 2));
						ids[3] = ((ushort) (idx1 + 2));
						ids[4] = ((ushort) (idx2 + 2));
						ids[5] = ((ushort) (idx2 + 1));
						ids[6] = ((ushort) (idx2 + 1));
						ids[7] = ((ushort) (idx1 + 1));
						ids[8] = ((ushort) (idx1 + 0));
						ids[9] = ((ushort) (idx1 + 0));
						ids[10] = ((ushort) (idx2 + 0));
						ids[11] = ((ushort) (idx2 + 1));
						ids[12] = ((ushort) (idx2 + 2));
						ids[13] = ((ushort) (idx1 + 2));
						ids[14] = ((ushort) (idx1 + 3));
						ids[15] = ((ushort) (idx1 + 3));
						ids[16] = ((ushort) (idx2 + 3));
						ids[17] = ((ushort) (idx2 + 2));
						ids += 18;
						idx1 = (ulong) (idx2);
					}
					for (i = (ulong) (0); (i) < (points_count); ++i)
					{
						nk_vec2 uv = (nk_vec2) (list.config._null_.uv);
						vtx = nk_draw_vertex(vtx, list.config, (nk_vec2) (temp[i*4 + 0]), (nk_vec2) (uv), (nk_colorf) (col_trans));
						vtx = nk_draw_vertex(vtx, list.config, (nk_vec2) (temp[i*4 + 1]), (nk_vec2) (uv), (nk_colorf) (col));
						vtx = nk_draw_vertex(vtx, list.config, (nk_vec2) (temp[i*4 + 2]), (nk_vec2) (uv), (nk_colorf) (col));
						vtx = nk_draw_vertex(vtx, list.config, (nk_vec2) (temp[i*4 + 3]), (nk_vec2) (uv), (nk_colorf) (col_trans));
					}
				}
				nk_buffer_reset(list.vertices, (int) (NK_BUFFER_FRONT));
			}
			else
			{
				ulong i1 = (ulong) (0);
				ulong idx = (ulong) (list.vertex_count);
				ulong idx_count = (ulong) (count*6);
				ulong vtx_count = (ulong) (count*4);
				void* vtx = nk_draw_list_alloc_vertices(list, (ulong) (vtx_count));
				ushort* ids = nk_draw_list_alloc_elements(list, (ulong) (idx_count));
				if ((vtx == null) || (ids == null)) return;
				for (i1 = (ulong) (0); (i1) < (count); ++i1)
				{
					float dx;
					float dy;
					nk_vec2 uv = (nk_vec2) (list.config._null_.uv);
					ulong i2 = (ulong) (((i1 + 1) == (points_count)) ? 0 : i1 + 1);
					nk_vec2 p1 = (nk_vec2) (points[i1]);
					nk_vec2 p2 = (nk_vec2) (points[i2]);
					nk_vec2 diff = (nk_vec2) (nk_vec2_((float) ((p2).x - (p1).x), (float) ((p2).y - (p1).y)));
					float len;
					len = (float) ((diff).x*(diff).x + (diff).y*(diff).y);
					if (len != 0.0f) len = (float) (nk_inv_sqrt((float) (len)));
					else len = (float) (1.0f);
					diff = (nk_vec2) (nk_vec2_((float) ((diff).x*(len)), (float) ((diff).y*(len))));
					dx = (float) (diff.x*(thickness*0.5f));
					dy = (float) (diff.y*(thickness*0.5f));
					vtx = nk_draw_vertex(vtx, list.config, (nk_vec2) (nk_vec2_((float) (p1.x + dy), (float) (p1.y - dx))),
						(nk_vec2) (uv), (nk_colorf) (col));
					vtx = nk_draw_vertex(vtx, list.config, (nk_vec2) (nk_vec2_((float) (p2.x + dy), (float) (p2.y - dx))),
						(nk_vec2) (uv), (nk_colorf) (col));
					vtx = nk_draw_vertex(vtx, list.config, (nk_vec2) (nk_vec2_((float) (p2.x - dy), (float) (p2.y + dx))),
						(nk_vec2) (uv), (nk_colorf) (col));
					vtx = nk_draw_vertex(vtx, list.config, (nk_vec2) (nk_vec2_((float) (p1.x - dy), (float) (p1.y + dx))),
						(nk_vec2) (uv), (nk_colorf) (col));
					ids[0] = ((ushort) (idx + 0));
					ids[1] = ((ushort) (idx + 1));
					ids[2] = ((ushort) (idx + 2));
					ids[3] = ((ushort) (idx + 0));
					ids[4] = ((ushort) (idx + 2));
					ids[5] = ((ushort) (idx + 3));
					ids += 6;
					idx += (ulong) (4);
				}
			}

		}

		public static void nk_draw_list_fill_poly_convex(nk_draw_list list, nk_vec2* points, uint points_count, nk_color color,
			int aliasing)
		{
			nk_colorf col = new nk_colorf();
			nk_colorf col_trans = new nk_colorf();
			ulong pnt_align = (ulong) (4);
			ulong pnt_size = (ulong) (sizeof (nk_vec2));
			if ((list == null) || ((points_count) < (3))) return;
			nk_draw_list_push_userdata(list, (nk_handle) (list.userdata));
			color.a = ((byte) ((float) (color.a)*list.config.global_alpha));
			nk_color_fv(&col.r, (nk_color) (color));
			col_trans = (nk_colorf) (col);
			col_trans.a = (float) (0);
			if ((aliasing) == (NK_ANTI_ALIASING_ON))
			{
				ulong i = (ulong) (0);
				ulong i0 = (ulong) (0);
				ulong i1 = (ulong) (0);
				float AA_SIZE = (float) (1.0f);
				ulong vertex_offset = (ulong) (0);
				ulong index = (ulong) (list.vertex_count);
				ulong idx_count = (ulong) ((points_count - 2)*3 + points_count*6);
				ulong vtx_count = (ulong) (points_count*2);
				void* vtx = nk_draw_list_alloc_vertices(list, (ulong) (vtx_count));
				ushort* ids = nk_draw_list_alloc_elements(list, (ulong) (idx_count));
				ulong size = (ulong) (0);
				nk_vec2* normals = null;
				uint vtx_inner_idx = (uint) (index + 0);
				uint vtx_outer_idx = (uint) (index + 1);
				if ((vtx == null) || (ids == null)) return;
				vertex_offset = ((ulong) ((byte*) (vtx) - (byte*) (list.vertices.memory.ptr)));
				nk_buffer_mark(list.vertices, (int) (NK_BUFFER_FRONT));
				size = (ulong) (pnt_size*points_count);
				normals = (nk_vec2*) (nk_buffer_alloc(list.vertices, (int) (NK_BUFFER_FRONT), (ulong) (size), (ulong) (pnt_align)));
				if (normals == null) return;
				vtx = (void*) ((byte*) (list.vertices.memory.ptr) + vertex_offset);
				for (i = (ulong) (2); (i) < (points_count); i++)
				{
					ids[0] = ((ushort) (vtx_inner_idx));
					ids[1] = ((ushort) (vtx_inner_idx + ((i - 1) << 1)));
					ids[2] = ((ushort) (vtx_inner_idx + (i << 1)));
					ids += 3;
				}
				for (i0 = (ulong) (points_count - 1) , i1 = (ulong) (0); (i1) < (points_count); i0 = (ulong) (i1++))
				{
					nk_vec2 p0 = (nk_vec2) (points[i0]);
					nk_vec2 p1 = (nk_vec2) (points[i1]);
					nk_vec2 diff = (nk_vec2) (nk_vec2_((float) ((p1).x - (p0).x), (float) ((p1).y - (p0).y)));
					float len = (float) ((diff).x*(diff).x + (diff).y*(diff).y);
					if (len != 0.0f) len = (float) (nk_inv_sqrt((float) (len)));
					else len = (float) (1.0f);
					diff = (nk_vec2) (nk_vec2_((float) ((diff).x*(len)), (float) ((diff).y*(len))));
					normals[i0].x = (float) (diff.y);
					normals[i0].y = (float) (-diff.x);
				}
				for (i0 = (ulong) (points_count - 1) , i1 = (ulong) (0); (i1) < (points_count); i0 = (ulong) (i1++))
				{
					nk_vec2 uv = (nk_vec2) (list.config._null_.uv);
					nk_vec2 n0 = (nk_vec2) (normals[i0]);
					nk_vec2 n1 = (nk_vec2) (normals[i1]);
					nk_vec2 dm =
						(nk_vec2)
							(nk_vec2_((float) ((nk_vec2_((float) ((n0).x + (n1).x), (float) ((n0).y + (n1).y))).x*(0.5f)),
								(float) ((nk_vec2_((float) ((n0).x + (n1).x), (float) ((n0).y + (n1).y))).y*(0.5f))));
					float dmr2 = (float) (dm.x*dm.x + dm.y*dm.y);
					if ((dmr2) > (0.000001f))
					{
						float scale = (float) (1.0f/dmr2);
						scale = (float) ((scale) < (100.0f) ? (scale) : (100.0f));
						dm = (nk_vec2) (nk_vec2_((float) ((dm).x*(scale)), (float) ((dm).y*(scale))));
					}
					dm = (nk_vec2) (nk_vec2_((float) ((dm).x*(AA_SIZE*0.5f)), (float) ((dm).y*(AA_SIZE*0.5f))));
					vtx = nk_draw_vertex(vtx, list.config,
						(nk_vec2) (nk_vec2_((float) ((points[i1]).x - (dm).x), (float) ((points[i1]).y - (dm).y))), (nk_vec2) (uv),
						(nk_colorf) (col));
					vtx = nk_draw_vertex(vtx, list.config,
						(nk_vec2) (nk_vec2_((float) ((points[i1]).x + (dm).x), (float) ((points[i1]).y + (dm).y))), (nk_vec2) (uv),
						(nk_colorf) (col_trans));
					ids[0] = ((ushort) (vtx_inner_idx + (i1 << 1)));
					ids[1] = ((ushort) (vtx_inner_idx + (i0 << 1)));
					ids[2] = ((ushort) (vtx_outer_idx + (i0 << 1)));
					ids[3] = ((ushort) (vtx_outer_idx + (i0 << 1)));
					ids[4] = ((ushort) (vtx_outer_idx + (i1 << 1)));
					ids[5] = ((ushort) (vtx_inner_idx + (i1 << 1)));
					ids += 6;
				}
				nk_buffer_reset(list.vertices, (int) (NK_BUFFER_FRONT));
			}
			else
			{
				ulong i = (ulong) (0);
				ulong index = (ulong) (list.vertex_count);
				ulong idx_count = (ulong) ((points_count - 2)*3);
				ulong vtx_count = (ulong) (points_count);
				void* vtx = nk_draw_list_alloc_vertices(list, (ulong) (vtx_count));
				ushort* ids = nk_draw_list_alloc_elements(list, (ulong) (idx_count));
				if ((vtx == null) || (ids == null)) return;
				for (i = (ulong) (0); (i) < (vtx_count); ++i)
				{
					vtx = nk_draw_vertex(vtx, list.config, (nk_vec2) (points[i]), (nk_vec2) (list.config._null_.uv), (nk_colorf) (col));
				}
				for (i = (ulong) (2); (i) < (points_count); ++i)
				{
					ids[0] = ((ushort) (index));
					ids[1] = ((ushort) (index + i - 1));
					ids[2] = ((ushort) (index + i));
					ids += 3;
				}
			}

		}

		public static void nk_draw_list_path_clear(nk_draw_list list)
		{
			if (list == null) return;
			nk_buffer_reset(list.buffer, (int) (NK_BUFFER_FRONT));
			list.path_count = (uint) (0);
			list.path_offset = (uint) (0);
		}

		public static void nk_draw_list_path_line_to(nk_draw_list list, nk_vec2 pos)
		{
			nk_vec2* points = null;
			nk_draw_command* cmd = null;
			if (list == null) return;
			if (list.cmd_count == 0) nk_draw_list_add_clip(list, (nk_rect) (nk_null_rect));
			cmd = nk_draw_list_command_last(list);
			if (((cmd) != null) && (cmd->texture.ptr != list.config._null_.texture.ptr))
				nk_draw_list_push_image(list, (nk_handle) (list.config._null_.texture));
			points = nk_draw_list_alloc_path(list, (int) (1));
			if (points == null) return;
			points[0] = (nk_vec2) (pos);
		}

		public static void nk_draw_list_path_arc_to_fast(nk_draw_list list, nk_vec2 center, float radius, int a_min, int a_max)
		{
			int a = (int) (0);
			if (list == null) return;
			if (a_min <= a_max)
			{
				for (a = (int) (a_min); a <= a_max; a++)
				{
					nk_vec2 c = (nk_vec2) (list.circle_vtx[(ulong) (a)%(ulong) list.circle_vtx.Length]);
					float x = (float) (center.x + c.x*radius);
					float y = (float) (center.y + c.y*radius);
					nk_draw_list_path_line_to(list, (nk_vec2) (nk_vec2_((float) (x), (float) (y))));
				}
			}

		}

		public static void nk_draw_list_path_arc_to(nk_draw_list list, nk_vec2 center, float radius, float a_min, float a_max,
			uint segments)
		{
			uint i = (uint) (0);
			if (list == null) return;
			if ((radius) == (0.0f)) return;
			{
				float d_angle = (float) ((a_max - a_min)/(float) (segments));
				float sin_d = (float) (nk_sin((float) (d_angle)));
				float cos_d = (float) (nk_cos((float) (d_angle)));
				float cx = (float) (nk_cos((float) (a_min))*radius);
				float cy = (float) (nk_sin((float) (a_min))*radius);
				for (i = (uint) (0); i <= segments; ++i)
				{
					float new_cx;
					float new_cy;
					float x = (float) (center.x + cx);
					float y = (float) (center.y + cy);
					nk_draw_list_path_line_to(list, (nk_vec2) (nk_vec2_((float) (x), (float) (y))));
					new_cx = (float) (cx*cos_d - cy*sin_d);
					new_cy = (float) (cy*cos_d + cx*sin_d);
					cx = (float) (new_cx);
					cy = (float) (new_cy);
				}
			}

		}

		public static void nk_draw_list_path_rect_to(nk_draw_list list, nk_vec2 a, nk_vec2 b, float rounding)
		{
			float r;
			if (list == null) return;
			r = (float) (rounding);
			r =
				(float)
					((r) < (((b.x - a.x) < (0)) ? -(b.x - a.x) : (b.x - a.x))
						? (r)
						: (((b.x - a.x) < (0)) ? -(b.x - a.x) : (b.x - a.x)));
			r =
				(float)
					((r) < (((b.y - a.y) < (0)) ? -(b.y - a.y) : (b.y - a.y))
						? (r)
						: (((b.y - a.y) < (0)) ? -(b.y - a.y) : (b.y - a.y)));
			if ((r) == (0.0f))
			{
				nk_draw_list_path_line_to(list, (nk_vec2) (a));
				nk_draw_list_path_line_to(list, (nk_vec2) (nk_vec2_((float) (b.x), (float) (a.y))));
				nk_draw_list_path_line_to(list, (nk_vec2) (b));
				nk_draw_list_path_line_to(list, (nk_vec2) (nk_vec2_((float) (a.x), (float) (b.y))));
			}
			else
			{
				nk_draw_list_path_arc_to_fast(list, (nk_vec2) (nk_vec2_((float) (a.x + r), (float) (a.y + r))), (float) (r),
					(int) (6), (int) (9));
				nk_draw_list_path_arc_to_fast(list, (nk_vec2) (nk_vec2_((float) (b.x - r), (float) (a.y + r))), (float) (r),
					(int) (9), (int) (12));
				nk_draw_list_path_arc_to_fast(list, (nk_vec2) (nk_vec2_((float) (b.x - r), (float) (b.y - r))), (float) (r),
					(int) (0), (int) (3));
				nk_draw_list_path_arc_to_fast(list, (nk_vec2) (nk_vec2_((float) (a.x + r), (float) (b.y - r))), (float) (r),
					(int) (3), (int) (6));
			}

		}

		public static void nk_draw_list_path_curve_to(nk_draw_list list, nk_vec2 p2, nk_vec2 p3, nk_vec2 p4, uint num_segments)
		{
			float t_step;
			uint i_step;
			nk_vec2 p1 = new nk_vec2();
			if ((list == null) || (list.path_count == 0)) return;
			num_segments = (uint) ((num_segments) < (1) ? (1) : (num_segments));
			p1 = (nk_vec2) (nk_draw_list_path_last(list));
			t_step = (float) (1.0f/(float) (num_segments));
			for (i_step = (uint) (1); i_step <= num_segments; ++i_step)
			{
				float t = (float) (t_step*(float) (i_step));
				float u = (float) (1.0f - t);
				float w1 = (float) (u*u*u);
				float w2 = (float) (3*u*u*t);
				float w3 = (float) (3*u*t*t);
				float w4 = (float) (t*t*t);
				float x = (float) (w1*p1.x + w2*p2.x + w3*p3.x + w4*p4.x);
				float y = (float) (w1*p1.y + w2*p2.y + w3*p3.y + w4*p4.y);
				nk_draw_list_path_line_to(list, (nk_vec2) (nk_vec2_((float) (x), (float) (y))));
			}
		}

		public static void nk_draw_list_path_fill(nk_draw_list list, nk_color color)
		{
			nk_vec2* points;
			if (list == null) return;
			points = (nk_vec2*) (nk_buffer_memory(list.buffer));
			nk_draw_list_fill_poly_convex(list, points, (uint) (list.path_count), (nk_color) (color),
				(int) (list.config.shape_AA));
			nk_draw_list_path_clear(list);
		}

		public static void nk_draw_list_path_stroke(nk_draw_list list, nk_color color, int closed, float thickness)
		{
			nk_vec2* points;
			if (list == null) return;
			points = (nk_vec2*) (nk_buffer_memory(list.buffer));
			nk_draw_list_stroke_poly_line(list, points, (uint) (list.path_count), (nk_color) (color), (int) (closed),
				(float) (thickness), (int) (list.config.line_AA));
			nk_draw_list_path_clear(list);
		}

		public static void nk_draw_list_stroke_line(nk_draw_list list, nk_vec2 a, nk_vec2 b, nk_color col, float thickness)
		{
			if ((list == null) || (col.a == 0)) return;
			if ((list.line_AA) == (NK_ANTI_ALIASING_ON))
			{
				nk_draw_list_path_line_to(list, (nk_vec2) (a));
				nk_draw_list_path_line_to(list, (nk_vec2) (b));
			}
			else
			{
				nk_draw_list_path_line_to(list,
					(nk_vec2)
						(nk_vec2_((float) ((a).x - (nk_vec2_((float) (0.5f), (float) (0.5f))).x),
							(float) ((a).y - (nk_vec2_((float) (0.5f), (float) (0.5f))).y))));
				nk_draw_list_path_line_to(list,
					(nk_vec2)
						(nk_vec2_((float) ((b).x - (nk_vec2_((float) (0.5f), (float) (0.5f))).x),
							(float) ((b).y - (nk_vec2_((float) (0.5f), (float) (0.5f))).y))));
			}

			nk_draw_list_path_stroke(list, (nk_color) (col), (int) (NK_STROKE_OPEN), (float) (thickness));
		}

		public static void nk_draw_list_fill_rect(nk_draw_list list, nk_rect rect, nk_color col, float rounding)
		{
			if ((list == null) || (col.a == 0)) return;
			if ((list.line_AA) == (NK_ANTI_ALIASING_ON))
			{
				nk_draw_list_path_rect_to(list, (nk_vec2) (nk_vec2_((float) (rect.x), (float) (rect.y))),
					(nk_vec2) (nk_vec2_((float) (rect.x + rect.w), (float) (rect.y + rect.h))), (float) (rounding));
			}
			else
			{
				nk_draw_list_path_rect_to(list, (nk_vec2) (nk_vec2_((float) (rect.x - 0.5f), (float) (rect.y - 0.5f))),
					(nk_vec2) (nk_vec2_((float) (rect.x + rect.w), (float) (rect.y + rect.h))), (float) (rounding));
			}

			nk_draw_list_path_fill(list, (nk_color) (col));
		}

		public static void nk_draw_list_stroke_rect(nk_draw_list list, nk_rect rect, nk_color col, float rounding,
			float thickness)
		{
			if ((list == null) || (col.a == 0)) return;
			if ((list.line_AA) == (NK_ANTI_ALIASING_ON))
			{
				nk_draw_list_path_rect_to(list, (nk_vec2) (nk_vec2_((float) (rect.x), (float) (rect.y))),
					(nk_vec2) (nk_vec2_((float) (rect.x + rect.w), (float) (rect.y + rect.h))), (float) (rounding));
			}
			else
			{
				nk_draw_list_path_rect_to(list, (nk_vec2) (nk_vec2_((float) (rect.x - 0.5f), (float) (rect.y - 0.5f))),
					(nk_vec2) (nk_vec2_((float) (rect.x + rect.w), (float) (rect.y + rect.h))), (float) (rounding));
			}

			nk_draw_list_path_stroke(list, (nk_color) (col), (int) (NK_STROKE_CLOSED), (float) (thickness));
		}

		public static void nk_draw_list_fill_rect_multi_color(nk_draw_list list, nk_rect rect, nk_color left, nk_color top,
			nk_color right, nk_color bottom)
		{
			void* vtx;
			nk_colorf col_left = new nk_colorf();
			nk_colorf col_top = new nk_colorf();
			nk_colorf col_right = new nk_colorf();
			nk_colorf col_bottom = new nk_colorf();
			ushort* idx;
			ushort index;
			nk_color_fv(&col_left.r, (nk_color) (left));
			nk_color_fv(&col_right.r, (nk_color) (right));
			nk_color_fv(&col_top.r, (nk_color) (top));
			nk_color_fv(&col_bottom.r, (nk_color) (bottom));
			if (list == null) return;
			nk_draw_list_push_image(list, (nk_handle) (list.config._null_.texture));
			index = ((ushort) (list.vertex_count));
			vtx = nk_draw_list_alloc_vertices(list, (ulong) (4));
			idx = nk_draw_list_alloc_elements(list, (ulong) (6));
			if ((vtx == null) || (idx == null)) return;
			idx[0] = ((ushort) (index + 0));
			idx[1] = ((ushort) (index + 1));
			idx[2] = ((ushort) (index + 2));
			idx[3] = ((ushort) (index + 0));
			idx[4] = ((ushort) (index + 2));
			idx[5] = ((ushort) (index + 3));
			vtx = nk_draw_vertex(vtx, list.config, (nk_vec2) (nk_vec2_((float) (rect.x), (float) (rect.y))),
				(nk_vec2) (list.config._null_.uv), (nk_colorf) (col_left));
			vtx = nk_draw_vertex(vtx, list.config, (nk_vec2) (nk_vec2_((float) (rect.x + rect.w), (float) (rect.y))),
				(nk_vec2) (list.config._null_.uv), (nk_colorf) (col_top));
			vtx = nk_draw_vertex(vtx, list.config, (nk_vec2) (nk_vec2_((float) (rect.x + rect.w), (float) (rect.y + rect.h))),
				(nk_vec2) (list.config._null_.uv), (nk_colorf) (col_right));
			vtx = nk_draw_vertex(vtx, list.config, (nk_vec2) (nk_vec2_((float) (rect.x), (float) (rect.y + rect.h))),
				(nk_vec2) (list.config._null_.uv), (nk_colorf) (col_bottom));
		}

		public static void nk_draw_list_fill_triangle(nk_draw_list list, nk_vec2 a, nk_vec2 b, nk_vec2 c, nk_color col)
		{
			if ((list == null) || (col.a == 0)) return;
			nk_draw_list_path_line_to(list, (nk_vec2) (a));
			nk_draw_list_path_line_to(list, (nk_vec2) (b));
			nk_draw_list_path_line_to(list, (nk_vec2) (c));
			nk_draw_list_path_fill(list, (nk_color) (col));
		}

		public static void nk_draw_list_stroke_triangle(nk_draw_list list, nk_vec2 a, nk_vec2 b, nk_vec2 c, nk_color col,
			float thickness)
		{
			if ((list == null) || (col.a == 0)) return;
			nk_draw_list_path_line_to(list, (nk_vec2) (a));
			nk_draw_list_path_line_to(list, (nk_vec2) (b));
			nk_draw_list_path_line_to(list, (nk_vec2) (c));
			nk_draw_list_path_stroke(list, (nk_color) (col), (int) (NK_STROKE_CLOSED), (float) (thickness));
		}

		public static void nk_draw_list_fill_circle(nk_draw_list list, nk_vec2 center, float radius, nk_color col, uint segs)
		{
			float a_max;
			if ((list == null) || (col.a == 0)) return;
			a_max = (float) (3.141592654f*2.0f*((float) (segs) - 1.0f)/(float) (segs));
			nk_draw_list_path_arc_to(list, (nk_vec2) (center), (float) (radius), (float) (0.0f), (float) (a_max), (uint) (segs));
			nk_draw_list_path_fill(list, (nk_color) (col));
		}

		public static void nk_draw_list_stroke_circle(nk_draw_list list, nk_vec2 center, float radius, nk_color col, uint segs,
			float thickness)
		{
			float a_max;
			if ((list == null) || (col.a == 0)) return;
			a_max = (float) (3.141592654f*2.0f*((float) (segs) - 1.0f)/(float) (segs));
			nk_draw_list_path_arc_to(list, (nk_vec2) (center), (float) (radius), (float) (0.0f), (float) (a_max), (uint) (segs));
			nk_draw_list_path_stroke(list, (nk_color) (col), (int) (NK_STROKE_CLOSED), (float) (thickness));
		}

		public static void nk_draw_list_stroke_curve(nk_draw_list list, nk_vec2 p0, nk_vec2 cp0, nk_vec2 cp1, nk_vec2 p1,
			nk_color col, uint segments, float thickness)
		{
			if ((list == null) || (col.a == 0)) return;
			nk_draw_list_path_line_to(list, (nk_vec2) (p0));
			nk_draw_list_path_curve_to(list, (nk_vec2) (cp0), (nk_vec2) (cp1), (nk_vec2) (p1), (uint) (segments));
			nk_draw_list_path_stroke(list, (nk_color) (col), (int) (NK_STROKE_OPEN), (float) (thickness));
		}

		public static void nk_draw_list_push_rect_uv(nk_draw_list list, nk_vec2 a, nk_vec2 c, nk_vec2 uva, nk_vec2 uvc,
			nk_color color)
		{
			void* vtx;
			nk_vec2 uvb = new nk_vec2();
			nk_vec2 uvd = new nk_vec2();
			nk_vec2 b = new nk_vec2();
			nk_vec2 d = new nk_vec2();
			nk_colorf col = new nk_colorf();
			ushort* idx;
			ushort index;
			if (list == null) return;
			nk_color_fv(&col.r, (nk_color) (color));
			uvb = (nk_vec2) (nk_vec2_((float) (uvc.x), (float) (uva.y)));
			uvd = (nk_vec2) (nk_vec2_((float) (uva.x), (float) (uvc.y)));
			b = (nk_vec2) (nk_vec2_((float) (c.x), (float) (a.y)));
			d = (nk_vec2) (nk_vec2_((float) (a.x), (float) (c.y)));
			index = ((ushort) (list.vertex_count));
			vtx = nk_draw_list_alloc_vertices(list, (ulong) (4));
			idx = nk_draw_list_alloc_elements(list, (ulong) (6));
			if ((vtx == null) || (idx == null)) return;
			idx[0] = ((ushort) (index + 0));
			idx[1] = ((ushort) (index + 1));
			idx[2] = ((ushort) (index + 2));
			idx[3] = ((ushort) (index + 0));
			idx[4] = ((ushort) (index + 2));
			idx[5] = ((ushort) (index + 3));
			vtx = nk_draw_vertex(vtx, list.config, (nk_vec2) (a), (nk_vec2) (uva), (nk_colorf) (col));
			vtx = nk_draw_vertex(vtx, list.config, (nk_vec2) (b), (nk_vec2) (uvb), (nk_colorf) (col));
			vtx = nk_draw_vertex(vtx, list.config, (nk_vec2) (c), (nk_vec2) (uvc), (nk_colorf) (col));
			vtx = nk_draw_vertex(vtx, list.config, (nk_vec2) (d), (nk_vec2) (uvd), (nk_colorf) (col));
		}

		public static void nk_draw_list_add_image(nk_draw_list list, nk_image texture, nk_rect rect, nk_color color)
		{
			if (list == null) return;
			nk_draw_list_push_image(list, (nk_handle) (texture.handle));
			if ((nk_image_is_subimage(texture)) != 0)
			{
				nk_vec2* uv = stackalloc nk_vec2[2];
				uv[0].x = (float) ((float) (texture.region[0])/(float) (texture.w));
				uv[0].y = (float) ((float) (texture.region[1])/(float) (texture.h));
				uv[1].x = (float) ((float) (texture.region[0] + texture.region[2])/(float) (texture.w));
				uv[1].y = (float) ((float) (texture.region[1] + texture.region[3])/(float) (texture.h));
				nk_draw_list_push_rect_uv(list, (nk_vec2) (nk_vec2_((float) (rect.x), (float) (rect.y))),
					(nk_vec2) (nk_vec2_((float) (rect.x + rect.w), (float) (rect.y + rect.h))), (nk_vec2) (uv[0]), (nk_vec2) (uv[1]),
					(nk_color) (color));
			}
			else
				nk_draw_list_push_rect_uv(list, (nk_vec2) (nk_vec2_((float) (rect.x), (float) (rect.y))),
					(nk_vec2) (nk_vec2_((float) (rect.x + rect.w), (float) (rect.y + rect.h))),
					(nk_vec2) (nk_vec2_((float) (0.0f), (float) (0.0f))), (nk_vec2) (nk_vec2_((float) (1.0f), (float) (1.0f))),
					(nk_color) (color));
		}

		public static void nk_draw_list_add_text(nk_draw_list list, nk_user_font font, nk_rect rect, char* text, int len,
			float font_height, nk_color fg)
		{
			float x = (float) (0);
			int text_len = (int) (0);
			char unicode = (char) 0;
			char next = (char) (0);
			int glyph_len = (int) (0);
			int next_glyph_len = (int) (0);
			nk_user_font_glyph g = new nk_user_font_glyph();
			if (((list == null) || (len == 0)) || (text == null)) return;
			if (
				!(!(((((list.clip_rect.x) > (rect.x + rect.w)) || ((list.clip_rect.x + list.clip_rect.w) < (rect.x))) ||
				     ((list.clip_rect.y) > (rect.y + rect.h))) || ((list.clip_rect.y + list.clip_rect.h) < (rect.y))))) return;
			nk_draw_list_push_image(list, (nk_handle) (font.texture));
			x = (float) (rect.x);
			glyph_len = (int) (nk_utf_decode(text, &unicode, (int) (len)));
			if (glyph_len == 0) return;
			fg.a = ((byte) ((float) (fg.a)*list.config.global_alpha));
			while (((text_len) < (len)) && ((glyph_len) != 0))
			{
				float gx;
				float gy;
				float gh;
				float gw;
				float char_width = (float) (0);
				if ((unicode) == (0xFFFD)) break;
				next_glyph_len = (int) (nk_utf_decode(text + text_len + glyph_len, &next, (int) (len - text_len)));
				font.query((nk_handle) (font.userdata), (float) (font_height), &g, unicode, (next == 0xFFFD) ? '\0' : next);
				gx = (float) (x + g.offset.x);
				gy = (float) (rect.y + g.offset.y);
				gw = (float) (g.width);
				gh = (float) (g.height);
				char_width = (float) (g.xadvance);
				nk_draw_list_push_rect_uv(list, (nk_vec2) (nk_vec2_((float) (gx), (float) (gy))),
					(nk_vec2) (nk_vec2_((float) (gx + gw), (float) (gy + gh))), nk_vec2_(g.uv_x[0], g.uv_y[0]),
					nk_vec2_(g.uv_x[1], g.uv_y[1]), (nk_color) (fg));
				text_len += (int) (glyph_len);
				x += (float) (char_width);
				glyph_len = (int) (next_glyph_len);
				unicode = (char) (next);
			}
		}

		public static uint nk_convert(nk_context ctx, nk_buffer cmds, nk_buffer vertices, nk_buffer elements,
			nk_convert_config config)
		{
			uint res = (uint) (NK_CONVERT_SUCCESS);

			if ((((((ctx == null) || (cmds == null)) || (vertices == null)) || (elements == null)) || (config == null)) ||
			    (config.vertex_layout == null)) return (uint) (NK_CONVERT_INVALID_PARAM);
			nk_draw_list_setup(ctx.draw_list, config, cmds, vertices, elements, (int) (config.line_AA), (int) (config.shape_AA));
			var top_window = nk__begin(ctx);
			foreach (var cmd in top_window.buffer.commands)
			{
				ctx.draw_list.userdata = (nk_handle) (cmd.userdata);
				switch (cmd.header.type)
				{
					case NK_COMMAND_NOP:
						break;
					case NK_COMMAND_SCISSOR:
					{
						nk_command_scissor s = (nk_command_scissor) (cmd);
						nk_draw_list_add_clip(ctx.draw_list,
							(nk_rect) (nk_rect_((float) (s.x), (float) (s.y), (float) (s.w), (float) (s.h))));
					}
						break;
					case NK_COMMAND_LINE:
					{
						nk_command_line l = (nk_command_line) (cmd);
						nk_draw_list_stroke_line(ctx.draw_list, (nk_vec2) (nk_vec2_((float) (l.begin.x), (float) (l.begin.y))),
							(nk_vec2) (nk_vec2_((float) (l.end.x), (float) (l.end.y))), (nk_color) (l.color), (float) (l.line_thickness));
					}
						break;
					case NK_COMMAND_CURVE:
					{
						nk_command_curve q = (nk_command_curve) (cmd);
						nk_draw_list_stroke_curve(ctx.draw_list, (nk_vec2) (nk_vec2_((float) (q.begin.x), (float) (q.begin.y))),
							(nk_vec2) (nk_vec2_((float) (q.ctrl_0.x), (float) (q.ctrl_0.y))),
							(nk_vec2) (nk_vec2_((float) (q.ctrl_1.x), (float) (q.ctrl_1.y))),
							(nk_vec2) (nk_vec2_((float) (q.end.x), (float) (q.end.y))), (nk_color) (q.color),
							(uint) (config.curve_segment_count), (float) (q.line_thickness));
					}
						break;
					case NK_COMMAND_RECT:
					{
						nk_command_rect r = (nk_command_rect) (cmd);
						nk_draw_list_stroke_rect(ctx.draw_list,
							(nk_rect) (nk_rect_((float) (r.x), (float) (r.y), (float) (r.w), (float) (r.h))), (nk_color) (r.color),
							(float) (r.rounding), (float) (r.line_thickness));
					}
						break;
					case NK_COMMAND_RECT_FILLED:
					{
						nk_command_rect_filled r = (nk_command_rect_filled) (cmd);
						nk_draw_list_fill_rect(ctx.draw_list,
							(nk_rect) (nk_rect_((float) (r.x), (float) (r.y), (float) (r.w), (float) (r.h))), (nk_color) (r.color),
							(float) (r.rounding));
					}
						break;
					case NK_COMMAND_RECT_MULTI_COLOR:
					{
						nk_command_rect_multi_color r = (nk_command_rect_multi_color) (cmd);
						nk_draw_list_fill_rect_multi_color(ctx.draw_list,
							(nk_rect) (nk_rect_((float) (r.x), (float) (r.y), (float) (r.w), (float) (r.h))), (nk_color) (r.left),
							(nk_color) (r.top), (nk_color) (r.right), (nk_color) (r.bottom));
					}
						break;
					case NK_COMMAND_CIRCLE:
					{
						nk_command_circle c = (nk_command_circle) (cmd);
						nk_draw_list_stroke_circle(ctx.draw_list,
							(nk_vec2) (nk_vec2_((float) ((float) (c.x) + (float) (c.w)/2), (float) ((float) (c.y) + (float) (c.h)/2))),
							(float) ((float) (c.w)/2), (nk_color) (c.color), (uint) (config.circle_segment_count), (float) (c.line_thickness));
					}
						break;
					case NK_COMMAND_CIRCLE_FILLED:
					{
						nk_command_circle_filled c = (nk_command_circle_filled) (cmd);
						nk_draw_list_fill_circle(ctx.draw_list,
							(nk_vec2) (nk_vec2_((float) ((float) (c.x) + (float) (c.w)/2), (float) ((float) (c.y) + (float) (c.h)/2))),
							(float) ((float) (c.w)/2), (nk_color) (c.color), (uint) (config.circle_segment_count));
					}
						break;
					case NK_COMMAND_ARC:
					{
						nk_command_arc c = (nk_command_arc) (cmd);
						nk_draw_list_path_line_to(ctx.draw_list, (nk_vec2) (nk_vec2_((float) (c.cx), (float) (c.cy))));
						nk_draw_list_path_arc_to(ctx.draw_list, (nk_vec2) (nk_vec2_((float) (c.cx), (float) (c.cy))), (float) (c.r),
							(float) (c.a[0]), (float) (c.a[1]), (uint) (config.arc_segment_count));
						nk_draw_list_path_stroke(ctx.draw_list, (nk_color) (c.color), (int) (NK_STROKE_CLOSED), (float) (c.line_thickness));
					}
						break;
					case NK_COMMAND_ARC_FILLED:
					{
						nk_command_arc_filled c = (nk_command_arc_filled) (cmd);
						nk_draw_list_path_line_to(ctx.draw_list, (nk_vec2) (nk_vec2_((float) (c.cx), (float) (c.cy))));
						nk_draw_list_path_arc_to(ctx.draw_list, (nk_vec2) (nk_vec2_((float) (c.cx), (float) (c.cy))), (float) (c.r),
							(float) (c.a[0]), (float) (c.a[1]), (uint) (config.arc_segment_count));
						nk_draw_list_path_fill(ctx.draw_list, (nk_color) (c.color));
					}
						break;
					case NK_COMMAND_TRIANGLE:
					{
						nk_command_triangle t = (nk_command_triangle) (cmd);
						nk_draw_list_stroke_triangle(ctx.draw_list, (nk_vec2) (nk_vec2_((float) (t.a.x), (float) (t.a.y))),
							(nk_vec2) (nk_vec2_((float) (t.b.x), (float) (t.b.y))), (nk_vec2) (nk_vec2_((float) (t.c.x), (float) (t.c.y))),
							(nk_color) (t.color), (float) (t.line_thickness));
					}
						break;
					case NK_COMMAND_TRIANGLE_FILLED:
					{
						nk_command_triangle_filled t = (nk_command_triangle_filled) (cmd);
						nk_draw_list_fill_triangle(ctx.draw_list, (nk_vec2) (nk_vec2_((float) (t.a.x), (float) (t.a.y))),
							(nk_vec2) (nk_vec2_((float) (t.b.x), (float) (t.b.y))), (nk_vec2) (nk_vec2_((float) (t.c.x), (float) (t.c.y))),
							(nk_color) (t.color));
					}
						break;
					case NK_COMMAND_POLYGON:
					{
						int i;
						nk_command_polygon p = (nk_command_polygon) (cmd);
						for (i = (int) (0); (i) < (p.point_count); ++i)
						{
							nk_vec2 pnt = (nk_vec2) (nk_vec2_((float) (p.points[i].x), (float) (p.points[i].y)));
							nk_draw_list_path_line_to(ctx.draw_list, (nk_vec2) (pnt));
						}
						nk_draw_list_path_stroke(ctx.draw_list, (nk_color) (p.color), (int) (NK_STROKE_CLOSED), (float) (p.line_thickness));
					}
						break;
					case NK_COMMAND_POLYGON_FILLED:
					{
						int i;
						nk_command_polygon_filled p = (nk_command_polygon_filled) (cmd);
						for (i = (int) (0); (i) < (p.point_count); ++i)
						{
							nk_vec2 pnt = (nk_vec2) (nk_vec2_((float) (p.points[i].x), (float) (p.points[i].y)));
							nk_draw_list_path_line_to(ctx.draw_list, (nk_vec2) (pnt));
						}
						nk_draw_list_path_fill(ctx.draw_list, (nk_color) (p.color));
					}
						break;
					case NK_COMMAND_POLYLINE:
					{
						int i;
						nk_command_polyline p = (nk_command_polyline) (cmd);
						for (i = (int) (0); (i) < (p.point_count); ++i)
						{
							nk_vec2 pnt = (nk_vec2) (nk_vec2_((float) (p.points[i].x), (float) (p.points[i].y)));
							nk_draw_list_path_line_to(ctx.draw_list, (nk_vec2) (pnt));
						}
						nk_draw_list_path_stroke(ctx.draw_list, (nk_color) (p.color), (int) (NK_STROKE_OPEN), (float) (p.line_thickness));
					}
						break;
					case NK_COMMAND_TEXT:
					{
						nk_command_text t = (nk_command_text) (cmd);
						nk_draw_list_add_text(ctx.draw_list, t.font,
							(nk_rect) (nk_rect_((float) (t.x), (float) (t.y), (float) (t.w), (float) (t.h))), t._string_, (int) (t.length),
							(float) (t.height), (nk_color) (t.foreground));
					}
						break;
					case NK_COMMAND_IMAGE:
					{
						nk_command_image i = (nk_command_image) (cmd);
						nk_draw_list_add_image(ctx.draw_list, (nk_image) (i.img),
							(nk_rect) (nk_rect_((float) (i.x), (float) (i.y), (float) (i.w), (float) (i.h))), (nk_color) (i.col));
					}
						break;
					case NK_COMMAND_CUSTOM:
					{
						nk_command_custom c = (nk_command_custom) (cmd);
						c.callback(ctx.draw_list, (short) (c.x), (short) (c.y), (ushort) (c.w), (ushort) (c.h),
							(nk_handle) (c.callback_data));
					}
						break;
					default:
						break;
				}
			}
			res |=
				(uint) (((cmds.needed) > (cmds.allocated + (cmds.memory.size - cmds.size))) ? NK_CONVERT_COMMAND_BUFFER_FULL : 0);
			res |= (uint) (((vertices.needed) > (vertices.allocated)) ? NK_CONVERT_VERTEX_BUFFER_FULL : 0);
			res |= (uint) (((elements.needed) > (elements.allocated)) ? NK_CONVERT_ELEMENT_BUFFER_FULL : 0);
			return (uint) (res);
		}

		public static nk_draw_command* nk__draw_begin(nk_context ctx, nk_buffer buffer)
		{
			return nk__draw_list_begin(ctx.draw_list, buffer);
		}

		public static nk_draw_command* nk__draw_end(nk_context ctx, nk_buffer buffer)
		{
			return nk__draw_list_end(ctx.draw_list, buffer);
		}

		public static nk_draw_command* nk__draw_next(nk_draw_command* cmd, nk_buffer buffer, nk_context ctx)
		{
			return nk__draw_list_next(cmd, buffer, ctx.draw_list);
		}

		public static ushort nk_ttUSHORT(byte* p)
		{
			return (ushort) (p[0]*256 + p[1]);
		}

		public static short nk_ttSHORT(byte* p)
		{
			return (short) (p[0]*256 + p[1]);
		}

		public static uint nk_ttULONG(byte* p)
		{
			return (uint) ((p[0] << 24) + (p[1] << 16) + (p[2] << 8) + p[3]);
		}

		public static int stbtt__close_shape(nk_tt_vertex* vertices, int num_vertices, int was_off, int start_off, int sx,
			int sy, int scx, int scy, int cx, int cy)
		{
			if ((start_off) != 0)
			{
				if ((was_off) != 0)
					nk_tt_setvertex(&vertices[num_vertices++], (byte) (NK_TT_vcurve), (int) ((cx + scx) >> 1), (int) ((cy + scy) >> 1),
						(int) (cx), (int) (cy));
				nk_tt_setvertex(&vertices[num_vertices++], (byte) (NK_TT_vcurve), (int) (sx), (int) (sy), (int) (scx), (int) (scy));
			}
			else
			{
				if ((was_off) != 0)
					nk_tt_setvertex(&vertices[num_vertices++], (byte) (NK_TT_vcurve), (int) (sx), (int) (sy), (int) (cx), (int) (cy));
				else nk_tt_setvertex(&vertices[num_vertices++], (byte) (NK_TT_vline), (int) (sx), (int) (sy), (int) (0), (int) (0));
			}

			return (int) (num_vertices);
		}

		public static int nk_range_count(uint* range)
		{
			uint* iter = range;
			if (range == null) return (int) (0);
			while (*(iter++) != 0)
			{
			}
			return (int) (((iter) == (range)) ? 0 : (int) ((iter - range)/2));
		}

		public static int nk_range_glyph_count(uint* range, int count)
		{
			int i = (int) (0);
			int total_glyphs = (int) (0);
			for (i = (int) (0); (i) < (count); ++i)
			{
				int diff;
				uint f = (uint) (range[(i*2) + 0]);
				uint t = (uint) (range[(i*2) + 1]);
				diff = ((int) ((t - f) + 1));
				total_glyphs += (int) (diff);
			}
			return (int) (total_glyphs);
		}

		public static uint* nk_font_default_glyph_ranges()
		{
			return default_ranges;
		}

		public static uint* nk_font_chinese_glyph_ranges()
		{
			return chinese_ranges;
		}

		public static uint* nk_font_cyrillic_glyph_ranges()
		{
			return cyrillic_ranges;
		}

		public static uint* nk_font_korean_glyph_ranges()
		{
			return korean_ranges;
		}

		public static float nk_font_text_width(nk_font font, float height, char* text, int len)
		{
			char unicode;
			int text_len = (int) (0);
			float text_width = (float) (0);
			int glyph_len = (int) (0);
			float scale = (float) (0);

			if (((font == null) || (text == null)) || (len == 0)) return (float) (0);
			scale = (float) (height/font.info.height);
			glyph_len = (int) (text_len = (int) (nk_utf_decode(text, &unicode, (int) (len))));
			if (glyph_len == 0) return (float) (0);
			while ((text_len <= len) && ((glyph_len) != 0))
			{
				nk_font_glyph* g;
				if ((unicode) == (0xFFFD)) break;
				g = nk_font_find_glyph(font, unicode);
				text_width += (float) (g->xadvance*scale);
				glyph_len = (int) (nk_utf_decode(text + text_len, &unicode, (int) (len - text_len)));
				text_len += (int) (glyph_len);
			}
			return (float) (text_width);
		}

		public static void nk_font_query_font_glyph(nk_font font, float height, nk_user_font_glyph* glyph, char codepoint,
			char next_codepoint)
		{
			float scale;
			nk_font_glyph* g;


			if ((font == null) || (glyph == null)) return;
			scale = (float) (height/font.info.height);
			g = nk_font_find_glyph(font, codepoint);
			glyph->width = (float) ((g->x1 - g->x0)*scale);
			glyph->height = (float) ((g->y1 - g->y0)*scale);
			glyph->offset = (nk_vec2) (nk_vec2_((float) (g->x0*scale), (float) (g->y0*scale)));
			glyph->xadvance = (float) (g->xadvance*scale);
			glyph->uv_x[0] = g->u0;
			glyph->uv_y[0] = g->v0;
			glyph->uv_x[1] = g->u1;
			glyph->uv_y[1] = g->v1;
		}

		public static nk_font_glyph* nk_font_find_glyph(nk_font font, char unicode)
		{
			int i = (int) (0);
			int count;
			int total_glyphs = (int) (0);
			nk_font_glyph* glyph = null;
			nk_font_config iter = null;
			if ((font == null) || (font.glyphs == null)) return null;
			glyph = font.fallback;
			iter = font.config;
			do
			{
				count = (int) (nk_range_count(iter.range));
				for (i = (int) (0); (i) < (count); ++i)
				{
					uint f = (uint) (iter.range[(i*2) + 0]);
					uint t = (uint) (iter.range[(i*2) + 1]);
					int diff = (int) ((t - f) + 1);
					if (((unicode) >= (f)) && (unicode <= t))
						return (nk_font_glyph*) font.glyphs + ((uint) (total_glyphs) + (unicode - f));
					total_glyphs += (int) (diff);
				}
			} while ((iter = iter.n) != font.config);
			return glyph;
		}

		public static void nk_font_init(nk_font font, float pixel_height, char fallback_codepoint, nk_font_glyph* glyphs,
			nk_baked_font baked_font, nk_handle atlas)
		{
			nk_baked_font baked = new nk_baked_font();
			if (((font == null) || (glyphs == null)) || (baked_font == null)) return;
			baked = (nk_baked_font) (baked_font);
			font.fallback = null;
			font.info = (nk_baked_font) (baked);
			font.scale = (float) (pixel_height/font.info.height);
			font.glyphs = &glyphs[baked_font.glyph_offset];
			font.texture = (nk_handle) (atlas);
			font.fallback_codepoint = fallback_codepoint;
			font.fallback = nk_font_find_glyph(font, fallback_codepoint);
			font.handle.height = (float) (font.info.height*font.scale);
			font.handle.width = font.text_width;

			font.handle.query = font.query_font_glyph;
			font.handle.texture = (nk_handle) (font.texture);
		}

		public static uint nk_decompress_length(byte* input)
		{
			return (uint) ((input[8] << 24) + (input[9] << 16) + (input[10] << 8) + input[11]);
		}

		public static void nk__match(byte* data, uint length)
		{
			if ((nk__dout + length) > (nk__barrier))
			{
				nk__dout += length;
				return;
			}

			if ((data) < (nk__barrier4))
			{
				nk__dout = nk__barrier + 1;
				return;
			}

			while ((length--) != 0)
			{
				*nk__dout++ = (byte) (*data++);
			}
		}

		public static void nk__lit(byte* data, uint length)
		{
			if ((nk__dout + length) > (nk__barrier))
			{
				nk__dout += length;
				return;
			}

			if ((data) < (nk__barrier2))
			{
				nk__dout = nk__barrier + 1;
				return;
			}

			nk_memcopy(nk__dout, data, (ulong) (length));
			nk__dout += length;
		}

		public static byte* nk_decompress_token(byte* i)
		{
			if ((*i) >= (0x20))
			{
				if ((*i) >= (0x80))
				{
					nk__match(nk__dout - i[1] - 1, (uint) ((uint) (i[0]) - 0x80 + 1));
					i += 2;
				}
				else if ((*i) >= (0x40))
				{
					nk__match(nk__dout - (((i[0] << 8) + i[(0) + 1]) - 0x4000 + 1), (uint) ((uint) (i[2]) + 1));
					i += 3;
				}
				else
				{
					nk__lit(i + 1, (uint) ((uint) (i[0]) - 0x20 + 1));
					i += 1 + (i[0] - 0x20 + 1);
				}
			}
			else
			{
				if ((*i) >= (0x18))
				{
					nk__match(nk__dout - (uint) (((i[0] << 16) + ((i[(0) + 1] << 8) + i[((0) + 1) + 1])) - 0x180000 + 1),
						(uint) ((uint) (i[3]) + 1));
					i += 4;
				}
				else if ((*i) >= (0x10))
				{
					nk__match(nk__dout - (uint) (((i[0] << 16) + ((i[(0) + 1] << 8) + i[((0) + 1) + 1])) - 0x100000 + 1),
						(uint) ((uint) ((i[3] << 8) + i[(3) + 1]) + 1));
					i += 5;
				}
				else if ((*i) >= (0x08))
				{
					nk__lit(i + 2, (uint) ((uint) ((i[0] << 8) + i[(0) + 1]) - 0x0800 + 1));
					i += 2 + (((i[0] << 8) + i[(0) + 1]) - 0x0800 + 1);
				}
				else if ((*i) == (0x07))
				{
					nk__lit(i + 3, (uint) ((uint) ((i[1] << 8) + i[(1) + 1]) + 1));
					i += 3 + (((i[1] << 8) + i[(1) + 1]) + 1);
				}
				else if ((*i) == (0x06))
				{
					nk__match(nk__dout - (uint) (((i[1] << 16) + ((i[(1) + 1] << 8) + i[((1) + 1) + 1])) + 1), (uint) (i[4] + 1u));
					i += 5;
				}
				else if ((*i) == (0x04))
				{
					nk__match(nk__dout - (uint) (((i[1] << 16) + ((i[(1) + 1] << 8) + i[((1) + 1) + 1])) + 1),
						(uint) ((uint) ((i[4] << 8) + i[(4) + 1]) + 1u));
					i += 6;
				}
			}

			return i;
		}

		public static uint nk_adler32(uint adler32, byte* buffer, uint buflen)
		{
			int ADLER_MOD = (int) (65521);
			int s1 = (int) (adler32 & 0xffff);
			int s2 = (int) (adler32 >> 16);
			int blocklen;
			int i;
			blocklen = (int) (buflen%5552);
			while ((buflen) != 0)
			{
				for (i = (int) (0); (i + 7) < (blocklen); i += (int) (8))
				{
					s1 += (int) (buffer[0]);
					s2 += (int) (s1);
					s1 += (int) (buffer[1]);
					s2 += (int) (s1);
					s1 += (int) (buffer[2]);
					s2 += (int) (s1);
					s1 += (int) (buffer[3]);
					s2 += (int) (s1);
					s1 += (int) (buffer[4]);
					s2 += (int) (s1);
					s1 += (int) (buffer[5]);
					s2 += (int) (s1);
					s1 += (int) (buffer[6]);
					s2 += (int) (s1);
					s1 += (int) (buffer[7]);
					s2 += (int) (s1);
					buffer += 8;
				}
				for (; (i) < (blocklen); ++i)
				{
					s1 += (int) (*buffer++);
					s2 += (int) (s1);
				}
				s1 %= (int) (ADLER_MOD);
				s2 %= (int) (ADLER_MOD);
				buflen -= ((uint) (blocklen));
				blocklen = (int) (5552);
			}
			return (uint) ((uint) (s2 << 16) + (uint) (s1));
		}

		public static uint nk_decompress(byte* output, byte* i, uint length)
		{
			uint olen;
			if (((i[0] << 24) + ((i[(0) + 1] << 16) + ((i[((0) + 1) + 1] << 8) + i[(((0) + 1) + 1) + 1]))) != 0x57bC0000)
				return (uint) (0);
			if (((i[4] << 24) + ((i[(4) + 1] << 16) + ((i[((4) + 1) + 1] << 8) + i[(((4) + 1) + 1) + 1]))) != 0)
				return (uint) (0);
			olen = (uint) (nk_decompress_length(i));
			nk__barrier2 = i;
			nk__barrier3 = i + length;
			nk__barrier = output + olen;
			nk__barrier4 = output;
			i += 16;
			nk__dout = output;
			for (;;)
			{
				byte* old_i = i;
				i = nk_decompress_token(i);
				if ((i) == (old_i))
				{
					if (((*i) == (0x05)) && ((i[1]) == (0xfa)))
					{
						if (nk__dout != output + olen) return (uint) (0);
						if (nk_adler32((uint) (1), output, (uint) (olen)) !=
						    (uint) ((i[2] << 24) + ((i[(2) + 1] << 16) + ((i[((2) + 1) + 1] << 8) + i[(((2) + 1) + 1) + 1]))))
							return (uint) (0);
						return (uint) (olen);
					}
					else
					{
						return (uint) (0);
					}
				}
				if ((nk__dout) > (output + olen)) return (uint) (0);
			}
		}

		public static uint nk_decode_85_byte(sbyte c)
		{
			return (uint) (((c) >= ('\\')) ? c - 36 : c - 35);
		}

		public static void nk_decode_85(byte* dst, byte* src)
		{
			while ((*src) != 0)
			{
				uint tmp =
					(uint)
						(nk_decode_85_byte((sbyte) (src[0])) +
						 85*
						 (nk_decode_85_byte((sbyte) (src[1])) +
						  85*
						  (nk_decode_85_byte((sbyte) (src[2])) +
						   85*(nk_decode_85_byte((sbyte) (src[3])) + 85*nk_decode_85_byte((sbyte) (src[4]))))));
				dst[0] = ((byte) ((tmp >> 0) & 0xFF));
				dst[1] = ((byte) ((tmp >> 8) & 0xFF));
				dst[2] = ((byte) ((tmp >> 16) & 0xFF));
				dst[3] = ((byte) ((tmp >> 24) & 0xFF));
				src += 5;
				dst += 4;
			}
		}

		public static nk_font_config nk_font_config_(float pixel_height)
		{
			nk_font_config cfg = new nk_font_config();

			cfg.ttf_blob = null;
			cfg.ttf_size = (ulong) (0);
			cfg.ttf_data_owned_by_atlas = (byte) (0);
			cfg.size = (float) (pixel_height);
			cfg.oversample_h = (byte) (3);
			cfg.oversample_v = (byte) (1);
			cfg.pixel_snap = (byte) (0);
			cfg.coord_type = (int) (NK_COORD_UV);
			cfg.spacing = (nk_vec2) (nk_vec2_((float) (0), (float) (0)));
			cfg.range = nk_font_default_glyph_ranges();
			cfg.merge_mode = (byte) (0);
			cfg.fallback_glyph = '?';
			cfg.font = null;
			cfg.n = null;
			return (nk_font_config) (cfg);
		}

		public static void nk_font_atlas_begin(nk_font_atlas atlas)
		{
			if (((((atlas == null))))) return;
			if ((atlas.glyphs) != null)
			{
				CRuntime.free(atlas.glyphs);
				atlas.glyphs = null;
			}

			if ((atlas.pixel) != null)
			{
				CRuntime.free(atlas.pixel);
				atlas.pixel = null;
			}

		}

		public static nk_font nk_font_atlas_add(nk_font_atlas atlas, nk_font_config config)
		{
			nk_font font = null;
			nk_font_config cfg;
			if (((((((((atlas == null) || (config == null)) || (config.ttf_blob == null)) || (config.ttf_size == 0)) ||
			        (config.size <= 0.0f)))))) return null;

			cfg = nk_font_config_clone(config);
			cfg.n = cfg;
			cfg.p = cfg;
			if (config.merge_mode == 0)
			{
				if (atlas.config == null)
				{
					atlas.config = cfg;
					cfg.next = null;
				}
				else
				{
					nk_font_config i = atlas.config;
					while ((i.next) != null)
					{
						i = i.next;
					}
					i.next = cfg;
					cfg.next = null;
				}
				font = new nk_font();
				font.config = cfg;
				if (atlas.fonts == null)
				{
					atlas.fonts = font;
					font.next = null;
				}
				else
				{
					nk_font i = atlas.fonts;
					while ((i.next) != null)
					{
						i = i.next;
					}
					i.next = font;
					font.next = null;
				}
				cfg.font = font.info;
			}
			else
			{
				nk_font f = null;
				nk_font_config c = null;
				f = atlas.fonts;
				c = f.config;
				cfg.font = f.info;
				cfg.n = c;
				cfg.p = c.p;
				c.p.n = cfg;
				c.p = cfg;
			}

			if (config.ttf_data_owned_by_atlas == 0)
			{
				cfg.ttf_blob = CRuntime.malloc((ulong) (cfg.ttf_size));
				if (cfg.ttf_blob == null)
				{
					atlas.font_num++;
					return null;
				}
				nk_memcopy(cfg.ttf_blob, config.ttf_blob, (ulong) (cfg.ttf_size));
				cfg.ttf_data_owned_by_atlas = (byte) (1);
			}

			atlas.font_num++;
			return font;
		}

		public static nk_font nk_font_atlas_add_from_memory(nk_font_atlas atlas, void* memory, ulong size, float height,
			nk_font_config config)
		{
			nk_font_config cfg = new nk_font_config();
			if (((((((atlas == null))) || (memory == null)) || (size == 0)))) return null;
			cfg = (nk_font_config) ((config != null) ? config : nk_font_config_((float) (height)));
			cfg.ttf_blob = memory;
			cfg.ttf_size = (ulong) (size);
			cfg.size = (float) (height);
			cfg.ttf_data_owned_by_atlas = (byte) (0);
			return nk_font_atlas_add(atlas, cfg);
		}

		public static nk_font nk_font_atlas_add_compressed(nk_font_atlas atlas, void* compressed_data, ulong compressed_size,
			float height, nk_font_config config)
		{
			uint decompressed_size;
			void* decompressed_data;
			nk_font_config cfg = new nk_font_config();
			if ((((((atlas == null) || (compressed_data == null)))))) return null;
			decompressed_size = (uint) (nk_decompress_length((byte*) (compressed_data)));
			decompressed_data = CRuntime.malloc((ulong) (decompressed_size));
			if (decompressed_data == null) return null;
			nk_decompress((byte*) (decompressed_data), (byte*) (compressed_data), (uint) (compressed_size));
			cfg = (nk_font_config) ((config != null) ? config : nk_font_config_((float) (height)));
			cfg.ttf_blob = decompressed_data;
			cfg.ttf_size = (ulong) (decompressed_size);
			cfg.size = (float) (height);
			cfg.ttf_data_owned_by_atlas = (byte) (1);
			return nk_font_atlas_add(atlas, cfg);
		}

		public static nk_font nk_font_atlas_add_compressed_base85(nk_font_atlas atlas, byte* data_base85, float height,
			nk_font_config config)
		{
			int compressed_size;
			void* compressed_data;
			if ((((((atlas == null) || (data_base85 == null)))))) return null;
			compressed_size = (int) (((nk_strlen(data_base85) + 4)/5)*4);
			compressed_data = CRuntime.malloc((ulong) (compressed_size));
			if (compressed_data == null) return null;
			nk_decode_85((byte*) (compressed_data), (byte*) (data_base85));
			nk_font font = nk_font_atlas_add_compressed(atlas, compressed_data, (ulong) (compressed_size), (float) (height),
				config);
			CRuntime.free(compressed_data);
			return font;
		}

		public static void* nk_font_atlas_bake(nk_font_atlas atlas, ref int width, ref int height, int fmt)
		{
			int i = (int) (0);
			void* tmp = null;
			ulong tmp_size;
			ulong img_size;
			nk_font font_iter;
			nk_font_baker* baker;
			if (((((((atlas == null) || (width == null)) || (height == null)))))) return null;
			if (atlas.font_num == 0) atlas.default_font = nk_font_atlas_add_default(atlas, (float) (13.0f), null);
			if (atlas.font_num == 0) return null;
			nk_font_baker_memory(&tmp_size, ref atlas.glyph_count, atlas.config, (int) (atlas.font_num));
			tmp = CRuntime.malloc((ulong) (tmp_size));
			if (tmp == null) goto failed;
			baker = nk_font_baker_(tmp, (int) (atlas.glyph_count), (int) (atlas.font_num));
			atlas.glyphs =
				(nk_font_glyph*) (CRuntime.malloc((ulong) ((ulong) sizeof (nk_font_glyph)*(ulong) (atlas.glyph_count))));
			if (atlas.glyphs == null) goto failed;
			atlas.custom.w = (short) ((90*2) + 1);
			atlas.custom.h = (short) (27 + 1);
			if (
				nk_font_bake_pack(baker, &img_size, ref width, ref height, ref atlas.custom, atlas.config, (int) (atlas.font_num)) ==
				0) goto failed;
			atlas.pixel = CRuntime.malloc((ulong) (img_size));
			if (atlas.pixel == null) goto failed;
			nk_font_bake(baker, atlas.pixel, (int) (width), (int) (height), atlas.glyphs, (int) (atlas.glyph_count), atlas.config,
				(int) (atlas.font_num));
			fixed (byte* ptr = nk_custom_cursor_data)
			{
				nk_font_bake_custom_data(atlas.pixel, (int) (width), (int) (height), (nk_recti) (atlas.custom), ptr, (int) (90),
					(int) (27), ('.'), ('X'));
			}
			if ((fmt) == (NK_FONT_ATLAS_RGBA32))
			{
				void* img_rgba = CRuntime.malloc((ulong) (width*height*4));
				if (img_rgba == null) goto failed;
				nk_font_bake_convert(img_rgba, (int) (width), (int) (height), atlas.pixel);
				CRuntime.free(atlas.pixel);
				atlas.pixel = img_rgba;
			}

			atlas.tex_width = (int) (width);
			atlas.tex_height = (int) (height);
			for (font_iter = atlas.fonts; font_iter != null; font_iter = font_iter.next)
			{
				nk_font font = font_iter;
				nk_font_config config = font.config;
				nk_font_init(font, (float) (config.size), config.fallback_glyph, atlas.glyphs, config.font,
					(nk_handle) (nk_handle_ptr(null)));
			}
			for (i = (int) (0); (i) < (NK_CURSOR_COUNT); ++i)
			{
				nk_cursor cursor = atlas.cursors[i];
				cursor.img.w = ((ushort) (width));
				cursor.img.h = ((ushort) (height));
				cursor.img.region[0] = ((ushort) (atlas.custom.x + nk_cursor_data[i, 0].x));
				cursor.img.region[1] = ((ushort) (atlas.custom.y + nk_cursor_data[i, 0].y));
				cursor.img.region[2] = ((ushort) (nk_cursor_data[i, 1].x));
				cursor.img.region[3] = ((ushort) (nk_cursor_data[i, 1].y));
				cursor.size = (nk_vec2) (nk_cursor_data[i, 1]);
				cursor.offset = (nk_vec2) (nk_cursor_data[i, 2]);
			}
			CRuntime.free(tmp);
			return atlas.pixel;
			failed:
			;
			if ((tmp) != null) CRuntime.free(tmp);
			if ((atlas.glyphs) != null)
			{
				CRuntime.free(atlas.glyphs);
				atlas.glyphs = null;
			}

			if ((atlas.pixel) != null)
			{
				CRuntime.free(atlas.pixel);
				atlas.pixel = null;
			}

			return null;
		}

		public static void nk_font_atlas_end(nk_font_atlas atlas, nk_handle texture, nk_draw_null_texture* _null_)
		{
			int i = (int) (0);
			nk_font font_iter;
			if (atlas == null)
			{
				if (_null_ == null) return;
				_null_->texture = (nk_handle) (texture);
				_null_->uv = (nk_vec2) (nk_vec2_((float) (0.5f), (float) (0.5f)));
			}

			if ((_null_) != null)
			{
				_null_->texture = (nk_handle) (texture);
				_null_->uv.x = (float) ((atlas.custom.x + 0.5f)/(float) (atlas.tex_width));
				_null_->uv.y = (float) ((atlas.custom.y + 0.5f)/(float) (atlas.tex_height));
			}

			for (font_iter = atlas.fonts; font_iter != null; font_iter = font_iter.next)
			{
				font_iter.texture = (nk_handle) (texture);
				font_iter.handle.texture = (nk_handle) (texture);
			}
			for (i = (int) (0); (i) < (NK_CURSOR_COUNT); ++i)
			{
				atlas.cursors[i].img.handle = (nk_handle) (texture);
			}
			CRuntime.free(atlas.pixel);
			atlas.pixel = null;
			atlas.tex_width = (int) (0);
			atlas.tex_height = (int) (0);
			atlas.custom.x = (short) (0);
			atlas.custom.y = (short) (0);
			atlas.custom.w = (short) (0);
			atlas.custom.h = (short) (0);
		}

		public static void nk_font_atlas_cleanup(nk_font_atlas atlas)
		{
			if (((atlas == null))) return;
			if ((atlas.config) != null)
			{
				nk_font_config iter;
				for (iter = atlas.config; iter != null; iter = iter.next)
				{
					nk_font_config i;
					for (i = iter.n; i != iter; i = i.n)
					{
						CRuntime.free(i.ttf_blob);
						i.ttf_blob = null;
					}
					CRuntime.free(iter.ttf_blob);
					iter.ttf_blob = null;
				}
			}

		}

		public static void nk_font_atlas_clear(nk_font_atlas atlas)
		{
			if (((atlas == null))) return;
			if ((atlas.config) != null)
			{
				nk_font_config iter;
				nk_font_config next;
				for (iter = atlas.config; iter != null; iter = next)
				{
					nk_font_config i;
					nk_font_config n;
					for (i = iter.n; i != iter; i = n)
					{
						n = i.n;
						if ((i.ttf_blob) != null) CRuntime.free(i.ttf_blob);
					}
					next = iter.next;
					if ((i.ttf_blob) != null) CRuntime.free(iter.ttf_blob);
				}
				atlas.config = null;
			}

			if ((atlas.fonts) != null)
			{
				nk_font iter;
				nk_font next;
				for (iter = atlas.fonts; iter != null; iter = next)
				{
					next = iter.next;
				}
				atlas.fonts = null;
			}

			if ((atlas.glyphs) != null) CRuntime.free(atlas.glyphs);

		}

		public static int nk_is_word_boundary(nk_text_edit state, int idx)
		{
			int len = 0;
			char c;
			if (idx <= 0) return (int) (1);
			if (nk_str_at_rune(state._string_, (int) (idx), &c, ref len) == null) return (int) (1);
			return
				(int)
					((((((((((((c) == (' ')) || ((c) == ('	'))) || ((c) == (0x3000))) || ((c) == (','))) || ((c) == (';'))) ||
					      ((c) == ('('))) || ((c) == (')')) || ((c) == ('{'))) || ((c) == ('}'))) || ((c) == ('['))) || ((c) == (']'))) ||
					 ((c) == ('|'))
						? 1
						: 0);
		}

		public static void nk_draw_symbol(nk_command_buffer _out_, int type, nk_rect content, nk_color background,
			nk_color foreground, float border_width, nk_user_font font)
		{
			switch (type)
			{
				case NK_SYMBOL_X:
				case NK_SYMBOL_UNDERSCORE:
				case NK_SYMBOL_PLUS:
				case NK_SYMBOL_MINUS:
				{
					char X = ((type) == (NK_SYMBOL_X))
						? 'x'
						: ((type) == (NK_SYMBOL_UNDERSCORE)) ? '_' : ((type) == (NK_SYMBOL_PLUS)) ? '+' : '-';
					nk_text text = new nk_text();
					text.padding = (nk_vec2) (nk_vec2_((float) (0), (float) (0)));
					text.background = (nk_color) (background);
					text.text = (nk_color) (foreground);
					nk_widget_text(_out_, (nk_rect) (content), &X, (int) (1), &text, (uint) (NK_TEXT_CENTERED), font);
				}
					break;
				case NK_SYMBOL_CIRCLE_SOLID:
				case NK_SYMBOL_CIRCLE_OUTLINE:
				case NK_SYMBOL_RECT_SOLID:
				case NK_SYMBOL_RECT_OUTLINE:
				{
					if (((type) == (NK_SYMBOL_RECT_SOLID)) || ((type) == (NK_SYMBOL_RECT_OUTLINE)))
					{
						nk_fill_rect(_out_, (nk_rect) (content), (float) (0), (nk_color) (foreground));
						if ((type) == (NK_SYMBOL_RECT_OUTLINE))
							nk_fill_rect(_out_, (nk_rect) (nk_shrink_rect_((nk_rect) (content), (float) (border_width))), (float) (0),
								(nk_color) (background));
					}
					else
					{
						nk_fill_circle(_out_, (nk_rect) (content), (nk_color) (foreground));
						if ((type) == (NK_SYMBOL_CIRCLE_OUTLINE))
							nk_fill_circle(_out_, (nk_rect) (nk_shrink_rect_((nk_rect) (content), (float) (1))), (nk_color) (background));
					}
				}
					break;
				case NK_SYMBOL_TRIANGLE_UP:
				case NK_SYMBOL_TRIANGLE_DOWN:
				case NK_SYMBOL_TRIANGLE_LEFT:
				case NK_SYMBOL_TRIANGLE_RIGHT:
				{
					int heading;
					nk_vec2* points = stackalloc nk_vec2[3];
					heading =
						(int)
							(((type) == (NK_SYMBOL_TRIANGLE_RIGHT))
								? NK_RIGHT
								: ((type) == (NK_SYMBOL_TRIANGLE_LEFT)) ? NK_LEFT : ((type) == (NK_SYMBOL_TRIANGLE_UP)) ? NK_UP : NK_DOWN);
					nk_triangle_from_direction(points, (nk_rect) (content), (float) (0), (float) (0), (int) (heading));
					nk_fill_triangle(_out_, (float) (points[0].x), (float) (points[0].y), (float) (points[1].x), (float) (points[1].y),
						(float) (points[2].x), (float) (points[2].y), (nk_color) (foreground));
				}
					break;
				default:
				case NK_SYMBOL_NONE:
				case NK_SYMBOL_MAX:
					break;
			}

		}

		public static void nk_setup(nk_context ctx, nk_user_font font)
		{
			if (ctx == null) return;

			nk_style_default(ctx);
			ctx.seq = (uint) (1);
			if ((font) != null) ctx.style.font = font;
			nk_draw_list_init(ctx.draw_list);
		}

		public static void nk_set_user_data(nk_context ctx, nk_handle handle)
		{
			if (ctx == null) return;
			ctx.userdata = (nk_handle) (handle);
			if ((ctx.current) != null) ctx.current.buffer.userdata = (nk_handle) (handle);
		}

		public static void nk_clear(nk_context ctx)
		{
			nk_window iter;
			nk_window next;
			if (ctx == null) return;
			nk_buffer_reset(ctx.memory, (int) (NK_BUFFER_FRONT));
			ctx.build = (int) (0);
			ctx.memory.calls = (ulong) (0);
			ctx.last_widget_state = (uint) (0);
			ctx.style.cursor_active = ctx.style.cursors[NK_CURSOR_ARROW];

			nk_draw_list_clear(ctx.draw_list);
			iter = ctx.begin;
			while ((iter) != null)
			{
				if ((((iter.flags & NK_WINDOW_MINIMIZED) != 0) && ((iter.flags & NK_WINDOW_CLOSED) == 0)) &&
				    ((iter.seq) == (ctx.seq)))
				{
					iter = iter.next;
					continue;
				}
				if ((((iter.flags & NK_WINDOW_HIDDEN) != 0) || ((iter.flags & NK_WINDOW_CLOSED) != 0)) && ((iter) == (ctx.active)))
				{
					ctx.active = iter.prev;
					ctx.end = iter.prev;
					if ((ctx.active) != null) ctx.active.flags &= (uint) (~(uint) (NK_WINDOW_ROM));
				}
				if (((iter.popup.win) != null) && (iter.popup.win.seq != ctx.seq))
				{
					nk_free_window(ctx, iter.popup.win);
					iter.popup.win = null;
				}
				{
					nk_table n;
					nk_table it = iter.tables;
					while ((it) != null)
					{
						n = it.next;
						if (it.seq != ctx.seq)
						{
							nk_remove_table(iter, it);
							if ((it) == (iter.tables)) iter.tables = n;
						}
						it = n;
					}
				}
				if ((iter.seq != ctx.seq) || ((iter.flags & NK_WINDOW_CLOSED) != 0))
				{
					next = iter.next;
					nk_remove_window(ctx, iter);
					nk_free_window(ctx, iter);
					iter = next;
				}
				else iter = iter.next;
			}
			ctx.seq++;
		}

		public static void nk_start_buffer(nk_context ctx, nk_command_buffer buffer)
		{
			if ((ctx == null) || (buffer == null)) return;
			buffer.clip = (nk_rect) (nk_null_rect);
			buffer.commands.Clear();
		}

		public static void nk_start(nk_context ctx, nk_window win)
		{
			nk_start_buffer(ctx, win.buffer);
		}

		public static void nk_finish_buffer(nk_context ctx, nk_command_buffer buffer)
		{
			if ((ctx == null) || (buffer == null)) return;
		}

		public static void nk_finish(nk_context ctx, nk_window win)
		{
			nk_popup_buffer buf;
			if ((ctx == null) || (win == null)) return;
			nk_finish_buffer(ctx, win.buffer);
			if (win.popup.buf.active == 0) return;
			buf = win.popup.buf;

//			buf.parent [buf.parent.Count - 1].next = buf.commands [0];
		}
	}
}