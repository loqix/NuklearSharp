// Generated by Sichem at 2/7/2018 6:09:30 PM

using System;
using System.Runtime.InteropServices;

namespace NuklearSharp
{
	public unsafe partial class Input
	{
		public Keyboard keyboard = new Keyboard();
		public Mouse mouse = new Mouse();

		public int HasMouseClick(int id)
		{
			MouseButton* btn;
			if (this == null) return (int) (Nuklear.nk_false);
			btn = (MouseButton*) this.mouse.buttons + id;
			return (int) ((((btn->clicked) != 0) && ((btn->down) == (Nuklear.nk_false))) ? Nuklear.nk_true : Nuklear.nk_false);
		}

		public int HasMouseClickInRect(int id, Rect b)
		{
			MouseButton* btn;
			if (this == null) return (int) (Nuklear.nk_false);
			btn = (MouseButton*) this.mouse.buttons + id;
			if (
				!((((b.x) <= (btn->clicked_pos.x)) && ((btn->clicked_pos.x) < (b.x + b.w))) &&
				  (((b.y) <= (btn->clicked_pos.y)) && ((btn->clicked_pos.y) < (b.y + b.h))))) return (int) (Nuklear.nk_false);
			return (int) (Nuklear.nk_true);
		}

		public int HasMouseClickDownInRect(int id, Rect b, int down)
		{
			MouseButton* btn;
			if (this == null) return (int) (Nuklear.nk_false);
			btn = (MouseButton*) this.mouse.buttons + id;
			return (int) (((HasMouseClickInRect((int) (id), (Rect) (b))) != 0) && ((btn->down) == (down)) ? 1 : 0);
		}

		public int IsMouseClickInRect(int id, Rect b)
		{
			MouseButton* btn;
			if (this == null) return (int) (Nuklear.nk_false);
			btn = (MouseButton*) this.mouse.buttons + id;
			return
				(int)
					((((HasMouseClickDownInRect((int) (id), (Rect) (b), (int) (Nuklear.nk_false))) != 0) && ((btn->clicked) != 0))
						? Nuklear.nk_true
						: Nuklear.nk_false);
		}

		public int IsMouseClickDownInRect(int id, Rect b, int down)
		{
			MouseButton* btn;
			if (this == null) return (int) (Nuklear.nk_false);
			btn = (MouseButton*) this.mouse.buttons + id;
			return
				(int)
					((((HasMouseClickDownInRect((int) (id), (Rect) (b), (int) (down))) != 0) && ((btn->clicked) != 0))
						? Nuklear.nk_true
						: Nuklear.nk_false);
		}

		public int AnyMouseClickInRect(Rect b)
		{
			int i;
			int down = (int) (0);
			for (i = (int) (0); (i) < (Nuklear.NK_BUTTON_MAX); ++i)
			{
				down = (int) (((down) != 0) || ((IsMouseClickInRect((int) (i), (Rect) (b))) != 0) ? 1 : 0);
			}
			return (int) (down);
		}

		public int IsMouseHoveringRect(Rect rect)
		{
			if (this == null) return (int) (Nuklear.nk_false);
			return ((((rect.x) <= (this.mouse.pos.x)) && ((this.mouse.pos.x) < (rect.x + rect.w))) &&
			        (((rect.y) <= (this.mouse.pos.y)) && ((this.mouse.pos.y) < (rect.y + rect.h))))
				? 1
				: 0;
		}

		public int IsMousePrevHoveringRect(Rect rect)
		{
			if (this == null) return (int) (Nuklear.nk_false);
			return ((((rect.x) <= (this.mouse.prev.x)) && ((this.mouse.prev.x) < (rect.x + rect.w))) &&
			        (((rect.y) <= (this.mouse.prev.y)) && ((this.mouse.prev.y) < (rect.y + rect.h))))
				? 1
				: 0;
		}

		public int MouseClicked(int id, Rect rect)
		{
			if (this == null) return (int) (Nuklear.nk_false);
			if (IsMouseHoveringRect((Rect) (rect)) == 0) return (int) (Nuklear.nk_false);
			return (int) (IsMouseClickInRect((int) (id), (Rect) (rect)));
		}

		public int IsMouseDown(int id)
		{
			if (this == null) return (int) (Nuklear.nk_false);
			return (int) (this.mouse.buttons[id].down);
		}

		public int IsMousePressed(int id)
		{
			MouseButton* b;
			if (this == null) return (int) (Nuklear.nk_false);
			b = (MouseButton*) this.mouse.buttons + id;
			if (((b->down) != 0) && ((b->clicked) != 0)) return (int) (Nuklear.nk_true);
			return (int) (Nuklear.nk_false);
		}

		public int IsMouseReleased(int id)
		{
			if (this == null) return (int) (Nuklear.nk_false);
			return ((this.mouse.buttons[id].down == 0) && ((this.mouse.buttons[id].clicked) != 0)) ? 1 : 0;
		}

		public int IsKeyPressed(int key)
		{
			Key* k;
			if (this == null) return (int) (Nuklear.nk_false);
			k = (Key*) this.keyboard.keys + key;
			if ((((k->down) != 0) && ((k->clicked) != 0)) || ((k->down == 0) && ((k->clicked) >= (2))))
				return (int) (Nuklear.nk_true);
			return (int) (Nuklear.nk_false);
		}

		public int IsKeyReleased(int key)
		{
			Key* k;
			if (this == null) return (int) (Nuklear.nk_false);
			k = (Key*) this.keyboard.keys + key;
			if (((k->down == 0) && ((k->clicked) != 0)) || (((k->down) != 0) && ((k->clicked) >= (2))))
				return (int) (Nuklear.nk_true);
			return (int) (Nuklear.nk_false);
		}

		public int IsKeyDown(int key)
		{
			Key* k;
			if (this == null) return (int) (Nuklear.nk_false);
			k = (Key*) this.keyboard.keys + key;
			if ((k->down) != 0) return (int) (Nuklear.nk_true);
			return (int) (Nuklear.nk_false);
		}

		public int ToggleBehavior(Rect select, ref uint state, int active)
		{
			if (((state) & Nuklear.NK_WIDGET_STATE_MODIFIED) != 0)
				(state) = (uint) (Nuklear.NK_WIDGET_STATE_INACTIVE | Nuklear.NK_WIDGET_STATE_MODIFIED);
			else (state) = (uint) (Nuklear.NK_WIDGET_STATE_INACTIVE);
			if ((select.ButtonBehavior(ref state, this, (int) (Nuklear.NK_BUTTON_DEFAULT))) != 0)
			{
				state = (uint) (Nuklear.NK_WIDGET_STATE_ACTIVE);
				active = active != 0 ? 0 : 1;
			}

			if (((state & Nuklear.NK_WIDGET_STATE_HOVER) != 0) && (IsMousePrevHoveringRect((Rect) (select)) == 0))
				state |= (uint) (Nuklear.NK_WIDGET_STATE_ENTERED);
			else if ((IsMousePrevHoveringRect((Rect) (select))) != 0) state |= (uint) (Nuklear.NK_WIDGET_STATE_LEFT);
			return (int) (active);
		}

		public ulong ProgressBehavior(ref uint state, Rect r, Rect cursor, ulong max, ulong value, int modifiable)
		{
			int left_mouse_down = (int) (0);
			int left_mouse_click_in_cursor = (int) (0);
			if (((state) & Nuklear.NK_WIDGET_STATE_MODIFIED) != 0)
				(state) = (uint) (Nuklear.NK_WIDGET_STATE_INACTIVE | Nuklear.NK_WIDGET_STATE_MODIFIED);
			else (state) = (uint) (Nuklear.NK_WIDGET_STATE_INACTIVE);
			if ((modifiable == 0)) return (ulong) (value);
			left_mouse_down =
				(int) (((this) != null) && ((((MouseButton*) this.mouse.buttons + Nuklear.NK_BUTTON_LEFT)->down) != 0) ? 1 : 0);
			left_mouse_click_in_cursor =
				(int)
					(((this) != null) &&
					 ((HasMouseClickDownInRect((int) (Nuklear.NK_BUTTON_LEFT), (Rect) (cursor), (int) (Nuklear.nk_true))) != 0)
						? 1
						: 0);
			if ((IsMouseHoveringRect((Rect) (r))) != 0) state = (uint) (Nuklear.NK_WIDGET_STATE_HOVERED);
			if ((((this) != null) && ((left_mouse_down) != 0)) && ((left_mouse_click_in_cursor) != 0))
			{
				if (((left_mouse_down) != 0) && ((left_mouse_click_in_cursor) != 0))
				{
					float ratio = (float) (((0) < (this.mouse.pos.x - cursor.x) ? (this.mouse.pos.x - cursor.x) : (0))/cursor.w);
					value =
						((ulong)
							((((float) (max)*ratio) < ((float) (max)) ? ((float) (max)*ratio) : ((float) (max))) < (0)
								? (0)
								: (((float) (max)*ratio) < ((float) (max)) ? ((float) (max)*ratio) : ((float) (max)))));
					((MouseButton*) this.mouse.buttons + Nuklear.NK_BUTTON_LEFT)->clicked_pos.x = (float) (cursor.x + cursor.w/2.0f);
					state |= (uint) (Nuklear.NK_WIDGET_STATE_ACTIVE);
				}
			}

			if (((state & Nuklear.NK_WIDGET_STATE_HOVER) != 0) && (IsMousePrevHoveringRect((Rect) (r)) == 0))
				state |= (uint) (Nuklear.NK_WIDGET_STATE_ENTERED);
			else if ((IsMousePrevHoveringRect((Rect) (r))) != 0) state |= (uint) (Nuklear.NK_WIDGET_STATE_LEFT);
			return (ulong) (value);
		}

		public float ScrollbarBehavior(ref uint state, int has_scrolling, Rect* scroll, ref Rect cursor, Rect* empty0,
			Rect* empty1, float scroll_offset, float target, float scroll_step, int o)
		{
			uint ws = (uint) (0);
			int left_mouse_down;
			int left_mouse_click_in_cursor;
			float scroll_delta;
			if (((state) & Nuklear.NK_WIDGET_STATE_MODIFIED) != 0)
				(state) = (uint) (Nuklear.NK_WIDGET_STATE_INACTIVE | Nuklear.NK_WIDGET_STATE_MODIFIED);
			else (state) = (uint) (Nuklear.NK_WIDGET_STATE_INACTIVE);
			if (this == null) return (float) (scroll_offset);
			left_mouse_down = (int) (((MouseButton*) this.mouse.buttons + Nuklear.NK_BUTTON_LEFT)->down);
			left_mouse_click_in_cursor =
				(int) (HasMouseClickDownInRect((int) (Nuklear.NK_BUTTON_LEFT), (Rect) (cursor), (int) (Nuklear.nk_true)));
			if ((IsMouseHoveringRect((Rect) (*scroll))) != 0) state = (uint) (Nuklear.NK_WIDGET_STATE_HOVERED);
			scroll_delta = (float) (((o) == (Nuklear.NK_VERTICAL)) ? this.mouse.scroll_delta.y : this.mouse.scroll_delta.x);
			if (((left_mouse_down) != 0) && ((left_mouse_click_in_cursor) != 0))
			{
				float pixel;
				float delta;
				state = (uint) (Nuklear.NK_WIDGET_STATE_ACTIVE);
				if ((o) == (Nuklear.NK_VERTICAL))
				{
					float cursor_y;
					pixel = (float) (this.mouse.delta.y);
					delta = (float) ((pixel/scroll->h)*target);
					scroll_offset =
						(float)
							(((scroll_offset + delta) < (target - scroll->h) ? (scroll_offset + delta) : (target - scroll->h)) < (0)
								? (0)
								: ((scroll_offset + delta) < (target - scroll->h) ? (scroll_offset + delta) : (target - scroll->h)));
					cursor_y = (float) (scroll->y + ((scroll_offset/target)*scroll->h));
					((MouseButton*) this.mouse.buttons + Nuklear.NK_BUTTON_LEFT)->clicked_pos.y = (float) (cursor_y + cursor.h/2.0f);
				}
				else
				{
					float cursor_x;
					pixel = (float) (this.mouse.delta.x);
					delta = (float) ((pixel/scroll->w)*target);
					scroll_offset =
						(float)
							(((scroll_offset + delta) < (target - scroll->w) ? (scroll_offset + delta) : (target - scroll->w)) < (0)
								? (0)
								: ((scroll_offset + delta) < (target - scroll->w) ? (scroll_offset + delta) : (target - scroll->w)));
					cursor_x = (float) (scroll->x + ((scroll_offset/target)*scroll->w));
					((MouseButton*) this.mouse.buttons + Nuklear.NK_BUTTON_LEFT)->clicked_pos.x = (float) (cursor_x + cursor.w/2.0f);
				}
			}
			else if (((((IsKeyPressed((int) (Nuklear.NK_KEY_SCROLL_UP))) != 0) && ((o) == (Nuklear.NK_VERTICAL))) &&
			          ((has_scrolling) != 0)) || ((empty0->ButtonBehavior(ref ws, this, (int) (Nuklear.NK_BUTTON_DEFAULT))) != 0))
			{
				if ((o) == (Nuklear.NK_VERTICAL))
					scroll_offset = (float) ((0) < (scroll_offset - scroll->h) ? (scroll_offset - scroll->h) : (0));
				else scroll_offset = (float) ((0) < (scroll_offset - scroll->w) ? (scroll_offset - scroll->w) : (0));
			}
			else if (((((IsKeyPressed((int) (Nuklear.NK_KEY_SCROLL_DOWN))) != 0) && ((o) == (Nuklear.NK_VERTICAL))) &&
			          ((has_scrolling) != 0)) || ((empty1->ButtonBehavior(ref ws, this, (int) (Nuklear.NK_BUTTON_DEFAULT))) != 0))
			{
				if ((o) == (Nuklear.NK_VERTICAL))
					scroll_offset =
						(float)
							((scroll_offset + scroll->h) < (target - scroll->h) ? (scroll_offset + scroll->h) : (target - scroll->h));
				else
					scroll_offset =
						(float)
							((scroll_offset + scroll->w) < (target - scroll->w) ? (scroll_offset + scroll->w) : (target - scroll->w));
			}
			else if ((has_scrolling) != 0)
			{
				if ((((scroll_delta) < (0)) || ((scroll_delta) > (0))))
				{
					scroll_offset = (float) (scroll_offset + scroll_step*(-scroll_delta));
					if ((o) == (Nuklear.NK_VERTICAL))
						scroll_offset =
							(float)
								(((scroll_offset) < (target - scroll->h) ? (scroll_offset) : (target - scroll->h)) < (0)
									? (0)
									: ((scroll_offset) < (target - scroll->h) ? (scroll_offset) : (target - scroll->h)));
					else
						scroll_offset =
							(float)
								(((scroll_offset) < (target - scroll->w) ? (scroll_offset) : (target - scroll->w)) < (0)
									? (0)
									: ((scroll_offset) < (target - scroll->w) ? (scroll_offset) : (target - scroll->w)));
				}
				else if ((IsKeyPressed((int) (Nuklear.NK_KEY_SCROLL_START))) != 0)
				{
					if ((o) == (Nuklear.NK_VERTICAL)) scroll_offset = (float) (0);
				}
				else if ((IsKeyPressed((int) (Nuklear.NK_KEY_SCROLL_END))) != 0)
				{
					if ((o) == (Nuklear.NK_VERTICAL)) scroll_offset = (float) (target - scroll->h);
				}
			}

			if (((state & Nuklear.NK_WIDGET_STATE_HOVER) != 0) && (IsMousePrevHoveringRect((Rect) (*scroll)) == 0))
				state |= (uint) (Nuklear.NK_WIDGET_STATE_ENTERED);
			else if ((IsMousePrevHoveringRect((Rect) (*scroll))) != 0) state |= (uint) (Nuklear.NK_WIDGET_STATE_LEFT);
			return (float) (scroll_offset);
		}

		public void DragBehavior(ref uint state, Rect drag, PropertyVariant* variant, float inc_per_pixel)
		{
			int left_mouse_down =
				(int) (((this) != null) && ((((MouseButton*) this.mouse.buttons + Nuklear.NK_BUTTON_LEFT)->down) != 0) ? 1 : 0);
			int left_mouse_click_in_cursor =
				(int)
					(((this) != null) &&
					 ((HasMouseClickDownInRect((int) (Nuklear.NK_BUTTON_LEFT), (Rect) (drag), (int) (Nuklear.nk_true))) != 0)
						? 1
						: 0);
			if (((state) & Nuklear.NK_WIDGET_STATE_MODIFIED) != 0)
				(state) = (uint) (Nuklear.NK_WIDGET_STATE_INACTIVE | Nuklear.NK_WIDGET_STATE_MODIFIED);
			else (state) = (uint) (Nuklear.NK_WIDGET_STATE_INACTIVE);
			if ((IsMouseHoveringRect((Rect) (drag))) != 0) state = (uint) (Nuklear.NK_WIDGET_STATE_HOVERED);
			if (((left_mouse_down) != 0) && ((left_mouse_click_in_cursor) != 0))
			{
				float delta;
				float pixels;
				pixels = (float) (this.mouse.delta.x);
				delta = (float) (pixels*inc_per_pixel);
				switch (variant->kind)
				{
					default:
						break;
					case Nuklear.NK_PROPERTY_INT:
						variant->value.i = (int) (variant->value.i + (int) (delta));
						variant->value.i =
							(int)
								(((variant->value.i) < (variant->max_value.i) ? (variant->value.i) : (variant->max_value.i)) <
								 (variant->min_value.i)
									? (variant->min_value.i)
									: ((variant->value.i) < (variant->max_value.i) ? (variant->value.i) : (variant->max_value.i)));
						break;
					case Nuklear.NK_PROPERTY_FLOAT:
						variant->value.f = (float) (variant->value.f + delta);
						variant->value.f =
							(float)
								(((variant->value.f) < (variant->max_value.f) ? (variant->value.f) : (variant->max_value.f)) <
								 (variant->min_value.f)
									? (variant->min_value.f)
									: ((variant->value.f) < (variant->max_value.f) ? (variant->value.f) : (variant->max_value.f)));
						break;
					case Nuklear.NK_PROPERTY_DOUBLE:
						variant->value.d = (double) (variant->value.d + (double) (delta));
						variant->value.d =
							(double)
								(((variant->value.d) < (variant->max_value.d) ? (variant->value.d) : (variant->max_value.d)) <
								 (variant->min_value.d)
									? (variant->min_value.d)
									: ((variant->value.d) < (variant->max_value.d) ? (variant->value.d) : (variant->max_value.d)));
						break;
				}
				state = (uint) (Nuklear.NK_WIDGET_STATE_ACTIVE);
			}

			if (((state & Nuklear.NK_WIDGET_STATE_HOVER) != 0) && (IsMousePrevHoveringRect((Rect) (drag)) == 0))
				state |= (uint) (Nuklear.NK_WIDGET_STATE_ENTERED);
			else if ((IsMousePrevHoveringRect((Rect) (drag))) != 0) state |= (uint) (Nuklear.NK_WIDGET_STATE_LEFT);
		}

		public void PropertyBehavior(ref uint ws, Rect property, Rect label, Rect edit, Rect empty, ref int state,
			PropertyVariant* variant, float inc_per_pixel)
		{
			if (((this) != null) && ((state) == (Nuklear.NK_PROPERTY_DEFAULT)))
			{
				if ((edit.ButtonBehavior(ref ws, this, (int) (Nuklear.NK_BUTTON_DEFAULT))) != 0)
					state = (int) (Nuklear.NK_PROPERTY_EDIT);
				else if ((IsMouseClickDownInRect((int) (Nuklear.NK_BUTTON_LEFT), (Rect) (label), (int) (Nuklear.nk_true))) != 0)
					state = (int) (Nuklear.NK_PROPERTY_DRAG);
				else if ((IsMouseClickDownInRect((int) (Nuklear.NK_BUTTON_LEFT), (Rect) (empty), (int) (Nuklear.nk_true))) != 0)
					state = (int) (Nuklear.NK_PROPERTY_DRAG);
			}

			if ((state) == (Nuklear.NK_PROPERTY_DRAG))
			{
				DragBehavior(ref ws, (Rect) (property), variant, (float) (inc_per_pixel));
				if ((ws & Nuklear.NK_WIDGET_STATE_ACTIVED) == 0) state = (int) (Nuklear.NK_PROPERTY_DEFAULT);
			}

		}
	}
}