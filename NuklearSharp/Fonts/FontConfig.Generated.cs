// Generated by Sichem at 2/7/2018 5:58:59 PM

using System;
using System.Runtime.InteropServices;

namespace NuklearSharp
{
	public unsafe partial class FontConfig
	{
		public FontConfig next;
		public void* ttf_blob;
		public ulong ttf_size;
		public byte ttf_data_owned_by_atlas;
		public byte merge_mode;
		public byte pixel_snap;
		public byte oversample_v;
		public byte oversample_h;
		public PinnedArray<byte> padding = new PinnedArray<byte>(3);
		public float size;
		public int coord_type;
		public Vec2 spacing = new Vec2();
		public uint* range;
		public BakedFont font;
		public char fallback_glyph;
		public FontConfig n;
		public FontConfig p;

		public void FontBakerMemory(ulong* temp, ref int glyph_count, int count)
		{
			int range_count = (int) (0);
			int total_range_count = (int) (0);
			FontConfig iter;
			FontConfig i;
			if (this == null)
			{
				*temp = (ulong) (0);
				glyph_count = (int) (0);
				return;
			}

			glyph_count = (int) (0);
			for (iter = this; iter != null; iter = iter.next)
			{
				i = iter;
				do
				{
					if (i.range == null) iter.range = Nuklear.FontDefaultGlyphRanges();
					range_count = (int) (Nuklear.RangeCount(i.range));
					total_range_count += (int) (range_count);
					glyph_count += (int) (Nuklear.RangeGlyphCount(i.range, (int) (range_count)));
				} while ((i = i.n) != iter);
			}
			*temp = (ulong) (glyph_count*sizeof (RpRect));
			*temp += (ulong) (total_range_count*sizeof (TtPackRange));
			*temp += (ulong) (glyph_count*sizeof (TtPackedchar));
			*temp += (ulong) (count*sizeof (FontBakeData));
			*temp += (ulong) (sizeof (FontBaker));
			*temp += (ulong) (Nuklear.nk_rect_align + Nuklear.nk_range_align + Nuklear.nk_char_align);
			*temp += (ulong) (Nuklear.nk_build_align + Nuklear.nk_baker_align);
		}
	}
}