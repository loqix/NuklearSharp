// Generated by Sichem at 2/7/2018 5:58:59 PM

using System;
using System.Runtime.InteropServices;

namespace NuklearSharp
{
	[StructLayout(LayoutKind.Sequential)]
	public unsafe partial struct TtActiveEdge
	{
		public TtActiveEdge* next;
		public float fx;
		public float fdx;
		public float fdy;
		public float direction;
		public float sy;
		public float ey;

		public void TtHandleClippedEdge(float* scanline, int x, float x0, float y0, float x1, float y1)
		{
			if ((y0) == (y1)) return;
			if ((y0) > (this.ey)) return;
			if ((y1) < (this.sy)) return;
			if ((y0) < (this.sy))
			{
				x0 += (float) ((x1 - x0)*(this.sy - y0)/(y1 - y0));
				y0 = (float) (this.sy);
			}

			if ((y1) > (this.ey))
			{
				x1 += (float) ((x1 - x0)*(this.ey - y1)/(y1 - y0));
				y1 = (float) (this.ey);
			}

			if ((x0 <= x) && (x1 <= x)) scanline[x] += (float) (this.direction*(y1 - y0));
			else if (((x0) >= (x + 1)) && ((x1) >= (x + 1)))
			{
			}
			else
			{
				scanline[x] += (float) (this.direction*(y1 - y0)*(1.0f - ((x0 - (float) (x)) + (x1 - (float) (x)))/2.0f));
			}

		}

		public static void TtFillActiveEdgesNew(float* scanline, float* scanline_fill, int len, TtActiveEdge* e, float y_top)
		{
			float y_bottom = (float) (y_top + 1);
			while ((e) != null)
			{
				if ((e->fdx) == (0))
				{
					float x0 = (float) (e->fx);
					if ((x0) < (len))
					{
						if ((x0) >= (0))
						{
							e->TtHandleClippedEdge(scanline, (int) (x0), (float) (x0), (float) (y_top), (float) (x0), (float) (y_bottom));
							e->TtHandleClippedEdge(scanline_fill - 1, (int) ((int) (x0) + 1), (float) (x0), (float) (y_top), (float) (x0),
								(float) (y_bottom));
						}
						else
						{
							e->TtHandleClippedEdge(scanline_fill - 1, (int) (0), (float) (x0), (float) (y_top), (float) (x0),
								(float) (y_bottom));
						}
					}
				}
				else
				{
					float x0 = (float) (e->fx);
					float dx = (float) (e->fdx);
					float xb = (float) (x0 + dx);
					float x_top;
					float x_bottom;
					float y0;
					float y1;
					float dy = (float) (e->fdy);
					if ((e->sy) > (y_top))
					{
						x_top = (float) (x0 + dx*(e->sy - y_top));
						y0 = (float) (e->sy);
					}
					else
					{
						x_top = (float) (x0);
						y0 = (float) (y_top);
					}
					if ((e->ey) < (y_bottom))
					{
						x_bottom = (float) (x0 + dx*(e->ey - y_top));
						y1 = (float) (e->ey);
					}
					else
					{
						x_bottom = (float) (xb);
						y1 = (float) (y_bottom);
					}
					if (((((x_top) >= (0)) && ((x_bottom) >= (0))) && ((x_top) < (len))) && ((x_bottom) < (len)))
					{
						if (((int) (x_top)) == ((int) (x_bottom)))
						{
							float height;
							int x = (int) (x_top);
							height = (float) (y1 - y0);
							scanline[x] += (float) (e->direction*(1.0f - ((x_top - (float) (x)) + (x_bottom - (float) (x)))/2.0f)*height);
							scanline_fill[x] += (float) (e->direction*height);
						}
						else
						{
							int x;
							int x1;
							int x2;
							float y_crossing;
							float step;
							float sign;
							float area;
							if ((x_top) > (x_bottom))
							{
								float t;
								y0 = (float) (y_bottom - (y0 - y_top));
								y1 = (float) (y_bottom - (y1 - y_top));
								t = (float) (y0);
								y0 = (float) (y1);
								y1 = (float) (t);
								t = (float) (x_bottom);
								x_bottom = (float) (x_top);
								x_top = (float) (t);
								dx = (float) (-dx);
								dy = (float) (-dy);
								t = (float) (x0);
								x0 = (float) (xb);
								xb = (float) (t);
							}
							x1 = ((int) (x_top));
							x2 = ((int) (x_bottom));
							y_crossing = (float) (((float) (x1) + 1 - x0)*dy + y_top);
							sign = (float) (e->direction);
							area = (float) (sign*(y_crossing - y0));
							scanline[x1] += (float) (area*(1.0f - ((x_top - (float) (x1)) + (float) (x1 + 1 - x1))/2.0f));
							step = (float) (sign*dy);
							for (x = (int) (x1 + 1); (x) < (x2); ++x)
							{
								scanline[x] += (float) (area + step/2);
								area += (float) (step);
							}
							y_crossing += (float) (dy*(float) (x2 - (x1 + 1)));
							scanline[x2] +=
								(float) (area + sign*(1.0f - ((float) (x2 - x2) + (x_bottom - (float) (x2)))/2.0f)*(y1 - y_crossing));
							scanline_fill[x2] += (float) (sign*(y1 - y0));
						}
					}
					else
					{
						int x;
						for (x = (int) (0); (x) < (len); ++x)
						{
							float ya = (float) (y_top);
							float x1 = (float) (x);
							float x2 = (float) (x + 1);
							float x3 = (float) (xb);
							float y3 = (float) (y_bottom);
							float yb;
							float y2;
							yb = (float) (((float) (x) - x0)/dx + y_top);
							y2 = (float) (((float) (x) + 1 - x0)/dx + y_top);
							if (((x0) < (x1)) && ((x3) > (x2)))
							{
								e->TtHandleClippedEdge(scanline, (int) (x), (float) (x0), (float) (ya), (float) (x1), (float) (yb));
								e->TtHandleClippedEdge(scanline, (int) (x), (float) (x1), (float) (yb), (float) (x2), (float) (y2));
								e->TtHandleClippedEdge(scanline, (int) (x), (float) (x2), (float) (y2), (float) (x3), (float) (y3));
							}
							else if (((x3) < (x1)) && ((x0) > (x2)))
							{
								e->TtHandleClippedEdge(scanline, (int) (x), (float) (x0), (float) (ya), (float) (x2), (float) (y2));
								e->TtHandleClippedEdge(scanline, (int) (x), (float) (x2), (float) (y2), (float) (x1), (float) (yb));
								e->TtHandleClippedEdge(scanline, (int) (x), (float) (x1), (float) (yb), (float) (x3), (float) (y3));
							}
							else if (((x0) < (x1)) && ((x3) > (x1)))
							{
								e->TtHandleClippedEdge(scanline, (int) (x), (float) (x0), (float) (ya), (float) (x1), (float) (yb));
								e->TtHandleClippedEdge(scanline, (int) (x), (float) (x1), (float) (yb), (float) (x3), (float) (y3));
							}
							else if (((x3) < (x1)) && ((x0) > (x1)))
							{
								e->TtHandleClippedEdge(scanline, (int) (x), (float) (x0), (float) (ya), (float) (x1), (float) (yb));
								e->TtHandleClippedEdge(scanline, (int) (x), (float) (x1), (float) (yb), (float) (x3), (float) (y3));
							}
							else if (((x0) < (x2)) && ((x3) > (x2)))
							{
								e->TtHandleClippedEdge(scanline, (int) (x), (float) (x0), (float) (ya), (float) (x2), (float) (y2));
								e->TtHandleClippedEdge(scanline, (int) (x), (float) (x2), (float) (y2), (float) (x3), (float) (y3));
							}
							else if (((x3) < (x2)) && ((x0) > (x2)))
							{
								e->TtHandleClippedEdge(scanline, (int) (x), (float) (x0), (float) (ya), (float) (x2), (float) (y2));
								e->TtHandleClippedEdge(scanline, (int) (x), (float) (x2), (float) (y2), (float) (x3), (float) (y3));
							}
							else
							{
								e->TtHandleClippedEdge(scanline, (int) (x), (float) (x0), (float) (ya), (float) (x3), (float) (y3));
							}
						}
					}
				}
				e = e->next;
			}
		}
	}
}