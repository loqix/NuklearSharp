// Generated by Sichem at 2/4/2018 7:15:31 PM

using System;
using System.Runtime.InteropServices;

namespace NuklearSharp
{
	unsafe partial class Nuklear
	{
		public static void nk_input_begin(nk_context ctx)
		{
			int i;
			nk_input _in_;
			if (ctx == null) return;
			_in_ = ctx.input;
			for (i = (int) (0); (i) < (NK_BUTTON_MAX); ++i)
			{
				((nk_mouse_button*) _in_.mouse.buttons + i)->clicked = (uint) (0);
			}
			_in_.keyboard.text_len = (int) (0);
			_in_.mouse.scroll_delta = (nk_vec2) (nk_vec2_((float) (0), (float) (0)));
			_in_.mouse.prev.x = (float) (_in_.mouse.pos.x);
			_in_.mouse.prev.y = (float) (_in_.mouse.pos.y);
			_in_.mouse.delta.x = (float) (0);
			_in_.mouse.delta.y = (float) (0);
			for (i = (int) (0); (i) < (NK_KEY_MAX); i++)
			{
				((nk_key*) _in_.keyboard.keys + i)->clicked = (uint) (0);
			}
		}

		public static void nk_input_end(nk_context ctx)
		{
			nk_input _in_;
			if (ctx == null) return;
			_in_ = ctx.input;
			if ((_in_.mouse.grab) != 0) _in_.mouse.grab = (byte) (0);
			if ((_in_.mouse.ungrab) != 0)
			{
				_in_.mouse.grabbed = (byte) (0);
				_in_.mouse.ungrab = (byte) (0);
				_in_.mouse.grab = (byte) (0);
			}

		}

		public static void nk_input_motion(nk_context ctx, int x, int y)
		{
			nk_input _in_;
			if (ctx == null) return;
			_in_ = ctx.input;
			_in_.mouse.pos.x = ((float) (x));
			_in_.mouse.pos.y = ((float) (y));
			_in_.mouse.delta.x = (float) (_in_.mouse.pos.x - _in_.mouse.prev.x);
			_in_.mouse.delta.y = (float) (_in_.mouse.pos.y - _in_.mouse.prev.y);
		}

		public static void nk_input_key(nk_context ctx, int key, int down)
		{
			nk_input _in_;
			if (ctx == null) return;
			_in_ = ctx.input;
			if (((nk_key*) _in_.keyboard.keys + key)->down != down) ((nk_key*) _in_.keyboard.keys + key)->clicked++;
			((nk_key*) _in_.keyboard.keys + key)->down = (int) (down);
		}

		public static void nk_input_button(nk_context ctx, int id, int x, int y, int down)
		{
			nk_mouse_button* btn;
			nk_input _in_;
			if (ctx == null) return;
			_in_ = ctx.input;
			if ((_in_.mouse.buttons[id].down) == (down)) return;
			btn = (nk_mouse_button*) _in_.mouse.buttons + id;
			btn->clicked_pos.x = ((float) (x));
			btn->clicked_pos.y = ((float) (y));
			btn->down = (int) (down);
			btn->clicked++;
		}

		public static void nk_input_scroll(nk_context ctx, nk_vec2 val)
		{
			if (ctx == null) return;
			ctx.input.mouse.scroll_delta.x += (float) (val.x);
			ctx.input.mouse.scroll_delta.y += (float) (val.y);
		}

		public static void nk_input_glyph(nk_context ctx, char* glyph)
		{
			int len = (int) (0);
			char unicode;
			nk_input _in_;
			if (ctx == null) return;
			_in_ = ctx.input;
			len = (int) (nk_utf_decode(glyph, &unicode, (int) (4)));
			if (((len) != 0) && ((_in_.keyboard.text_len + len) < (16)))
			{
				nk_utf_encode(unicode, (char*) _in_.keyboard.text + _in_.keyboard.text_len, (int) (16 - _in_.keyboard.text_len));
				_in_.keyboard.text_len += (int) (len);
			}

		}

		public static void nk_input_char(nk_context ctx, char c)
		{
			char* glyph = stackalloc char[4];
			if (ctx == null) return;
			glyph[0] = c;
			nk_input_glyph(ctx, glyph);
		}

		public static void nk_input_unicode(nk_context ctx, char unicode)
		{
			char* rune = stackalloc char[4];
			if (ctx == null) return;
			nk_utf_encode(unicode, rune, (int) (4));
			nk_input_glyph(ctx, rune);
		}

		public static int nk_input_has_mouse_click(nk_input i, int id)
		{
			nk_mouse_button* btn;
			if (i == null) return (int) (nk_false);
			btn = (nk_mouse_button*) i.mouse.buttons + id;
			return (int) ((((btn->clicked) != 0) && ((btn->down) == (nk_false))) ? nk_true : nk_false);
		}

		public static int nk_input_has_mouse_click_in_rect(nk_input i, int id, nk_rect b)
		{
			nk_mouse_button* btn;
			if (i == null) return (int) (nk_false);
			btn = (nk_mouse_button*) i.mouse.buttons + id;
			if (
				!((((b.x) <= (btn->clicked_pos.x)) && ((btn->clicked_pos.x) < (b.x + b.w))) &&
				  (((b.y) <= (btn->clicked_pos.y)) && ((btn->clicked_pos.y) < (b.y + b.h))))) return (int) (nk_false);
			return (int) (nk_true);
		}

		public static int nk_input_has_mouse_click_down_in_rect(nk_input i, int id, nk_rect b, int down)
		{
			nk_mouse_button* btn;
			if (i == null) return (int) (nk_false);
			btn = (nk_mouse_button*) i.mouse.buttons + id;
			return
				(int) (((nk_input_has_mouse_click_in_rect(i, (int) (id), (nk_rect) (b))) != 0) && ((btn->down) == (down)) ? 1 : 0);
		}

		public static int nk_input_is_mouse_click_in_rect(nk_input i, int id, nk_rect b)
		{
			nk_mouse_button* btn;
			if (i == null) return (int) (nk_false);
			btn = (nk_mouse_button*) i.mouse.buttons + id;
			return
				(int)
					((((nk_input_has_mouse_click_down_in_rect(i, (int) (id), (nk_rect) (b), (int) (nk_false))) != 0) &&
					  ((btn->clicked) != 0))
						? nk_true
						: nk_false);
		}

		public static int nk_input_is_mouse_click_down_in_rect(nk_input i, int id, nk_rect b, int down)
		{
			nk_mouse_button* btn;
			if (i == null) return (int) (nk_false);
			btn = (nk_mouse_button*) i.mouse.buttons + id;
			return
				(int)
					((((nk_input_has_mouse_click_down_in_rect(i, (int) (id), (nk_rect) (b), (int) (down))) != 0) &&
					  ((btn->clicked) != 0))
						? nk_true
						: nk_false);
		}

		public static int nk_input_any_mouse_click_in_rect(nk_input _in_, nk_rect b)
		{
			int i;
			int down = (int) (0);
			for (i = (int) (0); (i) < (NK_BUTTON_MAX); ++i)
			{
				down = (int) (((down) != 0) || ((nk_input_is_mouse_click_in_rect(_in_, (int) (i), (nk_rect) (b))) != 0) ? 1 : 0);
			}
			return (int) (down);
		}

		public static int nk_input_is_mouse_hovering_rect(nk_input i, nk_rect rect)
		{
			if (i == null) return (int) (nk_false);
			return (((rect.x) <= (i.mouse.pos.x)) && ((i.mouse.pos.x) < (rect.x + rect.w))) &&
			       (((rect.y) <= (i.mouse.pos.y)) && ((i.mouse.pos.y) < (rect.y + rect.h)))
				? 1
				: 0;
		}

		public static int nk_input_is_mouse_prev_hovering_rect(nk_input i, nk_rect rect)
		{
			if (i == null) return (int) (nk_false);
			return (((rect.x) <= (i.mouse.prev.x)) && ((i.mouse.prev.x) < (rect.x + rect.w))) &&
			       (((rect.y) <= (i.mouse.prev.y)) && ((i.mouse.prev.y) < (rect.y + rect.h)))
				? 1
				: 0;
		}

		public static int nk_input_mouse_clicked(nk_input i, int id, nk_rect rect)
		{
			if (i == null) return (int) (nk_false);
			if (nk_input_is_mouse_hovering_rect(i, (nk_rect) (rect)) == 0) return (int) (nk_false);
			return (int) (nk_input_is_mouse_click_in_rect(i, (int) (id), (nk_rect) (rect)));
		}

		public static int nk_input_is_mouse_down(nk_input i, int id)
		{
			if (i == null) return (int) (nk_false);
			return (int) (i.mouse.buttons[id].down);
		}

		public static int nk_input_is_mouse_pressed(nk_input i, int id)
		{
			nk_mouse_button* b;
			if (i == null) return (int) (nk_false);
			b = (nk_mouse_button*) i.mouse.buttons + id;
			if (((b->down) != 0) && ((b->clicked) != 0)) return (int) (nk_true);
			return (int) (nk_false);
		}

		public static int nk_input_is_mouse_released(nk_input i, int id)
		{
			if (i == null) return (int) (nk_false);
			return ((i.mouse.buttons[id].down == 0) && ((i.mouse.buttons[id].clicked) != 0)) ? 1 : 0;
		}

		public static int nk_input_is_key_pressed(nk_input i, int key)
		{
			nk_key* k;
			if (i == null) return (int) (nk_false);
			k = (nk_key*) i.keyboard.keys + key;
			if ((((k->down) != 0) && ((k->clicked) != 0)) || ((k->down == 0) && ((k->clicked) >= (2)))) return (int) (nk_true);
			return (int) (nk_false);
		}

		public static int nk_input_is_key_released(nk_input i, int key)
		{
			nk_key* k;
			if (i == null) return (int) (nk_false);
			k = (nk_key*) i.keyboard.keys + key;
			if (((k->down == 0) && ((k->clicked) != 0)) || (((k->down) != 0) && ((k->clicked) >= (2)))) return (int) (nk_true);
			return (int) (nk_false);
		}

		public static int nk_input_is_key_down(nk_input i, int key)
		{
			nk_key* k;
			if (i == null) return (int) (nk_false);
			k = (nk_key*) i.keyboard.keys + key;
			if ((k->down) != 0) return (int) (nk_true);
			return (int) (nk_false);
		}
	}
}