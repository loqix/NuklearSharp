// Generated by Sichem at 2/7/2018 4:58:57 PM

using System;
using System.Runtime.InteropServices;

namespace NuklearSharp
{
	public unsafe partial class CommandBuffer
	{
		public void PushScissor(Rect r)
		{
			CommandScissor cmd;

			this.clip.x = (float) (r.x);
			this.clip.y = (float) (r.y);
			this.clip.w = (float) (r.w);
			this.clip.h = (float) (r.h);
			cmd = (CommandScissor) (Push((int) (Nuklear.NK_COMMAND_SCISSOR)));
			if (cmd == null) return;
			cmd.x = ((short) (r.x));
			cmd.y = ((short) (r.y));
			cmd.w = ((ushort) ((0) < (r.w) ? (r.w) : (0)));
			cmd.h = ((ushort) ((0) < (r.h) ? (r.h) : (0)));
		}

		public void StrokeLine(float x0, float y0, float x1, float y1, float line_thickness, Color c)
		{
			CommandLine cmd;
			if ((line_thickness <= 0)) return;
			cmd = (CommandLine) (Push((int) (Nuklear.NK_COMMAND_LINE)));
			if (cmd == null) return;
			cmd.line_thickness = ((ushort) (line_thickness));
			cmd.begin.x = ((short) (x0));
			cmd.begin.y = ((short) (y0));
			cmd.end.x = ((short) (x1));
			cmd.end.y = ((short) (y1));
			cmd.color = (Color) (c);
		}

		public void StrokeCurve(float ax, float ay, float ctrl0x, float ctrl0y, float ctrl1x, float ctrl1y, float bx, float by,
			float line_thickness, Color col)
		{
			CommandCurve cmd;
			if ((((col.a) == (0))) || (line_thickness <= 0)) return;
			cmd = (CommandCurve) (Push((int) (Nuklear.NK_COMMAND_CURVE)));
			if (cmd == null) return;
			cmd.line_thickness = ((ushort) (line_thickness));
			cmd.begin.x = ((short) (ax));
			cmd.begin.y = ((short) (ay));
			cmd.ctrl_0.x = ((short) (ctrl0x));
			cmd.ctrl_0.y = ((short) (ctrl0y));
			cmd.ctrl_1.x = ((short) (ctrl1x));
			cmd.ctrl_1.y = ((short) (ctrl1y));
			cmd.end.x = ((short) (bx));
			cmd.end.y = ((short) (by));
			cmd.color = (Color) (col);
		}

		public void StrokeRect(Rect rect, float rounding, float line_thickness, Color c)
		{
			CommandRect cmd;
			if ((((((c.a) == (0))) || ((rect.w) == (0))) || ((rect.h) == (0))) || (line_thickness <= 0)) return;
			if ((this.use_clipping) != 0)
			{
				if (
					!(!(((((this.clip.x) > (rect.x + rect.w)) || ((this.clip.x + this.clip.w) < (rect.x))) ||
					     ((this.clip.y) > (rect.y + rect.h))) || ((this.clip.y + this.clip.h) < (rect.y))))) return;
			}

			cmd = (CommandRect) (Push((int) (Nuklear.NK_COMMAND_RECT)));
			if (cmd == null) return;
			cmd.rounding = ((ushort) (rounding));
			cmd.line_thickness = ((ushort) (line_thickness));
			cmd.x = ((short) (rect.x));
			cmd.y = ((short) (rect.y));
			cmd.w = ((ushort) ((0) < (rect.w) ? (rect.w) : (0)));
			cmd.h = ((ushort) ((0) < (rect.h) ? (rect.h) : (0)));
			cmd.color = (Color) (c);
		}

		public void FillRect(Rect rect, float rounding, Color c)
		{
			CommandRectFilled cmd;
			if (((((c.a) == (0))) || ((rect.w) == (0))) || ((rect.h) == (0))) return;
			if ((this.use_clipping) != 0)
			{
				if (
					!(!(((((this.clip.x) > (rect.x + rect.w)) || ((this.clip.x + this.clip.w) < (rect.x))) ||
					     ((this.clip.y) > (rect.y + rect.h))) || ((this.clip.y + this.clip.h) < (rect.y))))) return;
			}

			cmd = (CommandRectFilled) (Push((int) (Nuklear.NK_COMMAND_RECT_FILLED)));
			if (cmd == null) return;
			cmd.rounding = ((ushort) (rounding));
			cmd.x = ((short) (rect.x));
			cmd.y = ((short) (rect.y));
			cmd.w = ((ushort) ((0) < (rect.w) ? (rect.w) : (0)));
			cmd.h = ((ushort) ((0) < (rect.h) ? (rect.h) : (0)));
			cmd.color = (Color) (c);
		}

		public void FillRectMultiColor(Rect rect, Color left, Color top, Color right, Color bottom)
		{
			CommandRectMultiColor cmd;
			if ((((rect.w) == (0))) || ((rect.h) == (0))) return;
			if ((this.use_clipping) != 0)
			{
				if (
					!(!(((((this.clip.x) > (rect.x + rect.w)) || ((this.clip.x + this.clip.w) < (rect.x))) ||
					     ((this.clip.y) > (rect.y + rect.h))) || ((this.clip.y + this.clip.h) < (rect.y))))) return;
			}

			cmd = (CommandRectMultiColor) (Push((int) (Nuklear.NK_COMMAND_RECT_MULTI_COLOR)));
			if (cmd == null) return;
			cmd.x = ((short) (rect.x));
			cmd.y = ((short) (rect.y));
			cmd.w = ((ushort) ((0) < (rect.w) ? (rect.w) : (0)));
			cmd.h = ((ushort) ((0) < (rect.h) ? (rect.h) : (0)));
			cmd.left = (Color) (left);
			cmd.top = (Color) (top);
			cmd.right = (Color) (right);
			cmd.bottom = (Color) (bottom);
		}

		public void StrokeCircle(Rect r, float line_thickness, Color c)
		{
			CommandCircle cmd;
			if (((((r.w) == (0))) || ((r.h) == (0))) || (line_thickness <= 0)) return;
			if ((this.use_clipping) != 0)
			{
				if (
					!(!(((((this.clip.x) > (r.x + r.w)) || ((this.clip.x + this.clip.w) < (r.x))) || ((this.clip.y) > (r.y + r.h))) ||
					    ((this.clip.y + this.clip.h) < (r.y))))) return;
			}

			cmd = (CommandCircle) (Push((int) (Nuklear.NK_COMMAND_CIRCLE)));
			if (cmd == null) return;
			cmd.line_thickness = ((ushort) (line_thickness));
			cmd.x = ((short) (r.x));
			cmd.y = ((short) (r.y));
			cmd.w = ((ushort) ((r.w) < (0) ? (0) : (r.w)));
			cmd.h = ((ushort) ((r.h) < (0) ? (0) : (r.h)));
			cmd.color = (Color) (c);
		}

		public void FillCircle(Rect r, Color c)
		{
			CommandCircleFilled cmd;
			if (((((c.a) == (0))) || ((r.w) == (0))) || ((r.h) == (0))) return;
			if ((this.use_clipping) != 0)
			{
				if (
					!(!(((((this.clip.x) > (r.x + r.w)) || ((this.clip.x + this.clip.w) < (r.x))) || ((this.clip.y) > (r.y + r.h))) ||
					    ((this.clip.y + this.clip.h) < (r.y))))) return;
			}

			cmd = (CommandCircleFilled) (Push((int) (Nuklear.NK_COMMAND_CIRCLE_FILLED)));
			if (cmd == null) return;
			cmd.x = ((short) (r.x));
			cmd.y = ((short) (r.y));
			cmd.w = ((ushort) ((r.w) < (0) ? (0) : (r.w)));
			cmd.h = ((ushort) ((r.h) < (0) ? (0) : (r.h)));
			cmd.color = (Color) (c);
		}

		public void StrokeArc(float cx, float cy, float radius, float a_min, float a_max, float line_thickness, Color c)
		{
			CommandArc cmd;
			if ((((c.a) == (0))) || (line_thickness <= 0)) return;
			cmd = (CommandArc) (Push((int) (Nuklear.NK_COMMAND_ARC)));
			if (cmd == null) return;
			cmd.line_thickness = ((ushort) (line_thickness));
			cmd.cx = ((short) (cx));
			cmd.cy = ((short) (cy));
			cmd.r = ((ushort) (radius));
			cmd.a[0] = (float) (a_min);
			cmd.a[1] = (float) (a_max);
			cmd.color = (Color) (c);
		}

		public void FillArc(float cx, float cy, float radius, float a_min, float a_max, Color c)
		{
			CommandArcFilled cmd;
			if (((c.a) == (0))) return;
			cmd = (CommandArcFilled) (Push((int) (Nuklear.NK_COMMAND_ARC_FILLED)));
			if (cmd == null) return;
			cmd.cx = ((short) (cx));
			cmd.cy = ((short) (cy));
			cmd.r = ((ushort) (radius));
			cmd.a[0] = (float) (a_min);
			cmd.a[1] = (float) (a_max);
			cmd.color = (Color) (c);
		}

		public void StrokeTriangle(float x0, float y0, float x1, float y1, float x2, float y2, float line_thickness, Color c)
		{
			CommandTriangle cmd;
			if ((((c.a) == (0))) || (line_thickness <= 0)) return;
			if ((this.use_clipping) != 0)
			{
				if (
					((!((((this.clip.x) <= (x0)) && ((x0) < (this.clip.x + this.clip.w))) &&
					    (((this.clip.y) <= (y0)) && ((y0) < (this.clip.y + this.clip.h))))) &&
					 (!((((this.clip.x) <= (x1)) && ((x1) < (this.clip.x + this.clip.w))) &&
					    (((this.clip.y) <= (y1)) && ((y1) < (this.clip.y + this.clip.h)))))) &&
					(!((((this.clip.x) <= (x2)) && ((x2) < (this.clip.x + this.clip.w))) &&
					   (((this.clip.y) <= (y2)) && ((y2) < (this.clip.y + this.clip.h)))))) return;
			}

			cmd = (CommandTriangle) (Push((int) (Nuklear.NK_COMMAND_TRIANGLE)));
			if (cmd == null) return;
			cmd.line_thickness = ((ushort) (line_thickness));
			cmd.a.x = ((short) (x0));
			cmd.a.y = ((short) (y0));
			cmd.b.x = ((short) (x1));
			cmd.b.y = ((short) (y1));
			cmd.c.x = ((short) (x2));
			cmd.c.y = ((short) (y2));
			cmd.color = (Color) (c);
		}

		public void FillTriangle(float x0, float y0, float x1, float y1, float x2, float y2, Color c)
		{
			CommandTriangleFilled cmd;
			if (((c.a) == (0))) return;

			if ((this.use_clipping) != 0)
			{
				if (
					((!((((this.clip.x) <= (x0)) && ((x0) < (this.clip.x + this.clip.w))) &&
					    (((this.clip.y) <= (y0)) && ((y0) < (this.clip.y + this.clip.h))))) &&
					 (!((((this.clip.x) <= (x1)) && ((x1) < (this.clip.x + this.clip.w))) &&
					    (((this.clip.y) <= (y1)) && ((y1) < (this.clip.y + this.clip.h)))))) &&
					(!((((this.clip.x) <= (x2)) && ((x2) < (this.clip.x + this.clip.w))) &&
					   (((this.clip.y) <= (y2)) && ((y2) < (this.clip.y + this.clip.h)))))) return;
			}

			cmd = (CommandTriangleFilled) (Push((int) (Nuklear.NK_COMMAND_TRIANGLE_FILLED)));
			if (cmd == null) return;
			cmd.a.x = ((short) (x0));
			cmd.a.y = ((short) (y0));
			cmd.b.x = ((short) (x1));
			cmd.b.y = ((short) (y1));
			cmd.c.x = ((short) (x2));
			cmd.c.y = ((short) (y2));
			cmd.color = (Color) (c);
		}

		public void DrawImage(Rect r, Image img, Color col)
		{
			CommandImage cmd;

			if ((this.use_clipping) != 0)
			{
				if ((((this.clip.w) == (0)) || ((this.clip.h) == (0))) ||
				    (!(!(((((this.clip.x) > (r.x + r.w)) || ((this.clip.x + this.clip.w) < (r.x))) || ((this.clip.y) > (r.y + r.h))) ||
				         ((this.clip.y + this.clip.h) < (r.y)))))) return;
			}

			cmd = (CommandImage) (Push((int) (Nuklear.NK_COMMAND_IMAGE)));
			if (cmd == null) return;
			cmd.x = ((short) (r.x));
			cmd.y = ((short) (r.y));
			cmd.w = ((ushort) ((0) < (r.w) ? (r.w) : (0)));
			cmd.h = ((ushort) ((0) < (r.h) ? (r.h) : (0)));
			cmd.img = (Image) (img);
			cmd.col = (Color) (col);
		}

		public void PushCustom(Rect r, Nuklear.NkCommandCustomCallback cb, Handle usr)
		{
			CommandCustom cmd;

			if ((this.use_clipping) != 0)
			{
				if ((((this.clip.w) == (0)) || ((this.clip.h) == (0))) ||
				    (!(!(((((this.clip.x) > (r.x + r.w)) || ((this.clip.x + this.clip.w) < (r.x))) || ((this.clip.y) > (r.y + r.h))) ||
				         ((this.clip.y + this.clip.h) < (r.y)))))) return;
			}

			cmd = (CommandCustom) (Push((int) (Nuklear.NK_COMMAND_CUSTOM)));
			if (cmd == null) return;
			cmd.x = ((short) (r.x));
			cmd.y = ((short) (r.y));
			cmd.w = ((ushort) ((0) < (r.w) ? (r.w) : (0)));
			cmd.h = ((ushort) ((0) < (r.h) ? (r.h) : (0)));
			cmd.callback_data = (Handle) (usr);
			cmd.callback = cb;
		}

		public void DrawText(Rect r, char* _string_, int length, UserFont font, Color bg, Color fg)
		{
			float text_width = (float) (0);
			CommandText cmd;
			if ((((_string_ == null)) || (length == 0)) || (((bg.a) == (0)) && ((fg.a) == (0)))) return;
			if ((this.use_clipping) != 0)
			{
				if ((((this.clip.w) == (0)) || ((this.clip.h) == (0))) ||
				    (!(!(((((this.clip.x) > (r.x + r.w)) || ((this.clip.x + this.clip.w) < (r.x))) || ((this.clip.y) > (r.y + r.h))) ||
				         ((this.clip.y + this.clip.h) < (r.y)))))) return;
			}

			text_width = (float) (font.width((Handle) (font.userdata), (float) (font.height), _string_, (int) (length)));
			if ((text_width) > (r.w))
			{
				int glyphs = (int) (0);
				float txt_width = (float) (text_width);
				length = (int) (font.TextClamp(_string_, (int) (length), (float) (r.w), &glyphs, &txt_width, null, (int) (0)));
			}

			if (length == 0) return;
			cmd = (CommandText) (Push((int) (Nuklear.NK_COMMAND_TEXT)));
			if (cmd == null) return;
			cmd.x = ((short) (r.x));
			cmd.y = ((short) (r.y));
			cmd.w = ((ushort) (r.w));
			cmd.h = ((ushort) (r.h));
			cmd.background = (Color) (bg);
			cmd.foreground = (Color) (fg);
			cmd.font = font;
			cmd.length = (int) (length);
			cmd.height = (float) (font.height);
			cmd._string_ = new PinnedArray<char>(length);
			CRuntime.memcpy((void*) cmd._string_, _string_, length*sizeof (char));
			cmd._string_[length] = ('\0');
		}

		public void WidgetText(Rect b, char* _string_, int len, Text* t, uint a, UserFont f)
		{
			Rect label = new Rect();
			float text_width;
			if ((t == null)) return;
			b.h = (float) ((b.h) < (2*t->padding.y) ? (2*t->padding.y) : (b.h));
			label.x = (float) (0);
			label.w = (float) (0);
			label.y = (float) (b.y + t->padding.y);
			label.h = (float) ((f.height) < (b.h - 2*t->padding.y) ? (f.height) : (b.h - 2*t->padding.y));
			text_width = (float) (f.width((Handle) (f.userdata), (float) (f.height), _string_, (int) (len)));
			text_width += (float) (2.0f*t->padding.x);
			if ((a & Nuklear.NK_TEXT_ALIGN_LEFT) != 0)
			{
				label.x = (float) (b.x + t->padding.x);
				label.w = (float) ((0) < (b.w - 2*t->padding.x) ? (b.w - 2*t->padding.x) : (0));
			}
			else if ((a & Nuklear.NK_TEXT_ALIGN_CENTERED) != 0)
			{
				label.w = (float) ((1) < (2*t->padding.x + text_width) ? (2*t->padding.x + text_width) : (1));
				label.x = (float) (b.x + t->padding.x + ((b.w - 2*t->padding.x) - label.w)/2);
				label.x = (float) ((b.x + t->padding.x) < (label.x) ? (label.x) : (b.x + t->padding.x));
				label.w = (float) ((b.x + b.w) < (label.x + label.w) ? (b.x + b.w) : (label.x + label.w));
				if ((label.w) >= (label.x)) label.w -= (float) (label.x);
			}
			else if ((a & Nuklear.NK_TEXT_ALIGN_RIGHT) != 0)
			{
				label.x =
					(float)
						((b.x + t->padding.x) < ((b.x + b.w) - (2*t->padding.x + text_width))
							? ((b.x + b.w) - (2*t->padding.x + text_width))
							: (b.x + t->padding.x));
				label.w = (float) (text_width + 2*t->padding.x);
			}
			else return;
			if ((a & Nuklear.NK_TEXT_ALIGN_MIDDLE) != 0)
			{
				label.y = (float) (b.y + b.h/2.0f - f.height/2.0f);
				label.h =
					(float) ((b.h/2.0f) < (b.h - (b.h/2.0f + f.height/2.0f)) ? (b.h - (b.h/2.0f + f.height/2.0f)) : (b.h/2.0f));
			}
			else if ((a & Nuklear.NK_TEXT_ALIGN_BOTTOM) != 0)
			{
				label.y = (float) (b.y + b.h - f.height);
				label.h = (float) (f.height);
			}

			DrawText((Rect) (label), _string_, (int) (len), f, (Color) (t->background), (Color) (t->text));
		}

		public void WidgetTextWrap(Rect b, char* _string_, int len, Text* t, UserFont f)
		{
			float width;
			int glyphs = (int) (0);
			int fitting = (int) (0);
			int done = (int) (0);
			Rect line = new Rect();
			Text text = new Text();
			uint* seperator = stackalloc uint[1];
			seperator[0] = (uint) (' ');

			if ((t == null)) return;
			text.padding = (Vec2) (Nuklear.Vec2z((float) (0), (float) (0)));
			text.background = (Color) (t->background);
			text.text = (Color) (t->text);
			b.w = (float) ((b.w) < (2*t->padding.x) ? (2*t->padding.x) : (b.w));
			b.h = (float) ((b.h) < (2*t->padding.y) ? (2*t->padding.y) : (b.h));
			b.h = (float) (b.h - 2*t->padding.y);
			line.x = (float) (b.x + t->padding.x);
			line.y = (float) (b.y + t->padding.y);
			line.w = (float) (b.w - 2*t->padding.x);
			line.h = (float) (2*t->padding.y + f.height);
			fitting = (int) (f.TextClamp(_string_, (int) (len), (float) (line.w), &glyphs, &width, seperator, 1));
			while ((done) < (len))
			{
				if ((fitting == 0) || ((line.y + line.h) >= (b.y + b.h))) break;
				WidgetText((Rect) (line), &_string_[done], (int) (fitting), &text, (uint) (Nuklear.NK_TEXT_LEFT), f);
				done += (int) (fitting);
				line.y += (float) (f.height + 2*t->padding.y);
				fitting = (int) (f.TextClamp(&_string_[done], (int) (len - done), (float) (line.w), &glyphs, &width, seperator, 1));
			}
		}

		public void DrawSymbol(int type, Rect content, Color background, Color foreground, float border_width, UserFont font)
		{
			switch (type)
			{
				case Nuklear.NK_SYMBOL_X:
				case Nuklear.NK_SYMBOL_UNDERSCORE:
				case Nuklear.NK_SYMBOL_PLUS:
				case Nuklear.NK_SYMBOL_MINUS:
				{
					char X = ((type) == (Nuklear.NK_SYMBOL_X))
						? 'x'
						: ((type) == (Nuklear.NK_SYMBOL_UNDERSCORE)) ? '_' : ((type) == (Nuklear.NK_SYMBOL_PLUS)) ? '+' : '-';
					Text text = new Text();
					text.padding = (Vec2) (Nuklear.Vec2z((float) (0), (float) (0)));
					text.background = (Color) (background);
					text.text = (Color) (foreground);
					WidgetText((Rect) (content), &X, (int) (1), &text, (uint) (Nuklear.NK_TEXT_CENTERED), font);
				}
					break;
				case Nuklear.NK_SYMBOL_CIRCLE_SOLID:
				case Nuklear.NK_SYMBOL_CIRCLE_OUTLINE:
				case Nuklear.NK_SYMBOL_RECT_SOLID:
				case Nuklear.NK_SYMBOL_RECT_OUTLINE:
				{
					if (((type) == (Nuklear.NK_SYMBOL_RECT_SOLID)) || ((type) == (Nuklear.NK_SYMBOL_RECT_OUTLINE)))
					{
						FillRect((Rect) (content), (float) (0), (Color) (foreground));
						if ((type) == (Nuklear.NK_SYMBOL_RECT_OUTLINE))
							FillRect((Rect) (content.ShrinkRectz((float) (border_width))), (float) (0), (Color) (background));
					}
					else
					{
						FillCircle((Rect) (content), (Color) (foreground));
						if ((type) == (Nuklear.NK_SYMBOL_CIRCLE_OUTLINE))
							FillCircle((Rect) (content.ShrinkRectz((float) (1))), (Color) (background));
					}
				}
					break;
				case Nuklear.NK_SYMBOL_TRIANGLE_UP:
				case Nuklear.NK_SYMBOL_TRIANGLE_DOWN:
				case Nuklear.NK_SYMBOL_TRIANGLE_LEFT:
				case Nuklear.NK_SYMBOL_TRIANGLE_RIGHT:
				{
					int heading;
					Vec2* points = stackalloc Vec2[3];
					heading =
						(int)
							(((type) == (Nuklear.NK_SYMBOL_TRIANGLE_RIGHT))
								? Nuklear.NK_RIGHT
								: ((type) == (Nuklear.NK_SYMBOL_TRIANGLE_LEFT))
									? Nuklear.NK_LEFT
									: ((type) == (Nuklear.NK_SYMBOL_TRIANGLE_UP)) ? Nuklear.NK_UP : Nuklear.NK_DOWN);
					Vec2.TriangleFromDirection(points, (Rect) (content), (float) (0), (float) (0), (int) (heading));
					FillTriangle((float) (points[0].x), (float) (points[0].y), (float) (points[1].x), (float) (points[1].y),
						(float) (points[2].x), (float) (points[2].y), (Color) (foreground));
				}
					break;
				default:
				case Nuklear.NK_SYMBOL_NONE:
				case Nuklear.NK_SYMBOL_MAX:
					break;
			}

		}

		public StyleItem DrawButton(Rect* bounds, uint state, StyleButton style)
		{
			StyleItem background;
			if ((state & Nuklear.NK_WIDGET_STATE_HOVER) != 0) background = style.hover;
			else if ((state & Nuklear.NK_WIDGET_STATE_ACTIVED) != 0) background = style.active;
			else background = style.normal;
			if ((background.type) == (Nuklear.NK_STYLE_ITEM_IMAGE))
			{
				DrawImage((Rect) (*bounds), background.data.image, (Color) (Nuklear.nk_white));
			}
			else
			{
				FillRect((Rect) (*bounds), (float) (style.rounding), (Color) (background.data.color));
				StrokeRect((Rect) (*bounds), (float) (style.rounding), (float) (style.border), (Color) (style.border_color));
			}

			return background;
		}

		public int DoButton(ref uint state, Rect r, StyleButton style, Input _in_, int behavior, Rect* content)
		{
			Rect bounds = new Rect();
			if ((style == null)) return (int) (Nuklear.nk_false);
			content->x = (float) (r.x + style.padding.x + style.border + style.rounding);
			content->y = (float) (r.y + style.padding.y + style.border + style.rounding);
			content->w = (float) (r.w - (2*style.padding.x + style.border + style.rounding*2));
			content->h = (float) (r.h - (2*style.padding.y + style.border + style.rounding*2));
			bounds.x = (float) (r.x - style.touch_padding.x);
			bounds.y = (float) (r.y - style.touch_padding.y);
			bounds.w = (float) (r.w + 2*style.touch_padding.x);
			bounds.h = (float) (r.h + 2*style.touch_padding.y);
			return (int) (bounds.ButtonBehavior(ref state, _in_, (int) (behavior)));
		}

		public void DrawButtonText(Rect* bounds, Rect* content, uint state, StyleButton style, char* txt, int len,
			uint text_alignment, UserFont font)
		{
			Text text = new Text();
			StyleItem background;
			background = DrawButton(bounds, (uint) (state), style);
			if ((background.type) == (Nuklear.NK_STYLE_ITEM_COLOR)) text.background = (Color) (background.data.color);
			else text.background = (Color) (style.text_background);
			if ((state & Nuklear.NK_WIDGET_STATE_HOVER) != 0) text.text = (Color) (style.text_hover);
			else if ((state & Nuklear.NK_WIDGET_STATE_ACTIVED) != 0) text.text = (Color) (style.text_active);
			else text.text = (Color) (style.text_normal);
			text.padding = (Vec2) (Nuklear.Vec2z((float) (0), (float) (0)));
			WidgetText((Rect) (*content), txt, (int) (len), &text, (uint) (text_alignment), font);
		}

		public int DoButtonText(ref uint state, Rect bounds, char* _string_, int len, uint align, int behavior,
			StyleButton style, Input _in_, UserFont font)
		{
			Rect content = new Rect();
			int ret = (int) (Nuklear.nk_false);
			if ((((style == null)) || (font == null)) || (_string_ == null)) return (int) (Nuklear.nk_false);
			ret = (int) (DoButton(ref state, (Rect) (bounds), style, _in_, (int) (behavior), &content));
			if ((style.draw_begin) != null) style.draw_begin(this, (Handle) (style.userdata));
			DrawButtonText(&bounds, &content, (uint) (state), style, _string_, (int) (len), (uint) (align), font);
			if ((style.draw_end) != null) style.draw_end(this, (Handle) (style.userdata));
			return (int) (ret);
		}

		public void DrawButtonSymbol(Rect* bounds, Rect* content, uint state, StyleButton style, int type, UserFont font)
		{
			Color sym = new Color();
			Color bg = new Color();
			StyleItem background;
			background = DrawButton(bounds, (uint) (state), style);
			if ((background.type) == (Nuklear.NK_STYLE_ITEM_COLOR)) bg = (Color) (background.data.color);
			else bg = (Color) (style.text_background);
			if ((state & Nuklear.NK_WIDGET_STATE_HOVER) != 0) sym = (Color) (style.text_hover);
			else if ((state & Nuklear.NK_WIDGET_STATE_ACTIVED) != 0) sym = (Color) (style.text_active);
			else sym = (Color) (style.text_normal);
			DrawSymbol((int) (type), (Rect) (*content), (Color) (bg), (Color) (sym), (float) (1), font);
		}

		public int DoButtonSymbol(ref uint state, Rect bounds, int symbol, int behavior, StyleButton style, Input _in_,
			UserFont font)
		{
			int ret;
			Rect content = new Rect();
			if ((((style == null)) || (font == null)) || (state == null)) return (int) (Nuklear.nk_false);
			ret = (int) (DoButton(ref state, (Rect) (bounds), style, _in_, (int) (behavior), &content));
			if ((style.draw_begin) != null) style.draw_begin(this, (Handle) (style.userdata));
			DrawButtonSymbol(&bounds, &content, (uint) (state), style, (int) (symbol), font);
			if ((style.draw_end) != null) style.draw_end(this, (Handle) (style.userdata));
			return (int) (ret);
		}

		public void DrawButtonImage(Rect* bounds, Rect* content, uint state, StyleButton style, Image img)
		{
			DrawButton(bounds, (uint) (state), style);
			DrawImage((Rect) (*content), img, (Color) (Nuklear.nk_white));
		}

		public int DoButtonImage(ref uint state, Rect bounds, Image img, int b, StyleButton style, Input _in_)
		{
			int ret;
			Rect content = new Rect();
			if (((style == null)) || (state == null)) return (int) (Nuklear.nk_false);
			ret = (int) (DoButton(ref state, (Rect) (bounds), style, _in_, (int) (b), &content));
			content.x += (float) (style.image_padding.x);
			content.y += (float) (style.image_padding.y);
			content.w -= (float) (2*style.image_padding.x);
			content.h -= (float) (2*style.image_padding.y);
			if ((style.draw_begin) != null) style.draw_begin(this, (Handle) (style.userdata));
			DrawButtonImage(&bounds, &content, (uint) (state), style, img);
			if ((style.draw_end) != null) style.draw_end(this, (Handle) (style.userdata));
			return (int) (ret);
		}

		public void DrawButtonTextSymbol(Rect* bounds, Rect* label, Rect* symbol, uint state, StyleButton style, char* str,
			int len, int type, UserFont font)
		{
			Color sym = new Color();
			Text text = new Text();
			StyleItem background;
			background = DrawButton(bounds, (uint) (state), style);
			if ((background.type) == (Nuklear.NK_STYLE_ITEM_COLOR)) text.background = (Color) (background.data.color);
			else text.background = (Color) (style.text_background);
			if ((state & Nuklear.NK_WIDGET_STATE_HOVER) != 0)
			{
				sym = (Color) (style.text_hover);
				text.text = (Color) (style.text_hover);
			}
			else if ((state & Nuklear.NK_WIDGET_STATE_ACTIVED) != 0)
			{
				sym = (Color) (style.text_active);
				text.text = (Color) (style.text_active);
			}
			else
			{
				sym = (Color) (style.text_normal);
				text.text = (Color) (style.text_normal);
			}

			text.padding = (Vec2) (Nuklear.Vec2z((float) (0), (float) (0)));
			DrawSymbol((int) (type), (Rect) (*symbol), (Color) (style.text_background), (Color) (sym), (float) (0), font);
			WidgetText((Rect) (*label), str, (int) (len), &text, (uint) (Nuklear.NK_TEXT_CENTERED), font);
		}

		public int DoButtonTextSymbol(ref uint state, Rect bounds, int symbol, char* str, int len, uint align, int behavior,
			StyleButton style, UserFont font, Input _in_)
		{
			int ret;
			Rect tri = new Rect();
			Rect content = new Rect();
			if (((style == null)) || (font == null)) return (int) (Nuklear.nk_false);
			ret = (int) (DoButton(ref state, (Rect) (bounds), style, _in_, (int) (behavior), &content));
			tri.y = (float) (content.y + (content.h/2) - font.height/2);
			tri.w = (float) (font.height);
			tri.h = (float) (font.height);
			if ((align & Nuklear.NK_TEXT_ALIGN_LEFT) != 0)
			{
				tri.x = (float) ((content.x + content.w) - (2*style.padding.x + tri.w));
				tri.x = (float) ((tri.x) < (0) ? (0) : (tri.x));
			}
			else tri.x = (float) (content.x + 2*style.padding.x);
			if ((style.draw_begin) != null) style.draw_begin(this, (Handle) (style.userdata));
			DrawButtonTextSymbol(&bounds, &content, &tri, (uint) (state), style, str, (int) (len), (int) (symbol), font);
			if ((style.draw_end) != null) style.draw_end(this, (Handle) (style.userdata));
			return (int) (ret);
		}

		public void DrawButtonTextImage(Rect* bounds, Rect* label, Rect* image, uint state, StyleButton style, char* str,
			int len, UserFont font, Image img)
		{
			Text text = new Text();
			StyleItem background;
			background = DrawButton(bounds, (uint) (state), style);
			if ((background.type) == (Nuklear.NK_STYLE_ITEM_COLOR)) text.background = (Color) (background.data.color);
			else text.background = (Color) (style.text_background);
			if ((state & Nuklear.NK_WIDGET_STATE_HOVER) != 0) text.text = (Color) (style.text_hover);
			else if ((state & Nuklear.NK_WIDGET_STATE_ACTIVED) != 0) text.text = (Color) (style.text_active);
			else text.text = (Color) (style.text_normal);
			text.padding = (Vec2) (Nuklear.Vec2z((float) (0), (float) (0)));
			WidgetText((Rect) (*label), str, (int) (len), &text, (uint) (Nuklear.NK_TEXT_CENTERED), font);
			DrawImage((Rect) (*image), img, (Color) (Nuklear.nk_white));
		}

		public int DoButtonTextImage(ref uint state, Rect bounds, Image img, char* str, int len, uint align, int behavior,
			StyleButton style, UserFont font, Input _in_)
		{
			int ret;
			Rect icon = new Rect();
			Rect content = new Rect();
			if ((((font == null)) || (style == null)) || (str == null)) return (int) (Nuklear.nk_false);
			ret = (int) (DoButton(ref state, (Rect) (bounds), style, _in_, (int) (behavior), &content));
			icon.y = (float) (bounds.y + style.padding.y);
			icon.w = (float) (icon.h = (float) (bounds.h - 2*style.padding.y));
			if ((align & Nuklear.NK_TEXT_ALIGN_LEFT) != 0)
			{
				icon.x = (float) ((bounds.x + bounds.w) - (2*style.padding.x + icon.w));
				icon.x = (float) ((icon.x) < (0) ? (0) : (icon.x));
			}
			else icon.x = (float) (bounds.x + 2*style.padding.x);
			icon.x += (float) (style.image_padding.x);
			icon.y += (float) (style.image_padding.y);
			icon.w -= (float) (2*style.image_padding.x);
			icon.h -= (float) (2*style.image_padding.y);
			if ((style.draw_begin) != null) style.draw_begin(this, (Handle) (style.userdata));
			DrawButtonTextImage(&bounds, &content, &icon, (uint) (state), style, str, (int) (len), font, img);
			if ((style.draw_end) != null) style.draw_end(this, (Handle) (style.userdata));
			return (int) (ret);
		}

		public void DrawCheckbox(uint state, StyleToggle style, int active, Rect* label, Rect* selector, Rect* cursors,
			char* _string_, int len, UserFont font)
		{
			StyleItem background;
			StyleItem cursor;
			Text text = new Text();
			if ((state & Nuklear.NK_WIDGET_STATE_HOVER) != 0)
			{
				background = style.hover;
				cursor = style.cursor_hover;
				text.text = (Color) (style.text_hover);
			}
			else if ((state & Nuklear.NK_WIDGET_STATE_ACTIVED) != 0)
			{
				background = style.hover;
				cursor = style.cursor_hover;
				text.text = (Color) (style.text_active);
			}
			else
			{
				background = style.normal;
				cursor = style.cursor_normal;
				text.text = (Color) (style.text_normal);
			}

			if ((background.type) == (Nuklear.NK_STYLE_ITEM_COLOR))
			{
				FillRect((Rect) (*selector), (float) (0), (Color) (style.border_color));
				FillRect((Rect) (selector->ShrinkRectz((float) (style.border))), (float) (0), (Color) (background.data.color));
			}
			else DrawImage((Rect) (*selector), background.data.image, (Color) (Nuklear.nk_white));
			if ((active) != 0)
			{
				if ((cursor.type) == (Nuklear.NK_STYLE_ITEM_IMAGE))
					DrawImage((Rect) (*cursors), cursor.data.image, (Color) (Nuklear.nk_white));
				else FillRect((Rect) (*cursors), (float) (0), (Color) (cursor.data.color));
			}

			text.padding.x = (float) (0);
			text.padding.y = (float) (0);
			text.background = (Color) (style.text_background);
			WidgetText((Rect) (*label), _string_, (int) (len), &text, (uint) (Nuklear.NK_TEXT_LEFT), font);
		}

		public void DrawOption(uint state, StyleToggle style, int active, Rect* label, Rect* selector, Rect* cursors,
			char* _string_, int len, UserFont font)
		{
			StyleItem background;
			StyleItem cursor;
			Text text = new Text();
			if ((state & Nuklear.NK_WIDGET_STATE_HOVER) != 0)
			{
				background = style.hover;
				cursor = style.cursor_hover;
				text.text = (Color) (style.text_hover);
			}
			else if ((state & Nuklear.NK_WIDGET_STATE_ACTIVED) != 0)
			{
				background = style.hover;
				cursor = style.cursor_hover;
				text.text = (Color) (style.text_active);
			}
			else
			{
				background = style.normal;
				cursor = style.cursor_normal;
				text.text = (Color) (style.text_normal);
			}

			if ((background.type) == (Nuklear.NK_STYLE_ITEM_COLOR))
			{
				FillCircle((Rect) (*selector), (Color) (style.border_color));
				FillCircle((Rect) (selector->ShrinkRectz((float) (style.border))), (Color) (background.data.color));
			}
			else DrawImage((Rect) (*selector), background.data.image, (Color) (Nuklear.nk_white));
			if ((active) != 0)
			{
				if ((cursor.type) == (Nuklear.NK_STYLE_ITEM_IMAGE))
					DrawImage((Rect) (*cursors), cursor.data.image, (Color) (Nuklear.nk_white));
				else FillCircle((Rect) (*cursors), (Color) (cursor.data.color));
			}

			text.padding.x = (float) (0);
			text.padding.y = (float) (0);
			text.background = (Color) (style.text_background);
			WidgetText((Rect) (*label), _string_, (int) (len), &text, (uint) (Nuklear.NK_TEXT_LEFT), font);
		}

		public int DoToggle(ref uint state, Rect r, int* active, char* str, int len, int type, StyleToggle style, Input _in_,
			UserFont font)
		{
			int was_active;
			Rect bounds = new Rect();
			Rect select = new Rect();
			Rect cursor = new Rect();
			Rect label = new Rect();
			if ((((style == null)) || (font == null)) || (active == null)) return (int) (0);
			r.w = (float) ((r.w) < (font.height + 2*style.padding.x) ? (font.height + 2*style.padding.x) : (r.w));
			r.h = (float) ((r.h) < (font.height + 2*style.padding.y) ? (font.height + 2*style.padding.y) : (r.h));
			bounds.x = (float) (r.x - style.touch_padding.x);
			bounds.y = (float) (r.y - style.touch_padding.y);
			bounds.w = (float) (r.w + 2*style.touch_padding.x);
			bounds.h = (float) (r.h + 2*style.touch_padding.y);
			select.w = (float) (font.height);
			select.h = (float) (select.w);
			select.y = (float) (r.y + r.h/2.0f - select.h/2.0f);
			select.x = (float) (r.x);
			cursor.x = (float) (select.x + style.padding.x + style.border);
			cursor.y = (float) (select.y + style.padding.y + style.border);
			cursor.w = (float) (select.w - (2*style.padding.x + 2*style.border));
			cursor.h = (float) (select.h - (2*style.padding.y + 2*style.border));
			label.x = (float) (select.x + select.w + style.spacing);
			label.y = (float) (select.y);
			label.w = (float) (((r.x + r.w) < (label.x) ? (label.x) : (r.x + r.w)) - label.x);
			label.h = (float) (select.w);
			was_active = (int) (*active);

			if (_in_ != null)
			{
				*active = (int) (_in_.ToggleBehavior((Rect) (bounds), ref state, (int) (*active)));
			}
			else
			{
				*active = 0;
			}
			if ((style.draw_begin) != null) style.draw_begin(this, (Handle) (style.userdata));
			if ((type) == (Nuklear.NK_TOGGLE_CHECK))
			{
				DrawCheckbox((uint) (state), style, (int) (*active), &label, &select, &cursor, str, (int) (len), font);
			}
			else
			{
				DrawOption((uint) (state), style, (int) (*active), &label, &select, &cursor, str, (int) (len), font);
			}

			if ((style.draw_end) != null) style.draw_end(this, (Handle) (style.userdata));
			return was_active != *active ? 1 : 0;
		}

		public void DrawSelectable(uint state, StyleSelectable style, int active, Rect* bounds, Rect* icon, Image img,
			char* _string_, int len, uint align, UserFont font)
		{
			StyleItem background;
			Text text = new Text();
			text.padding = (Vec2) (style.padding);
			if (active == 0)
			{
				if ((state & Nuklear.NK_WIDGET_STATE_ACTIVED) != 0)
				{
					background = style.pressed;
					text.text = (Color) (style.text_pressed);
				}
				else if ((state & Nuklear.NK_WIDGET_STATE_HOVER) != 0)
				{
					background = style.hover;
					text.text = (Color) (style.text_hover);
				}
				else
				{
					background = style.normal;
					text.text = (Color) (style.text_normal);
				}
			}
			else
			{
				if ((state & Nuklear.NK_WIDGET_STATE_ACTIVED) != 0)
				{
					background = style.pressed_active;
					text.text = (Color) (style.text_pressed_active);
				}
				else if ((state & Nuklear.NK_WIDGET_STATE_HOVER) != 0)
				{
					background = style.hover_active;
					text.text = (Color) (style.text_hover_active);
				}
				else
				{
					background = style.normal_active;
					text.text = (Color) (style.text_normal_active);
				}
			}

			if ((background.type) == (Nuklear.NK_STYLE_ITEM_IMAGE))
			{
				DrawImage((Rect) (*bounds), background.data.image, (Color) (Nuklear.nk_white));
				text.background = (Color) (Nuklear.Rgba((int) (0), (int) (0), (int) (0), (int) (0)));
			}
			else
			{
				FillRect((Rect) (*bounds), (float) (style.rounding), (Color) (background.data.color));
				text.background = (Color) (background.data.color);
			}

			if (((img) != null) && ((icon) != null)) DrawImage((Rect) (*icon), img, (Color) (Nuklear.nk_white));
			WidgetText((Rect) (*bounds), _string_, (int) (len), &text, (uint) (align), font);
		}

		public int DoSelectable(ref uint state, Rect bounds, char* str, int len, uint align, ref int value,
			StyleSelectable style, Input _in_, UserFont font)
		{
			int old_value;
			Rect touch = new Rect();
			if (((((((state == null) || (this == null)) || (str == null)) || (len == 0)) || (value == null)) || (style == null)) ||
			    (font == null)) return (int) (0);
			old_value = (int) (value);
			touch.x = (float) (bounds.x - style.touch_padding.x);
			touch.y = (float) (bounds.y - style.touch_padding.y);
			touch.w = (float) (bounds.w + style.touch_padding.x*2);
			touch.h = (float) (bounds.h + style.touch_padding.y*2);
			if ((touch.ButtonBehavior(ref state, _in_, (int) (Nuklear.NK_BUTTON_DEFAULT))) != 0) value = value != 0 ? 0 : 1;
			if ((style.draw_begin) != null) style.draw_begin(this, (Handle) (style.userdata));
			DrawSelectable((uint) (state), style, (int) (value), &bounds, null, null, str, (int) (len), (uint) (align), font);
			if ((style.draw_end) != null) style.draw_end(this, (Handle) (style.userdata));
			return old_value != value ? 1 : 0;
		}

		public int DoSelectableImage(ref uint state, Rect bounds, char* str, int len, uint align, ref int value, Image img,
			StyleSelectable style, Input _in_, UserFont font)
		{
			int old_value;
			Rect touch = new Rect();
			Rect icon = new Rect();
			if (((((((state == null) || (this == null)) || (str == null)) || (len == 0)) || (value == null)) || (style == null)) ||
			    (font == null)) return (int) (0);
			old_value = (int) (value);
			touch.x = (float) (bounds.x - style.touch_padding.x);
			touch.y = (float) (bounds.y - style.touch_padding.y);
			touch.w = (float) (bounds.w + style.touch_padding.x*2);
			touch.h = (float) (bounds.h + style.touch_padding.y*2);
			if ((touch.ButtonBehavior(ref state, _in_, (int) (Nuklear.NK_BUTTON_DEFAULT))) != 0) value = value != 0 ? 0 : 1;
			icon.y = (float) (bounds.y + style.padding.y);
			icon.w = (float) (icon.h = (float) (bounds.h - 2*style.padding.y));
			if ((align & Nuklear.NK_TEXT_ALIGN_LEFT) != 0)
			{
				icon.x = (float) ((bounds.x + bounds.w) - (2*style.padding.x + icon.w));
				icon.x = (float) ((icon.x) < (0) ? (0) : (icon.x));
			}
			else icon.x = (float) (bounds.x + 2*style.padding.x);
			icon.x += (float) (style.image_padding.x);
			icon.y += (float) (style.image_padding.y);
			icon.w -= (float) (2*style.image_padding.x);
			icon.h -= (float) (2*style.image_padding.y);
			if ((style.draw_begin) != null) style.draw_begin(this, (Handle) (style.userdata));
			DrawSelectable((uint) (state), style, (int) (value), &bounds, &icon, img, str, (int) (len), (uint) (align), font);
			if ((style.draw_end) != null) style.draw_end(this, (Handle) (style.userdata));
			return old_value != value ? 1 : 0;
		}

		public void DrawSlider(uint state, StyleSlider style, Rect* bounds, Rect* visual_cursor, float min, float value,
			float max)
		{
			Rect fill = new Rect();
			Rect bar = new Rect();
			StyleItem background;
			Color bar_color = new Color();
			StyleItem cursor;
			if ((state & Nuklear.NK_WIDGET_STATE_ACTIVED) != 0)
			{
				background = style.active;
				bar_color = (Color) (style.bar_active);
				cursor = style.cursor_active;
			}
			else if ((state & Nuklear.NK_WIDGET_STATE_HOVER) != 0)
			{
				background = style.hover;
				bar_color = (Color) (style.bar_hover);
				cursor = style.cursor_hover;
			}
			else
			{
				background = style.normal;
				bar_color = (Color) (style.bar_normal);
				cursor = style.cursor_normal;
			}

			bar.x = (float) (bounds->x);
			bar.y = (float) ((visual_cursor->y + visual_cursor->h/2) - bounds->h/12);
			bar.w = (float) (bounds->w);
			bar.h = (float) (bounds->h/6);
			fill.w = (float) ((visual_cursor->x + (visual_cursor->w/2.0f)) - bar.x);
			fill.x = (float) (bar.x);
			fill.y = (float) (bar.y);
			fill.h = (float) (bar.h);
			if ((background.type) == (Nuklear.NK_STYLE_ITEM_IMAGE))
			{
				DrawImage((Rect) (*bounds), background.data.image, (Color) (Nuklear.nk_white));
			}
			else
			{
				FillRect((Rect) (*bounds), (float) (style.rounding), (Color) (background.data.color));
				StrokeRect((Rect) (*bounds), (float) (style.rounding), (float) (style.border), (Color) (style.border_color));
			}

			FillRect((Rect) (bar), (float) (style.rounding), (Color) (bar_color));
			FillRect((Rect) (fill), (float) (style.rounding), (Color) (style.bar_filled));
			if ((cursor.type) == (Nuklear.NK_STYLE_ITEM_IMAGE))
				DrawImage((Rect) (*visual_cursor), cursor.data.image, (Color) (Nuklear.nk_white));
			else FillCircle((Rect) (*visual_cursor), (Color) (cursor.data.color));
		}

		public float DoSlider(ref uint state, Rect bounds, float min, float val, float max, float step, StyleSlider style,
			Input _in_, UserFont font)
		{
			float slider_range;
			float slider_min;
			float slider_max;
			float slider_value;
			float slider_steps;
			float cursor_offset;
			Rect visual_cursor = new Rect();
			Rect logical_cursor = new Rect();
			if ((style == null)) return (float) (0);
			bounds.x = (float) (bounds.x + style.padding.x);
			bounds.y = (float) (bounds.y + style.padding.y);
			bounds.h = (float) ((bounds.h) < (2*style.padding.y) ? (2*style.padding.y) : (bounds.h));
			bounds.w =
				(float)
					((bounds.w) < (2*style.padding.x + style.cursor_size.x) ? (2*style.padding.x + style.cursor_size.x) : (bounds.w));
			bounds.w -= (float) (2*style.padding.x);
			bounds.h -= (float) (2*style.padding.y);
			if ((style.show_buttons) != 0)
			{
				uint ws = 0;
				Rect button = new Rect();
				button.y = (float) (bounds.y);
				button.w = (float) (bounds.h);
				button.h = (float) (bounds.h);
				button.x = (float) (bounds.x);
				if (
					(DoButtonSymbol(ref ws, (Rect) (button), (int) (style.dec_symbol), (int) (Nuklear.NK_BUTTON_DEFAULT),
						style.dec_button, _in_, font)) != 0) val -= (float) (step);
				button.x = (float) ((bounds.x + bounds.w) - button.w);
				if (
					(DoButtonSymbol(ref ws, (Rect) (button), (int) (style.inc_symbol), (int) (Nuklear.NK_BUTTON_DEFAULT),
						style.inc_button, _in_, font)) != 0) val += (float) (step);
				bounds.x = (float) (bounds.x + button.w + style.spacing.x);
				bounds.w = (float) (bounds.w - (2*button.w + 2*style.spacing.x));
			}

			bounds.x += (float) (style.cursor_size.x*0.5f);
			bounds.w -= (float) (style.cursor_size.x);
			slider_max = (float) ((min) < (max) ? (max) : (min));
			slider_min = (float) ((min) < (max) ? (min) : (max));
			slider_value =
				(float)
					(((val) < (slider_max) ? (val) : (slider_max)) < (slider_min)
						? (slider_min)
						: ((val) < (slider_max) ? (val) : (slider_max)));
			slider_range = (float) (slider_max - slider_min);
			slider_steps = (float) (slider_range/step);
			cursor_offset = (float) ((slider_value - slider_min)/step);
			logical_cursor.h = (float) (bounds.h);
			logical_cursor.w = (float) (bounds.w/slider_steps);
			logical_cursor.x = (float) (bounds.x + (logical_cursor.w*cursor_offset));
			logical_cursor.y = (float) (bounds.y);
			visual_cursor.h = (float) (style.cursor_size.y);
			visual_cursor.w = (float) (style.cursor_size.x);
			visual_cursor.y = (float) ((bounds.y + bounds.h*0.5f) - visual_cursor.h*0.5f);
			visual_cursor.x = (float) (logical_cursor.x - visual_cursor.w*0.5f);
			slider_value =
				(float)
					(logical_cursor.SliderBehavior(ref state, &visual_cursor, _in_, (Rect) (bounds), (float) (slider_min),
						(float) (slider_max), (float) (slider_value), (float) (step), (float) (slider_steps)));
			visual_cursor.x = (float) (logical_cursor.x - visual_cursor.w*0.5f);
			if ((style.draw_begin) != null) style.draw_begin(this, (Handle) (style.userdata));
			DrawSlider((uint) (state), style, &bounds, &visual_cursor, (float) (slider_min), (float) (slider_value),
				(float) (slider_max));
			if ((style.draw_end) != null) style.draw_end(this, (Handle) (style.userdata));
			return (float) (slider_value);
		}

		public void DrawProgress(uint state, StyleProgress style, Rect* bounds, Rect* scursor, ulong value, ulong max)
		{
			StyleItem background;
			StyleItem cursor;
			if ((state & Nuklear.NK_WIDGET_STATE_ACTIVED) != 0)
			{
				background = style.active;
				cursor = style.cursor_active;
			}
			else if ((state & Nuklear.NK_WIDGET_STATE_HOVER) != 0)
			{
				background = style.hover;
				cursor = style.cursor_hover;
			}
			else
			{
				background = style.normal;
				cursor = style.cursor_normal;
			}

			if ((background.type) == (Nuklear.NK_STYLE_ITEM_COLOR))
			{
				FillRect((Rect) (*bounds), (float) (style.rounding), (Color) (background.data.color));
				StrokeRect((Rect) (*bounds), (float) (style.rounding), (float) (style.border), (Color) (style.border_color));
			}
			else DrawImage((Rect) (*bounds), background.data.image, (Color) (Nuklear.nk_white));
			if ((cursor.type) == (Nuklear.NK_STYLE_ITEM_COLOR))
			{
				FillRect((Rect) (*scursor), (float) (style.rounding), (Color) (cursor.data.color));
				StrokeRect((Rect) (*scursor), (float) (style.rounding), (float) (style.border), (Color) (style.border_color));
			}
			else DrawImage((Rect) (*scursor), cursor.data.image, (Color) (Nuklear.nk_white));
		}

		public ulong DoProgress(ref uint state, Rect bounds, ulong value, ulong max, int modifiable, StyleProgress style,
			Input _in_)
		{
			float prog_scale;
			ulong prog_value;
			Rect cursor = new Rect();
			if ((style == null)) return (ulong) (0);
			cursor.w =
				(float) ((bounds.w) < (2*style.padding.x + 2*style.border) ? (2*style.padding.x + 2*style.border) : (bounds.w));
			cursor.h =
				(float) ((bounds.h) < (2*style.padding.y + 2*style.border) ? (2*style.padding.y + 2*style.border) : (bounds.h));
			cursor =
				(Rect)
					(bounds.PadRect(
						(Vec2) (Nuklear.Vec2z((float) (style.padding.x + style.border), (float) (style.padding.y + style.border)))));
			prog_scale = (float) ((float) (value)/(float) (max));
			prog_value = (ulong) ((value) < (max) ? (value) : (max));
			prog_value =
				(ulong)
					(_in_.ProgressBehavior(ref state, (Rect) (bounds), (Rect) (cursor), (ulong) (max), (ulong) (prog_value),
						(int) (modifiable)));
			cursor.w = (float) (cursor.w*prog_scale);
			if ((style.draw_begin) != null) style.draw_begin(this, (Handle) (style.userdata));
			DrawProgress((uint) (state), style, &bounds, &cursor, (ulong) (value), (ulong) (max));
			if ((style.draw_end) != null) style.draw_end(this, (Handle) (style.userdata));
			return (ulong) (prog_value);
		}

		public void DrawScrollbar(uint state, StyleScrollbar style, Rect* bounds, Rect* scroll)
		{
			StyleItem background;
			StyleItem cursor;
			if ((state & Nuklear.NK_WIDGET_STATE_ACTIVED) != 0)
			{
				background = style.active;
				cursor = style.cursor_active;
			}
			else if ((state & Nuklear.NK_WIDGET_STATE_HOVER) != 0)
			{
				background = style.hover;
				cursor = style.cursor_hover;
			}
			else
			{
				background = style.normal;
				cursor = style.cursor_normal;
			}

			if ((background.type) == (Nuklear.NK_STYLE_ITEM_COLOR))
			{
				FillRect((Rect) (*bounds), (float) (style.rounding), (Color) (background.data.color));
				StrokeRect((Rect) (*bounds), (float) (style.rounding), (float) (style.border), (Color) (style.border_color));
			}
			else
			{
				DrawImage((Rect) (*bounds), background.data.image, (Color) (Nuklear.nk_white));
			}

			if ((background.type) == (Nuklear.NK_STYLE_ITEM_COLOR))
			{
				FillRect((Rect) (*scroll), (float) (style.rounding_cursor), (Color) (cursor.data.color));
				StrokeRect((Rect) (*scroll), (float) (style.rounding_cursor), (float) (style.border_cursor),
					(Color) (style.cursor_border_color));
			}
			else DrawImage((Rect) (*scroll), cursor.data.image, (Color) (Nuklear.nk_white));
		}

		public float DoScrollbarv(ref uint state, Rect scroll, int has_scrolling, float offset, float target, float step,
			float button_pixel_inc, StyleScrollbar style, Input _in_, UserFont font)
		{
			Rect empty_north = new Rect();
			Rect empty_south = new Rect();
			Rect cursor = new Rect();
			float scroll_step;
			float scroll_offset;
			float scroll_off;
			float scroll_ratio;
			if ((style == null)) return (float) (0);
			scroll.w = (float) ((scroll.w) < (1) ? (1) : (scroll.w));
			scroll.h = (float) ((scroll.h) < (0) ? (0) : (scroll.h));
			if (target <= scroll.h) return (float) (0);
			if ((style.show_buttons) != 0)
			{
				uint ws = 0;
				float scroll_h;
				Rect button = new Rect();
				button.x = (float) (scroll.x);
				button.w = (float) (scroll.w);
				button.h = (float) (scroll.w);
				scroll_h = (float) ((scroll.h - 2*button.h) < (0) ? (0) : (scroll.h - 2*button.h));
				scroll_step = (float) ((step) < (button_pixel_inc) ? (step) : (button_pixel_inc));
				button.y = (float) (scroll.y);
				if (
					(DoButtonSymbol(ref ws, (Rect) (button), (int) (style.dec_symbol), (int) (Nuklear.NK_BUTTON_REPEATER),
						style.dec_button, _in_, font)) != 0) offset = (float) (offset - scroll_step);
				button.y = (float) (scroll.y + scroll.h - button.h);
				if (
					(DoButtonSymbol(ref ws, (Rect) (button), (int) (style.inc_symbol), (int) (Nuklear.NK_BUTTON_REPEATER),
						style.inc_button, _in_, font)) != 0) offset = (float) (offset + scroll_step);
				scroll.y = (float) (scroll.y + button.h);
				scroll.h = (float) (scroll_h);
			}

			scroll_step = (float) ((step) < (scroll.h) ? (step) : (scroll.h));
			scroll_offset =
				(float)
					(((offset) < (target - scroll.h) ? (offset) : (target - scroll.h)) < (0)
						? (0)
						: ((offset) < (target - scroll.h) ? (offset) : (target - scroll.h)));
			scroll_ratio = (float) (scroll.h/target);
			scroll_off = (float) (scroll_offset/target);
			cursor.h =
				(float)
					(((scroll_ratio*scroll.h) - (2*style.border + 2*style.padding.y)) < (0)
						? (0)
						: ((scroll_ratio*scroll.h) - (2*style.border + 2*style.padding.y)));
			cursor.y = (float) (scroll.y + (scroll_off*scroll.h) + style.border + style.padding.y);
			cursor.w = (float) (scroll.w - (2*style.border + 2*style.padding.x));
			cursor.x = (float) (scroll.x + style.border + style.padding.x);
			empty_north.x = (float) (scroll.x);
			empty_north.y = (float) (scroll.y);
			empty_north.w = (float) (scroll.w);
			empty_north.h = (float) ((cursor.y - scroll.y) < (0) ? (0) : (cursor.y - scroll.y));
			empty_south.x = (float) (scroll.x);
			empty_south.y = (float) (cursor.y + cursor.h);
			empty_south.w = (float) (scroll.w);
			empty_south.h =
				(float)
					(((scroll.y + scroll.h) - (cursor.y + cursor.h)) < (0) ? (0) : ((scroll.y + scroll.h) - (cursor.y + cursor.h)));
			scroll_offset =
				(float)
					(_in_.ScrollbarBehavior(ref state, (int) (has_scrolling), &scroll, ref cursor, &empty_north, &empty_south,
						(float) (scroll_offset), (float) (target), (float) (scroll_step), (int) (Nuklear.NK_VERTICAL)));
			scroll_off = (float) (scroll_offset/target);
			cursor.y = (float) (scroll.y + (scroll_off*scroll.h) + style.border_cursor + style.padding.y);
			if ((style.draw_begin) != null) style.draw_begin(this, (Handle) (style.userdata));
			DrawScrollbar((uint) (state), style, &scroll, &cursor);
			if ((style.draw_end) != null) style.draw_end(this, (Handle) (style.userdata));
			return (float) (scroll_offset);
		}

		public float DoScrollbarh(ref uint state, Rect scroll, int has_scrolling, float offset, float target, float step,
			float button_pixel_inc, StyleScrollbar style, Input _in_, UserFont font)
		{
			Rect cursor = new Rect();
			Rect empty_west = new Rect();
			Rect empty_east = new Rect();
			float scroll_step;
			float scroll_offset;
			float scroll_off;
			float scroll_ratio;
			if ((style == null)) return (float) (0);
			scroll.h = (float) ((scroll.h) < (1) ? (1) : (scroll.h));
			scroll.w = (float) ((scroll.w) < (2*scroll.h) ? (2*scroll.h) : (scroll.w));
			if (target <= scroll.w) return (float) (0);
			if ((style.show_buttons) != 0)
			{
				uint ws = 0;
				float scroll_w;
				Rect button = new Rect();
				button.y = (float) (scroll.y);
				button.w = (float) (scroll.h);
				button.h = (float) (scroll.h);
				scroll_w = (float) (scroll.w - 2*button.w);
				scroll_step = (float) ((step) < (button_pixel_inc) ? (step) : (button_pixel_inc));
				button.x = (float) (scroll.x);
				if (
					(DoButtonSymbol(ref ws, (Rect) (button), (int) (style.dec_symbol), (int) (Nuklear.NK_BUTTON_REPEATER),
						style.dec_button, _in_, font)) != 0) offset = (float) (offset - scroll_step);
				button.x = (float) (scroll.x + scroll.w - button.w);
				if (
					(DoButtonSymbol(ref ws, (Rect) (button), (int) (style.inc_symbol), (int) (Nuklear.NK_BUTTON_REPEATER),
						style.inc_button, _in_, font)) != 0) offset = (float) (offset + scroll_step);
				scroll.x = (float) (scroll.x + button.w);
				scroll.w = (float) (scroll_w);
			}

			scroll_step = (float) ((step) < (scroll.w) ? (step) : (scroll.w));
			scroll_offset =
				(float)
					(((offset) < (target - scroll.w) ? (offset) : (target - scroll.w)) < (0)
						? (0)
						: ((offset) < (target - scroll.w) ? (offset) : (target - scroll.w)));
			scroll_ratio = (float) (scroll.w/target);
			scroll_off = (float) (scroll_offset/target);
			cursor.w = (float) ((scroll_ratio*scroll.w) - (2*style.border + 2*style.padding.x));
			cursor.x = (float) (scroll.x + (scroll_off*scroll.w) + style.border + style.padding.x);
			cursor.h = (float) (scroll.h - (2*style.border + 2*style.padding.y));
			cursor.y = (float) (scroll.y + style.border + style.padding.y);
			empty_west.x = (float) (scroll.x);
			empty_west.y = (float) (scroll.y);
			empty_west.w = (float) (cursor.x - scroll.x);
			empty_west.h = (float) (scroll.h);
			empty_east.x = (float) (cursor.x + cursor.w);
			empty_east.y = (float) (scroll.y);
			empty_east.w = (float) ((scroll.x + scroll.w) - (cursor.x + cursor.w));
			empty_east.h = (float) (scroll.h);
			scroll_offset =
				(float)
					(_in_.ScrollbarBehavior(ref state, (int) (has_scrolling), &scroll, ref cursor, &empty_west, &empty_east,
						(float) (scroll_offset), (float) (target), (float) (scroll_step), (int) (Nuklear.NK_HORIZONTAL)));
			scroll_off = (float) (scroll_offset/target);
			cursor.x = (float) (scroll.x + (scroll_off*scroll.w));
			if ((style.draw_begin) != null) style.draw_begin(this, (Handle) (style.userdata));
			DrawScrollbar((uint) (state), style, &scroll, &cursor);
			if ((style.draw_end) != null) style.draw_end(this, (Handle) (style.userdata));
			return (float) (scroll_offset);
		}

		public void EditDrawText(StyleEdit style, float pos_x, float pos_y, float x_offset, char* text, int byte_len,
			float row_height, UserFont font, Color background, Color foreground, int is_selected)
		{
			if ((((text == null) || (byte_len == 0)) || (this == null)) || (style == null)) return;
			{
				int glyph_len = (int) (0);
				char unicode = (char) 0;
				int text_len = (int) (0);
				float line_width = (float) (0);
				float glyph_width;
				char* line = text;
				float line_offset = (float) (0);
				int line_count = (int) (0);
				Text txt = new Text();
				txt.padding = (Vec2) (Nuklear.Vec2z((float) (0), (float) (0)));
				txt.background = (Color) (background);
				txt.text = (Color) (foreground);
				glyph_len = (int) (Nuklear.UtfDecode(text + text_len, &unicode, (int) (byte_len - text_len)));
				if (glyph_len == 0) return;
				while (((text_len) < (byte_len)) && ((glyph_len) != 0))
				{
					if ((unicode) == ('\n'))
					{
						Rect label = new Rect();
						label.y = (float) (pos_y + line_offset);
						label.h = (float) (row_height);
						label.w = (float) (line_width);
						label.x = (float) (pos_x);
						if (line_count == 0) label.x += (float) (x_offset);
						if ((is_selected) != 0) FillRect((Rect) (label), (float) (0), (Color) (background));
						WidgetText((Rect) (label), line, (int) ((text + text_len) - line), &txt, (uint) (Nuklear.NK_TEXT_CENTERED), font);
						text_len++;
						line_count++;
						line_width = (float) (0);
						line = text + text_len;
						line_offset += (float) (row_height);
						glyph_len = (int) (Nuklear.UtfDecode(text + text_len, &unicode, (int) (byte_len - text_len)));
						continue;
					}
					if ((unicode) == ('\r'))
					{
						text_len++;
						glyph_len = (int) (Nuklear.UtfDecode(text + text_len, &unicode, (int) (byte_len - text_len)));
						continue;
					}
					glyph_width =
						(float) (font.width((Handle) (font.userdata), (float) (font.height), text + text_len, (int) (glyph_len)));
					line_width += (float) (glyph_width);
					text_len += (int) (glyph_len);
					glyph_len = (int) (Nuklear.UtfDecode(text + text_len, &unicode, (int) (byte_len - text_len)));
					continue;
				}
				if ((line_width) > (0))
				{
					Rect label = new Rect();
					label.y = (float) (pos_y + line_offset);
					label.h = (float) (row_height);
					label.w = (float) (line_width);
					label.x = (float) (pos_x);
					if (line_count == 0) label.x += (float) (x_offset);
					if ((is_selected) != 0) FillRect((Rect) (label), (float) (0), (Color) (background));
					WidgetText((Rect) (label), line, (int) ((text + text_len) - line), &txt, (uint) (Nuklear.NK_TEXT_LEFT), font);
				}
			}

		}

		public uint DoEdit(ref uint state, Rect bounds, uint flags, Nuklear.NkPluginFilter filter, TextEdit edit,
			StyleEdit style, Input _in_, UserFont font)
		{
			Rect area = new Rect();
			uint ret = (uint) (0);
			float row_height;
			sbyte prev_state = (sbyte) (0);
			sbyte is_hovered = (sbyte) (0);
			sbyte select_all = (sbyte) (0);
			sbyte cursor_follow = (sbyte) (0);
			Rect old_clip = new Rect();
			Rect clip = new Rect();
			if (((state == null) || (this == null)) || (style == null)) return (uint) (ret);
			area.x = (float) (bounds.x + style.padding.x + style.border);
			area.y = (float) (bounds.y + style.padding.y + style.border);
			area.w = (float) (bounds.w - (2.0f*style.padding.x + 2*style.border));
			area.h = (float) (bounds.h - (2.0f*style.padding.y + 2*style.border));
			if ((flags & Nuklear.NK_EDIT_MULTILINE) != 0)
				area.w = (float) ((0) < (area.w - style.scrollbar_size.x) ? (area.w - style.scrollbar_size.x) : (0));
			row_height = (float) ((flags & Nuklear.NK_EDIT_MULTILINE) != 0 ? font.height + style.row_padding : area.h);
			old_clip = (Rect) (this.clip);
			clip.Unify(ref old_clip, (float) (area.x), (float) (area.y), (float) (area.x + area.w), (float) (area.y + area.h));
			prev_state = ((sbyte) (edit.active));
			if (_in_ != null)
			{
				is_hovered = ((sbyte) (_in_.IsMouseHoveringRect((Rect) (bounds))));
			}
			 
			if ((((_in_) != null) && ((((MouseButton*) _in_.mouse.buttons + Nuklear.NK_BUTTON_LEFT)->clicked) != 0)) &&
			    ((((MouseButton*) _in_.mouse.buttons + Nuklear.NK_BUTTON_LEFT)->down) != 0))
			{
				edit.active =
					(byte)
						((((bounds.x) <= (_in_.mouse.pos.x)) && ((_in_.mouse.pos.x) < (bounds.x + bounds.w))) &&
						 (((bounds.y) <= (_in_.mouse.pos.y)) && ((_in_.mouse.pos.y) < (bounds.y + bounds.h)))
							? 1
							: 0);
			}

			if ((prev_state == 0) && ((edit.active) != 0))
			{
				int type =
					(int)
						((flags & Nuklear.NK_EDIT_MULTILINE) != 0 ? Nuklear.NK_TEXT_EDIT_MULTI_LINE : Nuklear.NK_TEXT_EDIT_SINGLE_LINE);
				edit.ClearState((int) (type), filter);
				if ((flags & Nuklear.NK_EDIT_AUTO_SELECT) != 0) select_all = (sbyte) (Nuklear.nk_true);
				if ((flags & Nuklear.NK_EDIT_GOTO_END_ON_ACTIVATE) != 0)
				{
					edit.cursor = (int) (edit._string_.len);
					_in_ = null;
				}
			}
			else if (edit.active == 0) edit.mode = (byte) (Nuklear.NK_TEXT_EDIT_MODE_VIEW);
			if ((flags & Nuklear.NK_EDIT_READ_ONLY) != 0) edit.mode = (byte) (Nuklear.NK_TEXT_EDIT_MODE_VIEW);
			else if ((flags & Nuklear.NK_EDIT_ALWAYS_INSERT_MODE) != 0) edit.mode = (byte) (Nuklear.NK_TEXT_EDIT_MODE_INSERT);
			ret = (uint) ((edit.active) != 0 ? Nuklear.NK_EDIT_ACTIVE : Nuklear.NK_EDIT_INACTIVE);
			if (prev_state != edit.active)
				ret |= (uint) ((edit.active) != 0 ? Nuklear.NK_EDIT_ACTIVATED : Nuklear.NK_EDIT_DEACTIVATED);
			if (((edit.active) != 0) && ((_in_) != null))
			{
				int shift_mod = (int) (_in_.keyboard.keys[Nuklear.NK_KEY_SHIFT].down);
				float mouse_x = (float) ((_in_.mouse.pos.x - area.x) + edit.scrollbar.x);
				float mouse_y = (float) ((_in_.mouse.pos.y - area.y) + edit.scrollbar.y);
				is_hovered = ((sbyte) (_in_.IsMouseHoveringRect((Rect) (area))));
				if ((select_all) != 0)
				{
					edit.SelectAll();
				}
				else if ((((is_hovered) != 0) && ((((MouseButton*) _in_.mouse.buttons + Nuklear.NK_BUTTON_LEFT)->down) != 0)) &&
				         ((((MouseButton*) _in_.mouse.buttons + Nuklear.NK_BUTTON_LEFT)->clicked) != 0))
				{
					edit.Click((float) (mouse_x), (float) (mouse_y), font, (float) (row_height));
				}
				else if ((((is_hovered) != 0) && ((((MouseButton*) _in_.mouse.buttons + Nuklear.NK_BUTTON_LEFT)->down) != 0)) &&
				         ((_in_.mouse.delta.x != 0.0f) || (_in_.mouse.delta.y != 0.0f)))
				{
					edit.Drag((float) (mouse_x), (float) (mouse_y), font, (float) (row_height));
					cursor_follow = (sbyte) (Nuklear.nk_true);
				}
				else if ((((is_hovered) != 0) && ((_in_.mouse.buttons[Nuklear.NK_BUTTON_RIGHT].clicked) != 0)) &&
				         ((_in_.mouse.buttons[Nuklear.NK_BUTTON_RIGHT].down) != 0))
				{
					edit.Key((int) (Nuklear.NK_KEY_TEXT_WORD_LEFT), (int) (Nuklear.nk_false), font, (float) (row_height));
					edit.Key((int) (Nuklear.NK_KEY_TEXT_WORD_RIGHT), (int) (Nuklear.nk_true), font, (float) (row_height));
					cursor_follow = (sbyte) (Nuklear.nk_true);
				}
				{
					int i;
					int old_mode = (int) (edit.mode);
					for (i = (int) (0); (i) < (Nuklear.NK_KEY_MAX); ++i)
					{
						if (((i) == (Nuklear.NK_KEY_ENTER)) || ((i) == (Nuklear.NK_KEY_TAB))) continue;
						if ((_in_.IsKeyPressed((int) (i))) != 0)
						{
							edit.Key((int) (i), (int) (shift_mod), font, (float) (row_height));
							cursor_follow = (sbyte) (Nuklear.nk_true);
						}
					}
					if (old_mode != edit.mode)
					{
						_in_.keyboard.text_len = (int) (0);
					}
				}
				edit.filter = filter;
				if ((_in_.keyboard.text_len) != 0)
				{
					edit.Text(_in_.keyboard.text, (int) (_in_.keyboard.text_len));
					cursor_follow = (sbyte) (Nuklear.nk_true);
					_in_.keyboard.text_len = (int) (0);
				}
				if ((_in_.IsKeyPressed((int) (Nuklear.NK_KEY_ENTER))) != 0)
				{
					cursor_follow = (sbyte) (Nuklear.nk_true);
					if (((flags & Nuklear.NK_EDIT_CTRL_ENTER_NEWLINE) != 0) && ((shift_mod) != 0)) edit.Text("\n", (int) (1));
					else if ((flags & Nuklear.NK_EDIT_SIG_ENTER) != 0) ret |= (uint) (Nuklear.NK_EDIT_COMMITED);
					else edit.Text("\n", (int) (1));
				}
				{
					int copy = (int) (_in_.IsKeyPressed((int) (Nuklear.NK_KEY_COPY)));
					int cut = (int) (_in_.IsKeyPressed((int) (Nuklear.NK_KEY_CUT)));
					if ((((copy) != 0) || ((cut) != 0)) && ((flags & Nuklear.NK_EDIT_CLIPBOARD) != 0))
					{
						int glyph_len = 0;
						char unicode;
						char* text;
						int b = (int) (edit.select_start);
						int e = (int) (edit.select_end);
						int begin = (int) ((b) < (e) ? (b) : (e));
						int end = (int) ((b) < (e) ? (e) : (b));
						text = edit._string_.AtConst((int) (begin), &unicode, ref glyph_len);
						if ((edit.clip.copy) != null) edit.clip.copy((Handle) (edit.clip.userdata), text, (int) (end - begin));
						if (((cut) != 0) && ((flags & Nuklear.NK_EDIT_READ_ONLY) == 0))
						{
							edit.Cut();
							cursor_follow = (sbyte) (Nuklear.nk_true);
						}
					}
				}
				{
					int paste = (int) (_in_.IsKeyPressed((int) (Nuklear.NK_KEY_PASTE)));
					if ((((paste) != 0) && ((flags & Nuklear.NK_EDIT_CLIPBOARD) != 0)) && ((edit.clip.paste) != null))
					{
						edit.clip.paste((Handle) (edit.clip.userdata), edit);
						cursor_follow = (sbyte) (Nuklear.nk_true);
					}
				}
				{
					int tab = (int) (_in_.IsKeyPressed((int) (Nuklear.NK_KEY_TAB)));
					if (((tab) != 0) && ((flags & Nuklear.NK_EDIT_ALLOW_TAB) != 0))
					{
						edit.Text("    ", (int) (4));
						cursor_follow = (sbyte) (Nuklear.nk_true);
					}
				}
			}

			if ((edit.active) != 0) state = (uint) (Nuklear.NK_WIDGET_STATE_ACTIVE);
			else if (((state) & Nuklear.NK_WIDGET_STATE_MODIFIED) != 0)
				(state) = (uint) (Nuklear.NK_WIDGET_STATE_INACTIVE | Nuklear.NK_WIDGET_STATE_MODIFIED);
			else (state) = (uint) (Nuklear.NK_WIDGET_STATE_INACTIVE);
			if ((is_hovered) != 0) state |= (uint) (Nuklear.NK_WIDGET_STATE_HOVERED);
			{
				char* text = edit._string_.GetConst();
				int len = (int) (edit._string_.LenChar());
				{
					StyleItem background;
					if ((state & Nuklear.NK_WIDGET_STATE_ACTIVED) != 0) background = style.active;
					else if ((state & Nuklear.NK_WIDGET_STATE_HOVER) != 0) background = style.hover;
					else background = style.normal;
					if ((background.type) == (Nuklear.NK_STYLE_ITEM_COLOR))
					{
						StrokeRect((Rect) (bounds), (float) (style.rounding), (float) (style.border), (Color) (style.border_color));
						FillRect((Rect) (bounds), (float) (style.rounding), (Color) (background.data.color));
					}
					else DrawImage((Rect) (bounds), background.data.image, (Color) (Nuklear.nk_white));
				}
				area.w = (float) ((0) < (area.w - style.cursor_size) ? (area.w - style.cursor_size) : (0));
				if ((edit.active) != 0)
				{
					int total_lines = (int) (1);
					Vec2 text_size = (Vec2) (Nuklear.Vec2z((float) (0), (float) (0)));
					char* cursor_ptr = null;
					char* select_begin_ptr = null;
					char* select_end_ptr = null;
					Vec2 cursor_pos = (Vec2) (Nuklear.Vec2z((float) (0), (float) (0)));
					Vec2 selection_offset_start = (Vec2) (Nuklear.Vec2z((float) (0), (float) (0)));
					Vec2 selection_offset_end = (Vec2) (Nuklear.Vec2z((float) (0), (float) (0)));
					int selection_begin = (int) ((edit.select_start) < (edit.select_end) ? (edit.select_start) : (edit.select_end));
					int selection_end = (int) ((edit.select_start) < (edit.select_end) ? (edit.select_end) : (edit.select_start));
					float line_width = (float) (0.0f);
					if (((text) != null) && ((len) != 0))
					{
						float glyph_width;
						int glyph_len = (int) (0);
						char unicode = (char) 0;
						int text_len = (int) (0);
						int glyphs = (int) (0);
						int row_begin = (int) (0);
						glyph_len = (int) (Nuklear.UtfDecode(text, &unicode, (int) (len)));
						glyph_width = (float) (font.width((Handle) (font.userdata), (float) (font.height), text, (int) (glyph_len)));
						line_width = (float) (0);
						while (((text_len) < (len)) && ((glyph_len) != 0))
						{
							if ((cursor_ptr == null) && ((glyphs) == (edit.cursor)))
							{
								int glyph_offset;
								Vec2 out_offset = new Vec2();
								Vec2 row_size = new Vec2();
								char* remaining;
								cursor_pos.y = (float) ((float) (total_lines - 1)*row_height);
								row_size =
									(Vec2)
										(font.TextCalculateTextBounds(text + row_begin, (int) (text_len - row_begin), (float) (row_height), &remaining,
											&out_offset, &glyph_offset, (int) (Nuklear.NK_STOP_ON_NEW_LINE)));
								cursor_pos.x = (float) (row_size.x);
								cursor_ptr = text + text_len;
							}
							if (((select_begin_ptr == null) && (edit.select_start != edit.select_end)) && ((glyphs) == (selection_begin)))
							{
								int glyph_offset;
								Vec2 out_offset = new Vec2();
								Vec2 row_size = new Vec2();
								char* remaining;
								selection_offset_start.y = (float) ((float) ((total_lines - 1) < (0) ? (0) : (total_lines - 1))*row_height);
								row_size =
									(Vec2)
										(font.TextCalculateTextBounds(text + row_begin, (int) (text_len - row_begin), (float) (row_height), &remaining,
											&out_offset, &glyph_offset, (int) (Nuklear.NK_STOP_ON_NEW_LINE)));
								selection_offset_start.x = (float) (row_size.x);
								select_begin_ptr = text + text_len;
							}
							if (((select_end_ptr == null) && (edit.select_start != edit.select_end)) && ((glyphs) == (selection_end)))
							{
								int glyph_offset;
								Vec2 out_offset = new Vec2();
								Vec2 row_size = new Vec2();
								char* remaining;
								selection_offset_end.y = (float) ((float) (total_lines - 1)*row_height);
								row_size =
									(Vec2)
										(font.TextCalculateTextBounds(text + row_begin, (int) (text_len - row_begin), (float) (row_height), &remaining,
											&out_offset, &glyph_offset, (int) (Nuklear.NK_STOP_ON_NEW_LINE)));
								selection_offset_end.x = (float) (row_size.x);
								select_end_ptr = text + text_len;
							}
							if ((unicode) == ('\n'))
							{
								text_size.x = (float) ((text_size.x) < (line_width) ? (line_width) : (text_size.x));
								total_lines++;
								line_width = (float) (0);
								text_len++;
								glyphs++;
								row_begin = (int) (text_len);
								glyph_len = (int) (Nuklear.UtfDecode(text + text_len, &unicode, (int) (len - text_len)));
								glyph_width =
									(float) (font.width((Handle) (font.userdata), (float) (font.height), text + text_len, (int) (glyph_len)));
								continue;
							}
							glyphs++;
							text_len += (int) (glyph_len);
							line_width += (float) (glyph_width);
							glyph_len = (int) (Nuklear.UtfDecode(text + text_len, &unicode, (int) (len - text_len)));
							glyph_width =
								(float) (font.width((Handle) (font.userdata), (float) (font.height), text + text_len, (int) (glyph_len)));
							continue;
						}
						text_size.y = (float) ((float) (total_lines)*row_height);
						if ((cursor_ptr == null) && ((edit.cursor) == (edit._string_.len)))
						{
							cursor_pos.x = (float) (line_width);
							cursor_pos.y = (float) (text_size.y - row_height);
						}
					}
					{
						if ((cursor_follow) != 0)
						{
							if ((flags & Nuklear.NK_EDIT_NO_HORIZONTAL_SCROLL) == 0)
							{
								float scroll_increment = (float) (area.w*0.25f);
								if ((cursor_pos.x) < (edit.scrollbar.x))
									edit.scrollbar.x =
										((float) ((int) ((0.0f) < (cursor_pos.x - scroll_increment) ? (cursor_pos.x - scroll_increment) : (0.0f))));
								if ((cursor_pos.x) >= (edit.scrollbar.x + area.w))
									edit.scrollbar.x = ((float) ((int) ((0.0f) < (cursor_pos.x) ? (cursor_pos.x) : (0.0f))));
							}
							else edit.scrollbar.x = (float) (0);
							if ((flags & Nuklear.NK_EDIT_MULTILINE) != 0)
							{
								if ((cursor_pos.y) < (edit.scrollbar.y))
									edit.scrollbar.y = (float) ((0.0f) < (cursor_pos.y - row_height) ? (cursor_pos.y - row_height) : (0.0f));
								if ((cursor_pos.y) >= (edit.scrollbar.y + area.h)) edit.scrollbar.y = (float) (edit.scrollbar.y + row_height);
							}
							else edit.scrollbar.y = (float) (0);
						}
						if ((flags & Nuklear.NK_EDIT_MULTILINE) != 0)
						{
							uint ws = 0;
							Rect scroll = new Rect();
							float scroll_target;
							float scroll_offset;
							float scroll_step;
							float scroll_inc;
							scroll = (Rect) (area);
							scroll.x = (float) ((bounds.x + bounds.w - style.border) - style.scrollbar_size.x);
							scroll.w = (float) (style.scrollbar_size.x);
							scroll_offset = (float) (edit.scrollbar.y);
							scroll_step = (float) (scroll.h*0.10f);
							scroll_inc = (float) (scroll.h*0.01f);
							scroll_target = (float) (text_size.y);
							edit.scrollbar.y =
								(float)
									(DoScrollbarv(ref ws, (Rect) (scroll), (int) (0), (float) (scroll_offset), (float) (scroll_target),
										(float) (scroll_step), (float) (scroll_inc), style.scrollbar, _in_, font));
						}
					}
					{
						Color background_color = new Color();
						Color text_color = new Color();
						Color sel_background_color = new Color();
						Color sel_text_color = new Color();
						Color cursor_color = new Color();
						Color cursor_text_color = new Color();
						StyleItem background;
						PushScissor((Rect) (clip));
						if ((state & Nuklear.NK_WIDGET_STATE_ACTIVED) != 0)
						{
							background = style.active;
							text_color = (Color) (style.text_active);
							sel_text_color = (Color) (style.selected_text_hover);
							sel_background_color = (Color) (style.selected_hover);
							cursor_color = (Color) (style.cursor_hover);
							cursor_text_color = (Color) (style.cursor_text_hover);
						}
						else if ((state & Nuklear.NK_WIDGET_STATE_HOVER) != 0)
						{
							background = style.hover;
							text_color = (Color) (style.text_hover);
							sel_text_color = (Color) (style.selected_text_hover);
							sel_background_color = (Color) (style.selected_hover);
							cursor_text_color = (Color) (style.cursor_text_hover);
							cursor_color = (Color) (style.cursor_hover);
						}
						else
						{
							background = style.normal;
							text_color = (Color) (style.text_normal);
							sel_text_color = (Color) (style.selected_text_normal);
							sel_background_color = (Color) (style.selected_normal);
							cursor_color = (Color) (style.cursor_normal);
							cursor_text_color = (Color) (style.cursor_text_normal);
						}
						if ((background.type) == (Nuklear.NK_STYLE_ITEM_IMAGE))
							background_color = (Color) (Nuklear.Rgba((int) (0), (int) (0), (int) (0), (int) (0)));
						else background_color = (Color) (background.data.color);
						if ((edit.select_start) == (edit.select_end))
						{
							char* begin = edit._string_.GetConst();
							int l = (int) (edit._string_.LenChar());
							EditDrawText(style, (float) (area.x - edit.scrollbar.x), (float) (area.y - edit.scrollbar.y), (float) (0), begin,
								(int) (l), (float) (row_height), font, (Color) (background_color), (Color) (text_color),
								(int) (Nuklear.nk_false));
						}
						else
						{
							if ((edit.select_start != edit.select_end) && ((selection_begin) > (0)))
							{
								char* begin = edit._string_.GetConst();
								EditDrawText(style, (float) (area.x - edit.scrollbar.x), (float) (area.y - edit.scrollbar.y), (float) (0), begin,
									(int) (select_begin_ptr - begin), (float) (row_height), font, (Color) (background_color), (Color) (text_color),
									(int) (Nuklear.nk_false));
							}
							if (edit.select_start != edit.select_end)
							{
								if (select_end_ptr == null)
								{
									char* begin = edit._string_.GetConst();
									select_end_ptr = begin + edit._string_.LenChar();
								}
								EditDrawText(style, (float) (area.x - edit.scrollbar.x),
									(float) (area.y + selection_offset_start.y - edit.scrollbar.y), (float) (selection_offset_start.x),
									select_begin_ptr, (int) (select_end_ptr - select_begin_ptr), (float) (row_height), font,
									(Color) (sel_background_color), (Color) (sel_text_color), (int) (Nuklear.nk_true));
							}
							if (((edit.select_start != edit.select_end) && ((selection_end) < (edit._string_.len))))
							{
								char* begin = select_end_ptr;
								char* end = edit._string_.GetConst() + edit._string_.LenChar();
								EditDrawText(style, (float) (area.x - edit.scrollbar.x),
									(float) (area.y + selection_offset_end.y - edit.scrollbar.y), (float) (selection_offset_end.x), begin,
									(int) (end - begin), (float) (row_height), font, (Color) (background_color), (Color) (text_color),
									(int) (Nuklear.nk_true));
							}
						}
						if ((edit.select_start) == (edit.select_end))
						{
							if (((edit.cursor) >= (edit._string_.Len())) || (((cursor_ptr) != null) && ((*cursor_ptr) == ('\n'))))
							{
								Rect cursor = new Rect();
								cursor.w = (float) (style.cursor_size);
								cursor.h = (float) (font.height);
								cursor.x = (float) (area.x + cursor_pos.x - edit.scrollbar.x);
								cursor.y = (float) (area.y + cursor_pos.y + row_height/2.0f - cursor.h/2.0f);
								cursor.y -= (float) (edit.scrollbar.y);
								FillRect((Rect) (cursor), (float) (0), (Color) (cursor_color));
							}
							else
							{
								int glyph_len;
								Rect label = new Rect();
								Text txt = new Text();
								char unicode;
								glyph_len = (int) (Nuklear.UtfDecode(cursor_ptr, &unicode, (int) (4)));
								label.x = (float) (area.x + cursor_pos.x - edit.scrollbar.x);
								label.y = (float) (area.y + cursor_pos.y - edit.scrollbar.y);
								label.w = (float) (font.width((Handle) (font.userdata), (float) (font.height), cursor_ptr, (int) (glyph_len)));
								label.h = (float) (row_height);
								txt.padding = (Vec2) (Nuklear.Vec2z((float) (0), (float) (0)));
								txt.background = (Color) (cursor_color);
								txt.text = (Color) (cursor_text_color);
								FillRect((Rect) (label), (float) (0), (Color) (cursor_color));
								WidgetText((Rect) (label), cursor_ptr, (int) (glyph_len), &txt, (uint) (Nuklear.NK_TEXT_LEFT), font);
							}
						}
					}
				}
				else
				{
					int l = (int) (edit._string_.LenChar());
					char* begin = edit._string_.GetConst();
					StyleItem background;
					Color background_color = new Color();
					Color text_color = new Color();
					PushScissor((Rect) (clip));
					if ((state & Nuklear.NK_WIDGET_STATE_ACTIVED) != 0)
					{
						background = style.active;
						text_color = (Color) (style.text_active);
					}
					else if ((state & Nuklear.NK_WIDGET_STATE_HOVER) != 0)
					{
						background = style.hover;
						text_color = (Color) (style.text_hover);
					}
					else
					{
						background = style.normal;
						text_color = (Color) (style.text_normal);
					}
					if ((background.type) == (Nuklear.NK_STYLE_ITEM_IMAGE))
						background_color = (Color) (Nuklear.Rgba((int) (0), (int) (0), (int) (0), (int) (0)));
					else background_color = (Color) (background.data.color);
					EditDrawText(style, (float) (area.x - edit.scrollbar.x), (float) (area.y - edit.scrollbar.y), (float) (0), begin,
						(int) (l), (float) (row_height), font, (Color) (background_color), (Color) (text_color), (int) (Nuklear.nk_false));
				}
				PushScissor((Rect) (old_clip));
			}

			return (uint) (ret);
		}

		public void DrawProperty(StyleProperty style, Rect* bounds, Rect* label, uint state, char* name, int len,
			UserFont font)
		{
			Text text = new Text();
			StyleItem background;
			if ((state & Nuklear.NK_WIDGET_STATE_ACTIVED) != 0)
			{
				background = style.active;
				text.text = (Color) (style.label_active);
			}
			else if ((state & Nuklear.NK_WIDGET_STATE_HOVER) != 0)
			{
				background = style.hover;
				text.text = (Color) (style.label_hover);
			}
			else
			{
				background = style.normal;
				text.text = (Color) (style.label_normal);
			}

			if ((background.type) == (Nuklear.NK_STYLE_ITEM_IMAGE))
			{
				DrawImage((Rect) (*bounds), background.data.image, (Color) (Nuklear.nk_white));
				text.background = (Color) (Nuklear.Rgba((int) (0), (int) (0), (int) (0), (int) (0)));
			}
			else
			{
				text.background = (Color) (background.data.color);
				FillRect((Rect) (*bounds), (float) (style.rounding), (Color) (background.data.color));
				StrokeRect((Rect) (*bounds), (float) (style.rounding), (float) (style.border), (Color) (background.data.color));
			}

			text.padding = (Vec2) (Nuklear.Vec2z((float) (0), (float) (0)));
			WidgetText((Rect) (*label), name, (int) (len), &text, (uint) (Nuklear.NK_TEXT_CENTERED), font);
		}

		public void DoProperty(ref uint ws, Rect property, char* name, PropertyVariant* variant, float inc_per_pixel,
			char* buffer, ref int len, ref int state, ref int cursor, ref int select_begin, ref int select_end,
			StyleProperty style, int filter, Input _in_, UserFont font, TextEdit text_edit, int behavior)
		{
			Nuklear.NkPluginFilter[] filters = new Nuklear.NkPluginFilter[2];
			filters[0] = TextEdit.FilterDecimal;
			filters[1] = TextEdit.FilterFloat;

			int active;
			int old;
			int num_len = 0;
			int name_len;
			char* _string_ = stackalloc char[64];
			float size;
			char* dst = null;
			bool length_is_len = false;
			int length;
			Rect left = new Rect();
			Rect right = new Rect();
			Rect label = new Rect();
			Rect edit = new Rect();
			Rect empty = new Rect();
			left.h = (float) (font.height/2);
			left.w = (float) (left.h);
			left.x = (float) (property.x + style.border + style.padding.x);
			left.y = (float) (property.y + style.border + property.h/2.0f - left.h/2);
			name_len = (int) (Nuklear.Strlen(name));
			size = (float) (font.width((Handle) (font.userdata), (float) (font.height), name, (int) (name_len)));
			label.x = (float) (left.x + left.w + style.padding.x);
			label.w = (float) (size + 2*style.padding.x);
			label.y = (float) (property.y + style.border + style.padding.y);
			label.h = (float) (property.h - (2*style.border + 2*style.padding.y));
			right.y = (float) (left.y);
			right.w = (float) (left.w);
			right.h = (float) (left.h);
			right.x = (float) (property.x + property.w - (right.w + style.padding.x));
			if ((state) == (Nuklear.NK_PROPERTY_EDIT))
			{
				size = (float) (font.width((Handle) (font.userdata), (float) (font.height), buffer, (int) (len)));
				size += (float) (style.edit.cursor_size);
				length = len;
				length_is_len = true;
				dst = buffer;
			}
			else
			{
				switch (variant->kind)
				{
					default:
						break;
					case Nuklear.NK_PROPERTY_INT:
						Nuklear.Itoa(_string_, (int) (variant->value.i));
						num_len = (int) (Nuklear.Strlen(_string_));
						break;
					case Nuklear.NK_PROPERTY_FLOAT:
						Nuklear.Dtoa(_string_, (double) (variant->value.f));
						num_len = (int) (Nuklear.StringFloatLimit(_string_, (int) (2)));
						break;
					case Nuklear.NK_PROPERTY_DOUBLE:
						Nuklear.Dtoa(_string_, (double) (variant->value.d));
						num_len = (int) (Nuklear.StringFloatLimit(_string_, (int) (2)));
						break;
				}
				size = (float) (font.width((Handle) (font.userdata), (float) (font.height), _string_, (int) (num_len)));
				dst = _string_;
				length = num_len;
			}

			edit.w = (float) (size + 2*style.padding.x);
			edit.w = (float) ((edit.w) < (right.x - (label.x + label.w)) ? (edit.w) : (right.x - (label.x + label.w)));
			edit.x = (float) (right.x - (edit.w + style.padding.x));
			edit.y = (float) (property.y + style.border);
			edit.h = (float) (property.h - (2*style.border));
			empty.w = (float) (edit.x - (label.x + label.w));
			empty.x = (float) (label.x + label.w);
			empty.y = (float) (property.y);
			empty.h = (float) (property.h);
			old = (int) ((state) == (Nuklear.NK_PROPERTY_EDIT) ? 1 : 0);
			if (_in_ != null)
			{
				_in_.PropertyBehavior(ref ws, (Rect) (property), (Rect) (label), (Rect) (edit), (Rect) (empty), ref state, variant,
					(float) (inc_per_pixel));
			}
			if ((style.draw_begin) != null) style.draw_begin(this, (Handle) (style.userdata));
			DrawProperty(style, &property, &label, (uint) (ws), name, (int) (name_len), font);
			if ((style.draw_end) != null) style.draw_end(this, (Handle) (style.userdata));
			if ((DoButtonSymbol(ref ws, (Rect) (left), (int) (style.sym_left), (int) (behavior), style.dec_button, _in_, font)) !=
			    0)
			{
				switch (variant->kind)
				{
					default:
						break;
					case Nuklear.NK_PROPERTY_INT:
						variant->value.i =
							(int)
								(((variant->value.i - variant->step.i) < (variant->max_value.i)
									? (variant->value.i - variant->step.i)
									: (variant->max_value.i)) < (variant->min_value.i)
									? (variant->min_value.i)
									: ((variant->value.i - variant->step.i) < (variant->max_value.i)
										? (variant->value.i - variant->step.i)
										: (variant->max_value.i)));
						break;
					case Nuklear.NK_PROPERTY_FLOAT:
						variant->value.f =
							(float)
								(((variant->value.f - variant->step.f) < (variant->max_value.f)
									? (variant->value.f - variant->step.f)
									: (variant->max_value.f)) < (variant->min_value.f)
									? (variant->min_value.f)
									: ((variant->value.f - variant->step.f) < (variant->max_value.f)
										? (variant->value.f - variant->step.f)
										: (variant->max_value.f)));
						break;
					case Nuklear.NK_PROPERTY_DOUBLE:
						variant->value.d =
							(double)
								(((variant->value.d - variant->step.d) < (variant->max_value.d)
									? (variant->value.d - variant->step.d)
									: (variant->max_value.d)) < (variant->min_value.d)
									? (variant->min_value.d)
									: ((variant->value.d - variant->step.d) < (variant->max_value.d)
										? (variant->value.d - variant->step.d)
										: (variant->max_value.d)));
						break;
				}
			}

			if ((DoButtonSymbol(ref ws, (Rect) (right), (int) (style.sym_right), (int) (behavior), style.inc_button, _in_, font)) !=
			    0)
			{
				switch (variant->kind)
				{
					default:
						break;
					case Nuklear.NK_PROPERTY_INT:
						variant->value.i =
							(int)
								(((variant->value.i + variant->step.i) < (variant->max_value.i)
									? (variant->value.i + variant->step.i)
									: (variant->max_value.i)) < (variant->min_value.i)
									? (variant->min_value.i)
									: ((variant->value.i + variant->step.i) < (variant->max_value.i)
										? (variant->value.i + variant->step.i)
										: (variant->max_value.i)));
						break;
					case Nuklear.NK_PROPERTY_FLOAT:
						variant->value.f =
							(float)
								(((variant->value.f + variant->step.f) < (variant->max_value.f)
									? (variant->value.f + variant->step.f)
									: (variant->max_value.f)) < (variant->min_value.f)
									? (variant->min_value.f)
									: ((variant->value.f + variant->step.f) < (variant->max_value.f)
										? (variant->value.f + variant->step.f)
										: (variant->max_value.f)));
						break;
					case Nuklear.NK_PROPERTY_DOUBLE:
						variant->value.d =
							(double)
								(((variant->value.d + variant->step.d) < (variant->max_value.d)
									? (variant->value.d + variant->step.d)
									: (variant->max_value.d)) < (variant->min_value.d)
									? (variant->min_value.d)
									: ((variant->value.d + variant->step.d) < (variant->max_value.d)
										? (variant->value.d + variant->step.d)
										: (variant->max_value.d)));
						break;
				}
			}

			if ((old != Nuklear.NK_PROPERTY_EDIT) && ((state) == (Nuklear.NK_PROPERTY_EDIT)))
			{
				Nuklear.Memcopy(buffer, dst, (ulong) (length));
				cursor = (int) (Nuklear.UtfLen(buffer, (int) (length)));
				len = (int) (length);
				length = len;
				dst = buffer;
				active = (int) (0);
			}
			else active = (int) ((state) == (Nuklear.NK_PROPERTY_EDIT) ? 1 : 0);
			text_edit.ClearState((int) (Nuklear.NK_TEXT_EDIT_SINGLE_LINE), filters[filter]);
			text_edit.active = ((byte) (active));
			text_edit._string_.len = (int) (length);
			text_edit.cursor =
				(int) (((cursor) < (length) ? (cursor) : (length)) < (0) ? (0) : ((cursor) < (length) ? (cursor) : (length)));
			text_edit.select_start =
				(int)
					(((select_begin) < (length) ? (select_begin) : (length)) < (0)
						? (0)
						: ((select_begin) < (length) ? (select_begin) : (length)));
			text_edit.select_end =
				(int)
					(((select_end) < (length) ? (select_end) : (length)) < (0)
						? (0)
						: ((select_end) < (length) ? (select_end) : (length)));
			text_edit._string_.buffer.allocated = ((ulong) (length));
			text_edit._string_.buffer.memory.size = (ulong) (64);
			text_edit._string_.buffer.memory.ptr = dst;
			text_edit._string_.buffer.size = (ulong) (64);
			text_edit.mode = (byte) (Nuklear.NK_TEXT_EDIT_MODE_INSERT);
			DoEdit(ref ws, (Rect) (edit), (uint) (Nuklear.NK_EDIT_FIELD | Nuklear.NK_EDIT_AUTO_SELECT), filters[filter],
				text_edit, style.edit, ((state) == (Nuklear.NK_PROPERTY_EDIT)) ? _in_ : null, font);

			if (length_is_len)
			{
				len = (int)(text_edit._string_.len);
			}

			cursor = (int) (text_edit.cursor);
			select_begin = (int) (text_edit.select_start);
			select_end = (int) (text_edit.select_end);
			if (((text_edit.active) != 0) && ((_in_.IsKeyPressed((int) (Nuklear.NK_KEY_ENTER))) != 0))
				text_edit.active = (byte) (Nuklear.nk_false);
			if (((active) != 0) && (text_edit.active == 0))
			{
				state = (int) (Nuklear.NK_PROPERTY_DEFAULT);
				buffer[len] = ('\0');
				switch (variant->kind)
				{
					default:
						break;
					case Nuklear.NK_PROPERTY_INT:
						variant->value.i = (int) (Nuklear.Strtoi(buffer, null));
						variant->value.i =
							(int)
								(((variant->value.i) < (variant->max_value.i) ? (variant->value.i) : (variant->max_value.i)) <
								 (variant->min_value.i)
									? (variant->min_value.i)
									: ((variant->value.i) < (variant->max_value.i) ? (variant->value.i) : (variant->max_value.i)));
						break;
					case Nuklear.NK_PROPERTY_FLOAT:
						Nuklear.StringFloatLimit(buffer, (int) (2));
						variant->value.f = (float) (Nuklear.Strtof(buffer, null));
						variant->value.f =
							(float)
								(((variant->value.f) < (variant->max_value.f) ? (variant->value.f) : (variant->max_value.f)) <
								 (variant->min_value.f)
									? (variant->min_value.f)
									: ((variant->value.f) < (variant->max_value.f) ? (variant->value.f) : (variant->max_value.f)));
						break;
					case Nuklear.NK_PROPERTY_DOUBLE:
						Nuklear.StringFloatLimit(buffer, (int) (2));
						variant->value.d = (double) (Nuklear.Strtod(buffer, null));
						variant->value.d =
							(double)
								(((variant->value.d) < (variant->max_value.d) ? (variant->value.d) : (variant->max_value.d)) <
								 (variant->min_value.d)
									? (variant->min_value.d)
									: ((variant->value.d) < (variant->max_value.d) ? (variant->value.d) : (variant->max_value.d)));
						break;
				}
			}

		}

		public void DrawColorPicker(Rect* matrix, Rect* hue_bar, Rect* alpha_bar, Colorf col)
		{
			Color black = (Color) (Nuklear.nk_black);
			Color white = (Color) (Nuklear.nk_white);
			Color black_trans = new Color();
			float crosshair_size = (float) (7.0f);
			Color temp = new Color();
			float* hsva = stackalloc float[4];
			float line_y;
			int i;
			col.HsvaFv(hsva);
			for (i = (int) (0); (i) < (6); ++i)
			{
				FillRectMultiColor(
					(Rect)
						(Nuklear.Rectz((float) (hue_bar->x), (float) (hue_bar->y + (float) (i)*(hue_bar->h/6.0f) + 0.5f),
							(float) (hue_bar->w), (float) ((hue_bar->h/6.0f) + 0.5f))), (Color) (Nuklear.hue_colors[i]),
					(Color) (Nuklear.hue_colors[i]), (Color) (Nuklear.hue_colors[i + 1]), (Color) (Nuklear.hue_colors[i + 1]));
			}
			line_y = ((float) ((int) (hue_bar->y + hsva[0]*matrix->h + 0.5f)));
			StrokeLine((float) (hue_bar->x - 1), (float) (line_y), (float) (hue_bar->x + hue_bar->w + 2), (float) (line_y),
				(float) (1), (Color) (Nuklear.Rgb((int) (255), (int) (255), (int) (255))));
			if ((alpha_bar) != null)
			{
				float alpha = (float) ((0) < ((1.0f) < (col.a) ? (1.0f) : (col.a)) ? ((1.0f) < (col.a) ? (1.0f) : (col.a)) : (0));
				line_y = ((float) ((int) (alpha_bar->y + (1.0f - alpha)*matrix->h + 0.5f)));
				FillRectMultiColor((Rect) (*alpha_bar), (Color) (white), (Color) (white), (Color) (black), (Color) (black));
				StrokeLine((float) (alpha_bar->x - 1), (float) (line_y), (float) (alpha_bar->x + alpha_bar->w + 2), (float) (line_y),
					(float) (1), (Color) (Nuklear.Rgb((int) (255), (int) (255), (int) (255))));
			}

			temp = (Color) (Nuklear.HsvF((float) (hsva[0]), (float) (1.0f), (float) (1.0f)));
			FillRectMultiColor((Rect) (*matrix), (Color) (white), (Color) (temp), (Color) (temp), (Color) (white));
			FillRectMultiColor((Rect) (*matrix), (Color) (black_trans), (Color) (black_trans), (Color) (black), (Color) (black));
			{
				Vec2 p = new Vec2();
				float S = (float) (hsva[1]);
				float V = (float) (hsva[2]);
				p.x = ((float) ((int) (matrix->x + S*matrix->w)));
				p.y = ((float) ((int) (matrix->y + (1.0f - V)*matrix->h)));
				StrokeLine((float) (p.x - crosshair_size), (float) (p.y), (float) (p.x - 2), (float) (p.y), (float) (1.0f),
					(Color) (white));
				StrokeLine((float) (p.x + crosshair_size + 1), (float) (p.y), (float) (p.x + 3), (float) (p.y), (float) (1.0f),
					(Color) (white));
				StrokeLine((float) (p.x), (float) (p.y + crosshair_size + 1), (float) (p.x), (float) (p.y + 3), (float) (1.0f),
					(Color) (white));
				StrokeLine((float) (p.x), (float) (p.y - crosshair_size), (float) (p.x), (float) (p.y - 2), (float) (1.0f),
					(Color) (white));
			}

		}

		public int DoColorPicker(ref uint state, Colorf* col, int fmt, Rect bounds, Vec2 padding, Input _in_, UserFont font)
		{
			int ret = (int) (0);
			Rect matrix = new Rect();
			Rect hue_bar = new Rect();
			Rect alpha_bar = new Rect();
			float bar_w;
			if ((((col == null)) || (state == null)) || (font == null)) return (int) (ret);
			bar_w = (float) (font.height);
			bounds.x += (float) (padding.x);
			bounds.y += (float) (padding.x);
			bounds.w -= (float) (2*padding.x);
			bounds.h -= (float) (2*padding.y);
			matrix.x = (float) (bounds.x);
			matrix.y = (float) (bounds.y);
			matrix.h = (float) (bounds.h);
			matrix.w = (float) (bounds.w - (3*padding.x + 2*bar_w));
			hue_bar.w = (float) (bar_w);
			hue_bar.y = (float) (bounds.y);
			hue_bar.h = (float) (matrix.h);
			hue_bar.x = (float) (matrix.x + matrix.w + padding.x);
			alpha_bar.x = (float) (hue_bar.x + hue_bar.w + padding.x);
			alpha_bar.y = (float) (bounds.y);
			alpha_bar.w = (float) (bar_w);
			alpha_bar.h = (float) (matrix.h);
			ret =
				(int)
					(bounds.ColorPickerBehavior(ref state, &matrix, &hue_bar, ((fmt) == (Nuklear.NK_RGBA)) ? &alpha_bar : null, col,
						_in_));
			DrawColorPicker(&matrix, &hue_bar, ((fmt) == (Nuklear.NK_RGBA)) ? &alpha_bar : null, (Colorf) (*col));
			return (int) (ret);
		}
	}
}